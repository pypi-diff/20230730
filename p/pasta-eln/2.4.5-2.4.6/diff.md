# Comparing `tmp/pasta_eln-2.4.5-py3-none-any.whl.zip` & `tmp/pasta_eln-2.4.6-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,52 +1,52 @@
-Zip file size: 130759 bytes, number of entries: 50
--rw-r--r--  2.0 unx       46 b- defN 23-Jul-16 10:55 pasta_eln/__init__.py
--rw-r--r--  2.0 unx    34856 b- defN 23-Jul-16 10:55 pasta_eln/backend.py
--rw-r--r--  2.0 unx    14028 b- defN 23-Jul-16 10:55 pasta_eln/cli.py
--rw-r--r--  2.0 unx     1453 b- defN 23-Jul-16 10:55 pasta_eln/communicate.py
--rw-r--r--  2.0 unx    43182 b- defN 23-Jul-16 10:55 pasta_eln/database.py
--rw-r--r--  2.0 unx     1660 b- defN 23-Jul-16 10:55 pasta_eln/dialogConfig.py
--rw-r--r--  2.0 unx     4036 b- defN 23-Jul-16 10:55 pasta_eln/dialogConfigAuthors.py
--rw-r--r--  2.0 unx     3520 b- defN 23-Jul-16 10:55 pasta_eln/dialogConfigGUI.py
--rw-r--r--  2.0 unx     5178 b- defN 23-Jul-16 10:55 pasta_eln/dialogConfigSetupLinux.py
--rw-r--r--  2.0 unx     6323 b- defN 23-Jul-16 10:55 pasta_eln/dialogConfigSetupWindows.py
--rw-r--r--  2.0 unx    20962 b- defN 23-Jul-16 10:55 pasta_eln/dialogForm.py
--rw-r--r--  2.0 unx     1291 b- defN 23-Jul-16 10:55 pasta_eln/dialogOntology.py
--rw-r--r--  2.0 unx     9004 b- defN 23-Jul-16 10:55 pasta_eln/dialogProjectGroup.py
--rw-r--r--  2.0 unx     4715 b- defN 23-Jul-16 10:55 pasta_eln/dialogTableHeader.py
--rw-r--r--  2.0 unx     5958 b- defN 23-Jul-16 10:55 pasta_eln/fixedStrings.py
--rw-r--r--  2.0 unx    10614 b- defN 23-Jul-16 10:55 pasta_eln/gui.py
--rw-r--r--  2.0 unx     6268 b- defN 23-Jul-16 10:55 pasta_eln/handleDictionaries.py
--rw-r--r--  2.0 unx    16995 b- defN 23-Jul-16 10:55 pasta_eln/inputOutput.py
--rw-r--r--  2.0 unx    23330 b- defN 23-Jul-16 10:55 pasta_eln/installationTools.py
--rw-r--r--  2.0 unx    10521 b- defN 23-Jul-16 10:55 pasta_eln/miscTools.py
--rw-r--r--  2.0 unx     5714 b- defN 23-Jul-16 10:55 pasta_eln/mixin_cli.py
--rw-r--r--  2.0 unx     3851 b- defN 23-Jul-16 10:55 pasta_eln/printer.py
--rw-r--r--  2.0 unx    21356 b- defN 23-Jul-16 10:55 pasta_eln/serverActions.py
--rw-r--r--  2.0 unx    11331 b- defN 23-Jul-16 10:55 pasta_eln/style.py
--rw-r--r--  2.0 unx     2372 b- defN 23-Jul-16 10:55 pasta_eln/tempStrings.py
--rw-r--r--  2.0 unx     1519 b- defN 23-Jul-16 10:55 pasta_eln/widgetBody.py
--rw-r--r--  2.0 unx    11684 b- defN 23-Jul-16 10:55 pasta_eln/widgetDetails.py
--rw-r--r--  2.0 unx     1666 b- defN 23-Jul-16 10:55 pasta_eln/widgetDocTypes.py
--rw-r--r--  2.0 unx    11998 b- defN 23-Jul-16 10:55 pasta_eln/widgetProject.py
--rw-r--r--  2.0 unx     8977 b- defN 23-Jul-16 10:55 pasta_eln/widgetProjectLeafRenderer.py
--rw-r--r--  2.0 unx     7349 b- defN 23-Jul-16 10:55 pasta_eln/widgetProjectTreeView.py
--rw-r--r--  2.0 unx     9539 b- defN 23-Jul-16 10:55 pasta_eln/widgetSidebar.py
--rw-r--r--  2.0 unx    18522 b- defN 23-Jul-16 10:55 pasta_eln/widgetTable.py
--rw-r--r--  2.0 unx      356 b- defN 23-Jul-16 10:55 pasta_eln/Extractors/README.md
--rw-r--r--  2.0 unx     4895 b- defN 23-Jul-16 10:55 pasta_eln/Extractors/extractor_csv.py
--rw-r--r--  2.0 unx     1275 b- defN 23-Jul-16 10:55 pasta_eln/Extractors/extractor_jpeg.py
--rw-r--r--  2.0 unx     1560 b- defN 23-Jul-16 10:55 pasta_eln/Extractors/extractor_jpg.py
--rw-r--r--  2.0 unx      953 b- defN 23-Jul-16 10:55 pasta_eln/Extractors/extractor_json.py
--rw-r--r--  2.0 unx      681 b- defN 23-Jul-16 10:55 pasta_eln/Extractors/extractor_md.py
--rw-r--r--  2.0 unx     1875 b- defN 23-Jul-16 10:55 pasta_eln/Extractors/extractor_png.py
--rw-r--r--  2.0 unx      187 b- defN 23-Jul-16 10:55 pasta_eln/Resources/ExampleMeasurements/simple.csv
--rw-r--r--  2.0 unx     9450 b- defN 23-Jul-16 10:55 pasta_eln/Resources/ExampleMeasurements/simple.png
--rw-r--r--  2.0 unx     5694 b- defN 23-Jul-16 10:55 pasta_eln/Resources/Icons/favicon64.ico
--rw-r--r--  2.0 unx     2161 b- defN 23-Jul-16 10:55 pasta_eln/Resources/Icons/favicon64.png
--rw-r--r--  2.0 unx     1613 b- defN 23-Jul-16 10:55 pasta_eln-2.4.5.dist-info/LICENSE
--rw-r--r--  2.0 unx     3541 b- defN 23-Jul-16 10:55 pasta_eln-2.4.5.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Jul-16 10:55 pasta_eln-2.4.5.dist-info/WHEEL
--rw-r--r--  2.0 unx      150 b- defN 23-Jul-16 10:55 pasta_eln-2.4.5.dist-info/entry_points.txt
--rw-r--r--  2.0 unx       10 b- defN 23-Jul-16 10:55 pasta_eln-2.4.5.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     4292 b- defN 23-Jul-16 10:55 pasta_eln-2.4.5.dist-info/RECORD
-50 files, 378603 bytes uncompressed, 123949 bytes compressed:  67.3%
+Zip file size: 133939 bytes, number of entries: 50
+-rw-r--r--  2.0 unx       46 b- defN 23-Jul-30 15:41 pasta_eln/__init__.py
+-rw-r--r--  2.0 unx    35035 b- defN 23-Jul-30 15:41 pasta_eln/backend.py
+-rw-r--r--  2.0 unx    14068 b- defN 23-Jul-30 15:41 pasta_eln/cli.py
+-rw-r--r--  2.0 unx     1453 b- defN 23-Jul-30 15:41 pasta_eln/communicate.py
+-rw-r--r--  2.0 unx    43523 b- defN 23-Jul-30 15:41 pasta_eln/database.py
+-rw-r--r--  2.0 unx     1660 b- defN 23-Jul-30 15:41 pasta_eln/dialogConfig.py
+-rw-r--r--  2.0 unx     4066 b- defN 23-Jul-30 15:41 pasta_eln/dialogConfigAuthors.py
+-rw-r--r--  2.0 unx     3520 b- defN 23-Jul-30 15:41 pasta_eln/dialogConfigGUI.py
+-rw-r--r--  2.0 unx     5178 b- defN 23-Jul-30 15:41 pasta_eln/dialogConfigSetupLinux.py
+-rw-r--r--  2.0 unx     6511 b- defN 23-Jul-30 15:41 pasta_eln/dialogConfigSetupWindows.py
+-rw-r--r--  2.0 unx    24744 b- defN 23-Jul-30 15:41 pasta_eln/dialogForm.py
+-rw-r--r--  2.0 unx     1291 b- defN 23-Jul-30 15:41 pasta_eln/dialogOntology.py
+-rw-r--r--  2.0 unx     9014 b- defN 23-Jul-30 15:41 pasta_eln/dialogProjectGroup.py
+-rw-r--r--  2.0 unx     4738 b- defN 23-Jul-30 15:41 pasta_eln/dialogTableHeader.py
+-rw-r--r--  2.0 unx     5958 b- defN 23-Jul-30 15:41 pasta_eln/fixedStrings.py
+-rw-r--r--  2.0 unx    11225 b- defN 23-Jul-30 15:41 pasta_eln/gui.py
+-rw-r--r--  2.0 unx     6184 b- defN 23-Jul-30 15:41 pasta_eln/handleDictionaries.py
+-rw-r--r--  2.0 unx    16925 b- defN 23-Jul-30 15:41 pasta_eln/inputOutput.py
+-rw-r--r--  2.0 unx    23476 b- defN 23-Jul-30 15:41 pasta_eln/installationTools.py
+-rw-r--r--  2.0 unx    10448 b- defN 23-Jul-30 15:41 pasta_eln/miscTools.py
+-rw-r--r--  2.0 unx     5547 b- defN 23-Jul-30 15:41 pasta_eln/mixin_cli.py
+-rw-r--r--  2.0 unx     3808 b- defN 23-Jul-30 15:41 pasta_eln/printer.py
+-rw-r--r--  2.0 unx    23353 b- defN 23-Jul-30 15:41 pasta_eln/serverActions.py
+-rw-r--r--  2.0 unx    11440 b- defN 23-Jul-30 15:41 pasta_eln/style.py
+-rw-r--r--  2.0 unx     2555 b- defN 23-Jul-30 15:41 pasta_eln/tempStrings.py
+-rw-r--r--  2.0 unx     1504 b- defN 23-Jul-30 15:41 pasta_eln/widgetBody.py
+-rw-r--r--  2.0 unx    12894 b- defN 23-Jul-30 15:41 pasta_eln/widgetDetails.py
+-rw-r--r--  2.0 unx     1581 b- defN 23-Jul-30 15:41 pasta_eln/widgetDocTypes.py
+-rw-r--r--  2.0 unx    13115 b- defN 23-Jul-30 15:41 pasta_eln/widgetProject.py
+-rw-r--r--  2.0 unx     8870 b- defN 23-Jul-30 15:41 pasta_eln/widgetProjectLeafRenderer.py
+-rw-r--r--  2.0 unx     7499 b- defN 23-Jul-30 15:41 pasta_eln/widgetProjectTreeView.py
+-rw-r--r--  2.0 unx     9430 b- defN 23-Jul-30 15:41 pasta_eln/widgetSidebar.py
+-rw-r--r--  2.0 unx    18500 b- defN 23-Jul-30 15:41 pasta_eln/widgetTable.py
+-rw-r--r--  2.0 unx      356 b- defN 23-Jul-30 15:41 pasta_eln/Extractors/README.md
+-rw-r--r--  2.0 unx     4895 b- defN 23-Jul-30 15:41 pasta_eln/Extractors/extractor_csv.py
+-rw-r--r--  2.0 unx     1275 b- defN 23-Jul-30 15:41 pasta_eln/Extractors/extractor_jpeg.py
+-rw-r--r--  2.0 unx     1560 b- defN 23-Jul-30 15:41 pasta_eln/Extractors/extractor_jpg.py
+-rw-r--r--  2.0 unx      953 b- defN 23-Jul-30 15:41 pasta_eln/Extractors/extractor_json.py
+-rw-r--r--  2.0 unx      681 b- defN 23-Jul-30 15:41 pasta_eln/Extractors/extractor_md.py
+-rw-r--r--  2.0 unx     1875 b- defN 23-Jul-30 15:41 pasta_eln/Extractors/extractor_png.py
+-rw-r--r--  2.0 unx      187 b- defN 23-Jul-30 15:41 pasta_eln/Resources/ExampleMeasurements/simple.csv
+-rw-r--r--  2.0 unx     9450 b- defN 23-Jul-30 15:41 pasta_eln/Resources/ExampleMeasurements/simple.png
+-rw-r--r--  2.0 unx     5694 b- defN 23-Jul-30 15:41 pasta_eln/Resources/Icons/favicon64.ico
+-rw-r--r--  2.0 unx     2161 b- defN 23-Jul-30 15:41 pasta_eln/Resources/Icons/favicon64.png
+-rw-r--r--  2.0 unx     1613 b- defN 23-Jul-30 15:41 pasta_eln-2.4.6.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3541 b- defN 23-Jul-30 15:41 pasta_eln-2.4.6.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jul-30 15:41 pasta_eln-2.4.6.dist-info/WHEEL
+-rw-r--r--  2.0 unx      150 b- defN 23-Jul-30 15:41 pasta_eln-2.4.6.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx       10 b- defN 23-Jul-30 15:41 pasta_eln-2.4.6.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     4292 b- defN 23-Jul-30 15:41 pasta_eln-2.4.6.dist-info/RECORD
+50 files, 387944 bytes uncompressed, 127129 bytes compressed:  67.2%
```

## zipnote {}

```diff
@@ -126,26 +126,26 @@
 
 Filename: pasta_eln/Resources/Icons/favicon64.ico
 Comment: 
 
 Filename: pasta_eln/Resources/Icons/favicon64.png
 Comment: 
 
-Filename: pasta_eln-2.4.5.dist-info/LICENSE
+Filename: pasta_eln-2.4.6.dist-info/LICENSE
 Comment: 
 
-Filename: pasta_eln-2.4.5.dist-info/METADATA
+Filename: pasta_eln-2.4.6.dist-info/METADATA
 Comment: 
 
-Filename: pasta_eln-2.4.5.dist-info/WHEEL
+Filename: pasta_eln-2.4.6.dist-info/WHEEL
 Comment: 
 
-Filename: pasta_eln-2.4.5.dist-info/entry_points.txt
+Filename: pasta_eln-2.4.6.dist-info/entry_points.txt
 Comment: 
 
-Filename: pasta_eln-2.4.5.dist-info/top_level.txt
+Filename: pasta_eln-2.4.6.dist-info/top_level.txt
 Comment: 
 
-Filename: pasta_eln-2.4.5.dist-info/RECORD
+Filename: pasta_eln-2.4.6.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## pasta_eln/__init__.py

```diff
@@ -1,2 +1,2 @@
 """ EMPTY INIT FILE """
-__version__ = "2.4.5"
+__version__ = "2.4.6"
```

## pasta_eln/backend.py

```diff
@@ -48,17 +48,17 @@
       print('**ERROR Configuration file does not exist')
       return
     with open(configFileName,'r', encoding='utf-8') as confFile:
       self.configuration = json.load(confFile)
     if self.configuration['version']!=2:
       print('**ERROR Configuration version does not fit')
       raise ValueError('VersionError')
-    if defaultProjectGroup =="":
+    if not defaultProjectGroup:
       defaultProjectGroup = self.configuration['defaultProjectGroup']
-    if not defaultProjectGroup in self.configuration['projectGroups']:
+    if defaultProjectGroup not in self.configuration['projectGroups']:
       raise ValueError('BadConfigurationFileError')
     projectGroup = self.configuration['projectGroups'][defaultProjectGroup]
     if 'user' in projectGroup['local']:
       n,s = projectGroup['local']['user'], projectGroup['local']['password']
     else:
       n,s = upOut(projectGroup['local']['cred'])[0].split(':')
     databaseName = projectGroup['local']['database']
@@ -112,15 +112,18 @@
       self.cwd     = self.basePath/doc['-branch'][0]['path']
     self.hierStack = doc['-branch'][0]['stack']+[doc['_id']]
     doc['childNum']= doc['-branch'][0]['child']
     # change content
     self.addData('-edit-', doc)
     # change folder-name in database of all children
     if doc['-type'][0][0]=='x' and self.cwd is not None:
-      items = self.db.getView('viewHierarchy/viewPaths', startKey=self.cwd.relative_to(self.basePath).as_posix()+'/')
+      items = self.db.getView(
+          'viewHierarchy/viewPaths',
+          startKey=f'{self.cwd.relative_to(self.basePath).as_posix()}/',
+      )
       for item in items:
         oldPathparts = item['key'].split('/')
         newPathParts = doc['-branch']['path'].split('/')
         newPath = '/'.join(newPathParts+oldPathparts[len(newPathParts):]  )
         # print(item['id']+'  old='+item['key']+'  branch='+str(item['value'][-1])+\
         #      '  child='+str(item['value'][-3])+'  new='+newPath)
         self.db.updateBranch(item['id'], item['value'][-1], item['value'][-3], path=newPath)
@@ -148,31 +151,33 @@
     childNum     = doc.pop('childNum',None)
     path         = None
     oldPath      = None
     operation    = 'c'  #operation of branch/path
     if docType == '-edit-':
       edit = True
       if '-type' not in doc:
-        doc['-type'] = ['x'+str(len(self.hierStack))]
-      if len(hierStack) == 0:
+        doc['-type'] = [f'x{len(self.hierStack)}']
+      if not hierStack:
         hierStack = self.hierStack
       if '_id' not in doc:
         doc['_id'] = hierStack[-1]
       if len(hierStack)>0 and doc['-type'][0][0]=='x':
         hierStack  = hierStack[:-1]
         oldPath    =  doc['-branch'][0]['path']
       elif '-branch' in doc:
         hierStack   = doc['-branch'][0]['stack']
     else:  #new doc
       edit = False
       doc['-type'] = docType.split('/')
       if len(hierStack) == 0:
         hierStack = self.hierStack
-    logging.debug('Add/edit data in cwd:'+str(self.cwd)+' with stack:'+str(hierStack)+' and name: '\
-                 +doc['-name']+' type:'+str(doc['-type'])+' and edit: '+str(edit))
+    logging.debug((((
+        f'Add/edit data in cwd:{str(self.cwd)} with stack:{str(hierStack)} and name: '
+        + doc['-name']) + ' type:') + str(doc['-type']) + ' and edit: ') +
+                  str(edit))
 
     # collect structure-doc and prepare
     if doc['-type'][0][0]=='x' and doc['-type'][0]!='x0' and childNum is None:
       #should not have childnumber in other cases
       thisStack = ' '.join(hierStack)
       view = self.db.getView('viewHierarchy/viewHierarchy', startKey=thisStack) #not faster with cT.getChildren
       childNum = 0
@@ -184,35 +189,35 @@
 
     # find path name on local file system; name can be anything
     if self.cwd is not None and '-name' in doc:
       if doc['-type'][0][0]=='x':
         #project, step, task
         if doc['-type'][0]=='x0':
           childNum = 0
-        if edit:      #edit: cwd of the project/step/task: remove last directory from cwd (since cwd contains a / at end: remove two)
-          parentDirectory = self.cwd.parent
-        else:         #new: below the current project/step/task
-          parentDirectory = self.cwd
+        #parentDir
+        #  edit: cwd of the project/step/task: remove last directory from cwd (since cwd contains a / at end: remove two)
+        #  new: below the current project/step/task
+        parentDirectory = self.cwd.parent if edit else self.cwd
         path = parentDirectory/createDirName(doc['-name'],doc['-type'][0],childNum) #update,or create (if new doc, update ignored anyhow)
         operation = 'u'
       else:
         #measurement, sample, procedure
         shasum = ''
-        if '://' in doc['-name']:                                 #make up name
+        if '://' in doc['-name']:                           #make up name
           if localCopy:
             baseName  = Path(doc['-name']).stem
             extension = Path(doc['-name']).suffix
             path = self.cwd/(camelCase(baseName)+extension)
             request.urlretrieve(doc['-name'], path)
             doc['-name'] = camelCase(baseName)+extension
           else:
             path = Path(doc['-name'])
             try:
               shasum  = generic_hash(path)
-            except:
+            except Exception:
               print('**ERROR bad01: fetch remote content failed. Data not added')
               return ''
         elif doc['-name']!='' and (self.basePath/doc['-name']).exists():          #file exists
           path = self.basePath/doc['-name']
           doc['-name'] = Path(doc['-name']).name
         elif doc['-name']!='' and (self.cwd/doc['-name']).exists():               #file exists
           path = self.cwd/doc['-name']
@@ -263,15 +268,17 @@
 
     ## adaptation of directory tree, information on disk: documentID is required
     if self.cwd is not None and doc['-type'][0][0]=='x':
       #project, step, task
       path = Path(doc['-branch'][0]['path'])
       if edit and oldPath is not None:
         if not (self.basePath/oldPath).exists():
-          print('**WARNING: addData edit of folder should have oldPath and that should exist:'+oldPath+'\n This can be triggered if user moved the folder.')
+          print(
+              f'**WARNING: addData edit of folder should have oldPath and that should exist:{oldPath}'
+              + '\n This can be triggered if user moved the folder.')
           return ''
         (self.basePath/oldPath).rename(self.basePath/path)
       else:
         (self.basePath/path).mkdir(exist_ok=True)   #if exist, create again; moving not necessary since directory moved in changeHierarchy
       with open(self.basePath/path/'.id_pastaELN.json','w', encoding='utf-8') as f:  #local path, update in any case
         f.write(json.dumps(doc))
     return doc['_id']
@@ -291,26 +298,26 @@
     """
     logging.debug('changeHierarchy should only be used in CLI mode') #TODO_P5 remove this warning
     if self.cwd is None:
       return
     if docID is None or (docID[0]=='x' and docID[1]!='-'):  #cd ..: none. close 'project', 'task'
       self.hierStack.pop()
       self.cwd = self.cwd.parent
-    else:  # existing ID is given: open that
-      if dirName is None:
-        doc = self.db.getDoc(docID)
-        self.cwd = self.basePath/doc['-branch'][0]['path']
-        self.hierStack = doc['-branch'][0]['stack']+[docID]
-      else:
-        self.cwd = dirName
-        self.hierStack.append(docID)
+    elif dirName is None:  # existing ID is given: open that
+      doc = self.db.getDoc(docID)
+      self.cwd = self.basePath/doc['-branch'][0]['path']
+      self.hierStack = doc['-branch'][0]['stack']+[docID]
+    else:
+      self.cwd = dirName
+      self.hierStack.append(docID)
     return
 
 
   def scanProject(self, progressBar:Union[QProgressBar,DummyProgressBar] , projID:str, projPath:str='') -> None:
+    # sourcery skip: use-next
     """ Scan directory tree recursively from project/...
     - find changes on file system and move those changes to DB
     - use .id_pastaELN.json to track changes of directories, aka projects/steps/tasks
     - use shasum to track changes of measurements etc. (one file=one shasum=one entry in DB)
     - create database entries for measurements in directory
     - move/copy/delete allowed as the doc['path'] = list of all copies
       doc['path'] is adopted once changes are observed
@@ -321,15 +328,15 @@
       projPath (str): project's path from basePath; if not given, will be determined
 
     Raises:
       ValueError: could not add new measurement to database
     """
     progressBar.show()
     self.hierStack = [projID]
-    if projPath=='':
+    if not projPath:
       projPath = self.db.getDoc(projID)['-branch'][0]['path']
     self.cwd = self.basePath/projPath
     rerunScanTree = False
     #prepare lists and start iterating
     inDB_all = self.db.getView('viewHierarchy/viewPaths')
     pathsInDB_x    = [i['key'] for i in inDB_all if i['value'][1][0][0]=='x']  #all structure elements: task, subtasts
     pathsInDB_data = [i['key'] for i in inDB_all if i['value'][1][0][0]!='x']
@@ -339,15 +346,15 @@
       #find parent-document
       self.cwd = Path(root).relative_to(self.basePath)
       if self.cwd.name.startswith('trash_'):
         del dirs
         del files
         continue
       parentIDs = [i for i in inDB_all if i['key']==self.cwd.as_posix()]
-      if len(parentIDs)==0: #skip newly moved folder, will be scanned upon re-scanning
+      if not parentIDs: #skip newly moved folder, will be scanned upon re-scanning
         continue
       parentID = parentIDs[0]['id']
       parentDoc = self.db.getDoc(parentID)
       hierStack = parentDoc['-branch'][0]['stack']+[parentID]
       # handle directories
       for dirName in dirs[::-1]: #sorted forward in Linux
         if dirName.startswith('.') or dirName.startswith('trash_'):
@@ -356,15 +363,15 @@
         if path in pathsInDB_x: #path already in database
           pathsInDB_x.remove(path)
           continue
         if (self.basePath/path/'.id_pastaELN.json').exists(): # update branch: path and stack
           with open(self.basePath/path/'.id_pastaELN.json', 'r', encoding='utf-8') as fIn:
             doc = json.loads(fIn.read())
           if (self.basePath/doc['-branch'][0]['path']).parent.as_posix()  == root and \
-             doc['-branch'][0]['stack']==hierStack:
+               doc['-branch'][0]['stack']==hierStack:
             # special case: user wants to have a different directory name in same folder: then the child-number should not change
             childNum = doc['-branch'][0]['child']
             newPath = path
           else:
             #determine childNumber
             thisStack = ' '.join(hierStack)  #TODO_P5 this childNumSearch could become new function
             view = self.db.getView('viewHierarchy/viewHierarchy', startKey=thisStack)
@@ -377,50 +384,56 @@
             newPath = '/'.join(path.split('/')[:-1])+'/'+createDirName(doc['-name'],doc['-type'][0],childNum) #update,or create (if new doc, update ignored anyhow)
             if (self.basePath/newPath).exists():
               print("**ERROR new path should not exist",newPath)
             else:
               (self.basePath/path).rename(self.basePath/newPath)
           self.db.updateBranch(doc['_id'], 0, childNum, hierStack, newPath)
         else:
-          currentID = self.addData('x'+str(len(hierStack)), {'-name':dirName}, hierStack)
+          currentID = self.addData(f'x{len(hierStack)}', {'-name': dirName}, hierStack)
           newDir = self.basePath/self.db.getDoc(currentID)['-branch'][0]['path']
           (newDir/'.id_pastaELN.json').rename(self.basePath/root/dirName/'.id_pastaELN.json') #move index file into old folder
           newDir.rmdir()                     #remove created path
           (self.basePath/root/dirName).rename(newDir) #move old to new path
         rerunScanTree = True
       # handle files
       for fileName in files:
         filesCount += 1
         progressBar.setValue(int(100*filesCount/filesCountSum))
         if fileName.startswith('.') or fileName.startswith('trash_') or '_PastaExport' in fileName:
           continue
         path = (Path(root).relative_to(self.basePath) /fileName).as_posix()
         if path in pathsInDB_data:
-          logging.info("Scan: file already in DB: "+path)
+          logging.info('Scan: file already in DB: %s',path)
           pathsInDB_data.remove(path)
         else:
-          logging.info("Scan: add file to DB: "+path)
+          logging.info('Scan: add file to DB: %s',path)
           self.addData('-', {'-name':path}, hierStack)
     #finish method
     self.cwd = self.basePath/projPath
-    orphans = [i for i in pathsInDB_data if i.startswith(self.cwd.relative_to(self.basePath).as_posix()+'/')]
-    logging.info('Scan: these files are on DB but not harddisk\n'+'\n  '.join(orphans))
-    orphanDirs = [i for i in pathsInDB_x if i.startswith(self.cwd.relative_to(self.basePath).as_posix()+'/') and i!=projPath]
-    logging.info('Scan: these directories are on DB but not harddisk\n'+'\n  '.join(orphanDirs))
+    orphans = [
+        i for i in pathsInDB_data
+        if i.startswith(f'{self.cwd.relative_to(self.basePath).as_posix()}/')
+    ]
+    logging.info('Scan: these files are on DB but not hard disk\n'+'\n  '.join(orphans))
+    orphanDirs = [
+        i for i in pathsInDB_x
+        if i.startswith(f'{self.cwd.relative_to(self.basePath).as_posix()}/')
+        and i != projPath
+    ]
+    logging.info('Scan: these directories are on DB but not hard disk\n'+'\n  '.join(orphanDirs))
     for orphan in orphans+orphanDirs:
       docID = [i for i in inDB_all if i['key']==orphan][0]['id']
       doc   = dict(self.db.getDoc(docID))
       change = None
       for branch in doc['-branch']:
         if branch['path']==orphan:
-          change = {'-branch': {'op':'d', 'oldpath':branch['path'], 'path':branch['path'], \
-                                'stack':branch['stack'] }}
+          change = {'-branch': {'op':'d', 'oldpath':branch['path'], 'path':branch['path'], 'stack':branch['stack'] }}
           break
       if change is None:
-        logging.warning('Tried to remove orphan in database but could not; that can happen if user renames folder:'+orphan)
+        logging.warning('Tried to remove orphan in database but could not; that can happen if user renames folder: %s', orphan)
       else:
         self.db.updateDoc(change, docID)
     #reset to initial values
     self.hierStack = []
     self.cwd = Path(self.basePath)
     if rerunScanTree:
       self.scanProject(progressBar, projID, projPath)
@@ -442,72 +455,72 @@
     if str(filePath).startswith('http'):
       absFilePath = Path(tempfile.gettempdir())/filePath.name
       request.urlretrieve(filePath.as_posix().replace(':/','://'), absFilePath)
     else:
       if filePath.is_absolute():
         filePath = filePath.relative_to(self.basePath)
       absFilePath = self.basePath/filePath
-    pyFile = 'extractor_'+extension.lower()+'.py'
+    pyFile = f'extractor_{extension.lower()}.py'
     pyPath = self.extractorPath/pyFile
     success = False
     if pyPath.exists():
       success = True
       # import module and use to get data
       os.environ['QT_API'] = 'pyside2'
       import matplotlib.pyplot as plt  #IMPORTANT: NO PYPLOT OUTSIDE THIS QT_API BLOCK
       plt.clf()
       try:
         module  = importlib.import_module(pyFile[:-3])
         content = module.use(absFilePath, '/'.join(doc['-type']) )
-      except:
-        logging.error('ERROR with extractor '+pyFile+'\n'+traceback.format_exc())
+      except Exception:
+        logging.error(f'ERROR with extractor {pyFile}' + '\n' + traceback.format_exc())
         success = False
       os.environ['QT_API'] = 'pyside6'
       #combine into document
       if success:
-        doc.update(content)
+        doc |= content
         for meta in ['metaVendor','metaUser']:
           for item in doc[meta]:
             if isinstance(doc[meta][item], tuple):
               doc[meta][item] = list(doc[meta][item])
             if not isinstance(doc[meta][item], (str, int, float, list)) and \
-              doc[meta][item] is not None:
+                    doc[meta][item] is not None:
               print(' -> simplify ',meta,item, doc[meta][item])
               doc[meta][item] = str(doc[meta][item])
-        if doc['-type'][0]==doc['recipe'].split('/')[0] or doc['-type'][0]=='-':
+        if doc['-type'][0] in [doc['recipe'].split('/')[0], '-']:
           doc['-type']     = doc['recipe'].split('/')
         else:
           #user has strange wish: trust him/her
           logging.info('user has strange wish: trust him/her: '+'/'.join(doc['-type'])+'  '+doc['recipe'])
         del doc['recipe']
         if 'fileExtension' not in doc['metaVendor']:
           doc['metaVendor']['fileExtension'] = extension.lower()
-        if 'links' in doc:
+        if 'links' in doc and len(doc['links'])==0:
           #TODO_P3 extractor: creates links to sample/instrument
-          if len(doc['links'])==0:
-            del doc['links']
+          del doc['links']
     if not success:
-      print('  **Warning, issue with extractor',pyFile)
-      logging.warning('Issue with extractor '+pyFile)
+      print('  **Warning, issue with extractor', pyFile)
+      logging.warning('Issue with extractor %s', pyFile)
       doc['metaUser'] = {'filename':absFilePath.name, 'extension':absFilePath.suffix,
         'filesize':absFilePath.stat().st_size,
         'created at':datetime.fromtimestamp(absFilePath.stat().st_ctime, tz=timezone.utc).isoformat(),
         'modified at':datetime.fromtimestamp(absFilePath.stat().st_mtime, tz=timezone.utc).isoformat()}
     doc['shasum']=shasum  #essential for logic, always save, unlike image
     return
 
 
   def testExtractor(self, filePath:Union[Path,str], extractorPath:Optional[Path]=None, recipe:str='',
-                    outputStyle:str='text') -> str:
+                    outputStyle:str='text', saveFig:str='') -> str:
     """
     Args:
       filePath (Path, str): path to the file to be tested
       extractorPath (Path, None): path to the directory with extractors
       recipe (str): recipe in / separated
       outputStyle (str): report in ['print','text','html'] including show images
+      saveFig (str): save figure to...; if given stop testing after generating image
 
     Returns:
       str: short summary or long report
     """
     import base64
     from io import BytesIO
     from PIL import Image
@@ -521,108 +534,106 @@
     if isinstance(filePath, str):
       filePath = Path(filePath)
     if filePath.as_posix().startswith('http'):
       tempFilePath = Path(tempfile.gettempdir())/filePath.name
       request.urlretrieve(filePath.as_posix().replace(':/','://'), tempFilePath)
       filePath = tempFilePath
     report = outputString(outputStyle, 'h2', 'Report on extractor test')
-    report += outputString(outputStyle, 'info', 'check file: '+str(filePath))
+    report += outputString(outputStyle, 'info', f'check file: {str(filePath)}')
     extension = filePath.suffix[1:]
-    pyFile = 'extractor_'+extension.lower()+'.py'
+    pyFile = f'extractor_{extension.lower()}.py'
     if extractorPath is None:
       extractorPath = self.extractorPath
     #start testing
     if (extractorPath/pyFile).exists():
-      report += outputString(outputStyle, 'info', 'use extractor: '+str(extractorPath/pyFile))
+      report += outputString(outputStyle, 'info', f'use extractor: {str(extractorPath / pyFile)}')
     else:
       success = False
-      report += outputString(outputStyle, 'error', 'No fitting extractor found:'+pyFile)
+      report += outputString(outputStyle, 'error', f'No fitting extractor found:{pyFile}')
     if success:
       try:
         module  = importlib.import_module(pyFile[:-3])
         plt.clf()
-        content = module.use(filePath, recipe)
-      except:
+        content = module.use(filePath, recipe, saveFig or None)
+        if saveFig:
+          return report
+      except Exception:
         success = False
         report += outputString(outputStyle, 'error', 'Python error in extractor')
-        report += outputString(outputStyle, 'error', htmlStr+'python-error">website</a>')
+        report += outputString(outputStyle, 'error', f'{htmlStr}python-error">website</a>')
         report += outputString(outputStyle, 'error', traceback.format_exc(limit=3))
     if success:
       if 'recipe' in content:
         possibleDocTypes = [i for i in self.db.dataLabels.keys() if i[0]!='x']
         matches = [i for i in possibleDocTypes if content['recipe'].startswith(i)]
-        if len(matches)==0 and content['recipe']!='' and content['recipe']!='-':
-          report += outputString(outputStyle, 'error', 'Recipe does not follow doctype in ontology.')
-        else:
+        if matches or content['recipe'] == '' or content['recipe'] == '-':
           report += outputString(outputStyle, 'info', 'Recipe is good: '+content['recipe'])
           size = len(str(content))
-          report += outputString(outputStyle, 'info', 'Entire extracted size: '+str(int(size/1024))+'kB')
+          report += outputString(outputStyle, 'info', f'Entire extracted size: {size // 1024}kB')
+        else:
+          report += outputString(outputStyle, 'error', 'Recipe does not follow doctype in ontology.')
       else:
         report += outputString(outputStyle,'error','Recipe not included in extractor.')
     if success:
       try:
         _ = json.dumps(content)
-      except:
+      except Exception:
         report += outputString(outputStyle,'error','Extractor reply not json dumpable.')
     if success:
       try:
         _ = json.dumps(content['metaVendor'])
         report += outputString(outputStyle,'info','Number of vendor entries: '+str(len(content['metaVendor'])))
-      except:
+      except Exception:
         # possible cause of failure: make sure that no int64 but normal int
         success = False
-        report += outputString(outputStyle,'error','Some json format does not fit in metaVendor')
-        report += outputString(outputStyle,'error',htmlStr+'metadata-error">website</a>')
+        report += outputString(outputStyle,'error', 'Some json format does not fit in metaVendor')
+        report += outputString(outputStyle, 'error', f'{htmlStr}metadata-error">website</a>')
         #iterate keys
         for key in content['metaVendor']:
           try:
             _ = json.dumps(content['metaVendor'][key])
-          except:
-            report += outputString(outputStyle,'error','FAIL '+key+' : '+str(content['metaVendor'][key])+\
-                                   ' type:'+str(type(content['metaVendor'][key])))
-
+          except Exception:
+            report += outputString(outputStyle,'error',f'FAIL {key}:'+str(content['metaVendor'][key])+' type:')+str(type(content['metaVendor'][key]))
     if success:
       try:
         _ = json.dumps(content['metaUser'])
         report += 'Number of user entries: '+str(len(content['metaUser']))+'<br>'
-      except:
-        report += outputString(outputStyle,'error','Some json format does not fit in metaUser')
-        report += outputString(outputStyle,'error',htmlStr+'metadata-error">website</a>')
+      except Exception:
+        report += outputString(outputStyle,'error', 'Some json format does not fit in metaUser')
+        report += outputString(outputStyle, 'error', f'{htmlStr}metadata-error">website</a>')
         #iterate keys
         for key in content['metaUser']:
           try:
             _ = json.dumps(content['metaUser'][key])
-          except:
-            report += outputString(outputStyle,'error','FAIL '+key+' : '+str(content['metaUser'][key])+\
-                                   ' type:'+str(type(content['metaUser'][key])))
-    #verify image is of correct type
-    if success and 'image' not in content:
-      success = False
-      report += outputString(outputStyle,'error','Image does not exist')
+          except Exception:
+            report += outputString(outputStyle,'error',f'FAIL {key}:'+str(content['metaUser'][key])+' type:') + str(type(content['metaUser'][key]))
+      if 'image' not in content:
+        success = False
+        report += outputString(outputStyle,'error','Image does not exist')
     if success and isinstance(content['image'],Image.Image):
       success = False
       report += outputString(outputStyle,'error','Image is a PIL image: not a base64 string')
-      report += outputString(outputStyle,'error', htmlStr+'pillow-image">website</a>')
-      # print('Encode image via the following: pay attention to jpg/png which is encoded twice\n```')
-      # print('from io import BytesIO')
-      # print('figfile = BytesIO()')
-      # print('image.save(figfile, format="PNG")')
-      # print('imageData = base64.b64encode(figfile.getvalue()).decode()')
-      # print('image = "data:image/jpg;base64," + imageData')
+      report += outputString(outputStyle, 'error', f'{htmlStr}pillow-image">website</a>')
+        # print('Encode image via the following: pay attention to jpg/png which is encoded twice\n```')
+        # print('from io import BytesIO')
+        # print('figfile = BytesIO()')
+        # print('image.save(figfile, format="PNG")')
+        # print('imageData = base64.b64encode(figfile.getvalue()).decode()')
+        # print('image = "data:image/jpg;base64," + imageData')
     if success and isinstance(content['image'], mpaxes._axes.Axes): # pylint: disable=protected-access
       success = False
       report += outputString(outputStyle,'error','Image is a matplotlib axis: not a base64 string')
-      report += outputString(outputStyle,'error', htmlStr+'matplotlib">website</a>')
-      # print('**Warning: image is a matplotlib axis: not a svg string')
-      # print('  figfile = StringIO()')
-      # print('plt.savefig(figfile, format="svg")')
-      # print('image = figfile.getvalue()')
-    if success and isinstance(content['image'], str):  #show content
+      report += outputString(outputStyle, 'error', f'{htmlStr}matplotlib">website</a>')
+        # print('**Warning: image is a matplotlib axis: not a svg string')
+        # print('  figfile = StringIO()')
+        # print('plt.savefig(figfile, format="svg")')
+        # print('image = figfile.getvalue()')
+    if success and isinstance(content['image'], str):#show content
       size = len(content['image'])
-      report += outputString(outputStyle,'info','Image size '+str(int(size/1024))+'kB')
+      report += outputString(outputStyle, 'info', f'Image size {str(size // 1024)}kB')
       if outputStyle!='text':
         report += outputString(outputStyle,'h2','Additional window shows the image')
       if len(content['image'])>20:
         if content['image'].startswith('data:image/'):
           #png or jpg encoded base64
           extension = content['image'][11:14]
           img = base64.b64decode(content['image'][22:])
@@ -657,16 +668,15 @@
     defaultProjectGroup = self.configuration['defaultProjectGroup']
     remoteConf = self.configuration['projectGroups'][defaultProjectGroup]['remote']
     if not remoteConf: #empty entry: fails
       print("**ERROR brp01: You tried to replicate although, remote is not defined")
       return 'ERROR'
     if 'cred' in remoteConf:
       remoteConf['user'], remoteConf['password'] = upOut(remoteConf['cred'])[0].split(':')
-    report = self.db.replicateDB(remoteConf, progressBar, removeAtStart)
-    return report
+    return self.db.replicateDB(remoteConf, progressBar, removeAtStart)
 
 
   def checkDB(self, outputStyle:str='text', repair:bool=False, minimal:bool=False) -> str:
     """
     Wrapper of check database for consistencies by iterating through all documents
 
     Args:
@@ -696,53 +706,50 @@
           del dirs
           continue
         for fileName in files:
           if fileName.startswith('.') or fileName.startswith('trash_') or '_PastaExport' in fileName:
             continue
           path = (Path(root).relative_to(self.basePath) /fileName).as_posix()
           if path not in pathsInDB_data:
-            output += outputString(outputStyle,'error','File on harddisk but not DB: '+path)
+            output += outputString(outputStyle, 'error', f'File on harddisk but not DB: {path}')
             count += 1
           else:
             pathsInDB_data.remove(path)
         for dirName in dirs:
           if dirName.startswith('.') or dirName.startswith('trash_'):
             continue
           path = (Path(root).relative_to(self.basePath) /dirName).as_posix()
           if path not in pathsInDB_folder:
-            output += outputString(outputStyle,'error','Directory on harddisk but not DB:'+path)
+            output += outputString(outputStyle, 'error', f'Directory on harddisk but not DB:{path}')
             count += 1
           else:
             pathsInDB_folder.remove(path)
             if (self.basePath/root/dirName/'.id_pastaELN.json').exists():
               with open(self.basePath/root/dirName/'.id_pastaELN.json','r',encoding='utf-8') as fIn:
                 docDisk = json.loads(fIn.read())
                 listDocs = self.db.getView('viewHierarchy/viewPathsAll', preciseKey=path)
                 if len(listDocs)!=1:
-                  output += outputString(outputStyle,'error','Path of folder is non-unique: '+path)
+                  output += outputString(outputStyle, 'error', f'Path of folder is non-unique: {path}')
                 docDB   = self.db.getDoc(listDocs[0]['id'])
                 difference = diffDicts(docDisk,docDB)
                 if len(difference)>1:
                   output += outputString(outputStyle,'error','disk(1) and db(2) content do not match:'+docDisk['_id'])
                   output += outputString(outputStyle,'error',difference)
                   # #use only for resetting the content in the .id_pastaELN.json
                   # with open(self.basePath/root/dirName/'.id_pastaELN.json','w',encoding='utf-8') as fOut:
                   #   json.dump(docDB, fOut)
             else:
-              output += outputString(outputStyle,'error','Folder has no .id_pastaELN.json:'+path)
+              output += outputString(outputStyle, 'error', f'Folder has no .id_pastaELN.json:{path}')
               count += 1
               # if True:  #use only for resetting the content in the .id_pastaELN.json
               #   with open(self.basePath/root/dirName/'.id_pastaELN.json','w',encoding='utf-8') as fOut:
               #     docDB   = self.db.getDoc( docDisk['_id'] )
               #     json.dump(docDB, fOut)
-    output += outputString(outputStyle,'info','Number of files on disk that are not in database '+str(count))
+    output += outputString(outputStyle, 'info', f'Number of files on disk that are not in database {str(count)}')
     orphans = [i for i in pathsInDB_data   if not (self.basePath/i).exists() and ":/" not in i]
     orphans+= [i for i in pathsInDB_folder if not (self.basePath/i).exists() ]
-    if len(orphans)>0:
+    if orphans:
       output += outputString(outputStyle,'error','bch01: These files of database not on filesystem:\n- '+'\n- '.join(orphans))
     output += outputString(outputStyle,'h2','File summary')
     if outputStyle == 'text':
-      if len(orphans)==0 and count==0:
-        output += "Success\n"
-      else:
-        output += "Failure\n"
+      output += "Success\n" if not orphans and count==0 else "Failure\n"
     return output
```

## pasta_eln/cli.py

```diff
@@ -127,25 +127,25 @@
         urls.append(config['projectGroups'][args.database]['remote']['url'])
       for url in urls:
         try:
           with urllib.request.urlopen(url) as package:
             contents = package.read()
             if json.loads(contents)['couchdb'] == 'Welcome':
               print('CouchDB server',url,'is working: username and password test upcoming')
-        except:
+        except Exception:
           print('**ERROR pma01: CouchDB server not working |',url)
           if url=='http://127.0.0.1:5984':
             raise NameError('**ERROR pma01a: Wrong local server.') from None
 
     #open backend
     if not getDocu:
       try:
         be = Backend(defaultProjectGroup=args.database, initViews=initViews, initConfig=initConfig,
                   resetOntology=resetOntology)
-      except:
+      except Exception:
         print('**ERROR pma20: backend could not be started.\n'+traceback.format_exc()+'\n\n')
         return ''
 
     if not getDocu and args.command.startswith('test') and be:
       #PART 2 of test: main test
       print('database server:',be.db.db.client.server_url)
       print('default project group:',be.configuration['defaultProjectGroup'])
@@ -154,18 +154,18 @@
       print('Design documents')
       for item in designDocuments:
         numViews = len(item['doc']['views']) if 'views' in item['doc'] else 0
         print('  ',item['id'], '   Num. of views:', numViews )
       try:
         data = be.db.getDoc('-ontology-')
         print('Ontology exists on server')
-      except:
+      except Exception:
         print('**ERROR pma02: Ontology does NOT exist on server')
       print('local directory:',be.basePath)
-      print('software version: '+__version__)
+      print(f'software version: {__version__}')
       return '1'
 
     if getDocu:
       doc += '  verifyDB: test PASTA database\n'
       doc += '    example: pastaELN_CLI.py verifyDB\n'
       doc += '    example: pastaELN_CLI.py verifyDBdev (repair function)\n'
     elif args.command.startswith('verifyDB'):
@@ -302,29 +302,30 @@
       doc += '  hierarchy: print document hierarchy\n'
       doc += '    example: pastaELN_CLI.py hierarchy -i x-1234567890abc'
     elif args.command=='hierarchy':
       print(be.outputHierarchy(True,True))
       return '1'
 
   except:
-    print("**ERROR pma10: exception thrown during pastaELN_CLI.py"+traceback.format_exc()+"\n")
+    print(
+        f"**ERROR pma10: exception thrown during pastaELN_CLI.py{traceback.format_exc()}"
+        + "\n")
     raise
 
   if not getDocu and be is not None:
     be.exit()
   return doc
 
 ###################
 ## MAIN FUNCTION ##
 def main() -> None:
   """
   Main function
   """
-  usage = "python -m pasta_eln.cli <command> [-i docID] [-c content] [-l labels] [-d database]\n\n"
-  usage+= "Possible commands are:\n"
+  usage = "python -m pasta_eln.cli <command> [-i docID] [-c content] [-l labels] [-d database]\n\nPossible commands are:\n"
   usage+= commands(True, argparse.Namespace())
   argparser = argparse.ArgumentParser(usage=usage)
   argparser.add_argument('command', help='see above...')
   argparser.add_argument('-i','--docID',   help='docID of project; a long alpha-numeric code', default='')
   argparser.add_argument('-c','--content', help='content to save/store', default=None)
   argparser.add_argument('-l','--label',   help='label used for printing', default='x0')
   argparser.add_argument('-d','--database',help='name of database configuration', default='') #required for be = Pasta(args.database)
```

## pasta_eln/database.py

```diff
@@ -22,15 +22,15 @@
       password (string): password to local database
       databaseName (string): local database name
       configuration (dict): configuration of GUI elements
       resetOntology (bool): reset ontology
     """
     try:
       self.client = CouchDB(user, password, url='http://127.0.0.1:5984', connect=True)
-    except:
+    except Exception:
       print('**ERROR dit01: Could not connect with username+password to local server')
       return
     self.databaseName = databaseName
     if self.databaseName in self.client.all_dbs():
       self.db = self.client[self.databaseName]
     else:
       self.db = self.client.create_database(self.databaseName)
@@ -69,51 +69,53 @@
     for docType in [i for i in self.ontology if i[0] not in ['_','-']]+['-']:
       if docType=='x0':
         newString = "doc['-type']=='x0' && (doc['-branch'][0].show.every(function(i) {return i;}))"
         js    = jsDefault.replace('$docType$', newString).replace('$key$','doc._id')
         jsAll = jsDefault.replace('$docType$', "doc['-type']=='x0'").replace('$key$','doc._id')
       elif docType[0]=='x':
         continue
-      else:     #show all doctypes that have the same starting ..
-        js    = jsDefault.replace('$docType$', "doc['-type'].join('/').substring(0, "+str(len(docType))+")=='"\
-                +docType+"' && (doc['-branch'][0].show.every(function(i) {return i;}))")\
-                .replace('$key$','branch.stack[0]')
-        jsAll = jsDefault.replace('$docType$', "doc['-type'].join('/').substring(0, "+str(len(docType))+")=='"\
-                +docType+"'").replace('$key$','branch.stack[0]')
+      else: #show all doctypes that have the same starting ..
+        js = jsDefault.replace('$docType$',
+            f"doc['-type'].join('/').substring(0,{len(docType)})=='{docType}"+"' && (doc['-branch'][0].show.every(function(i) {return i;}))",
+            ).replace('$key$', 'branch.stack[0]')
+        jsAll = jsDefault.replace(
+            '$docType$',
+            f"doc['-type'].join('/').substring(0, {len(docType)})=='{docType}'",
+            ).replace('$key$', 'branch.stack[0]')
       outputList = []
       baseDocType = docType[:-3] if docType.endswith('All') else docType
       if docTypeChange==docType:
         columnNames = columnsChange
       elif baseDocType in oldColumnNames:
         columnNames = oldColumnNames[baseDocType].split(',')
       elif docType == '-':
         columnNames = [i['name'] for i in defaultOntologyNode if 'name' in i]
       else:
         columnNames = [i['name'] for i in self.ontology[docType]['prop'] if 'name' in i]
       columnNames = columnNames[:tableColumnsMax]
-      commentString = '// '+docType+' : '+','.join(columnNames)+'\n'
+      commentString = f'// {docType} : ' + ','.join(columnNames) + '\n'
       # print('STEFFEN verify comment string',commentString)
       for name in columnNames:
         if name == 'image':
           outputList.append('doc.image.length>3')  #Not as .toString() because that leads to inconsistencies
         elif name == '-tags':
           outputList.append("doc['-tags'].join(' ')")
         elif '#_' in name:
-          outputList.append('doc["-tags"].indexOf("'+name[1:]+'")>-1')
+          outputList.append(f'doc["-tags"].indexOf("{name[1:]}")>-1')
         elif name == '-type':
           outputList.append('doc["-type"].slice(1).join("/")')
         elif name == 'content':
           outputList.append('doc.content?doc.content.slice(0, 100):""')
         elif '/' in name:  #stacked requests i.e. metaVendor/date
-          parentString = 'doc'+''.join(['["'+i+'"]' for i in name.split('/')[:-1]])
-          newString = 'doc'+''.join(['["'+i+'"]' for i in name.split('/')])
-          newString = parentString +' ? '+ newString + ': ""'
+          parentString = 'doc' + ''.join([f'["{i}"]' for i in name.split('/')[:-1]])
+          newString = 'doc' + ''.join([f'["{i}"]' for i in name.split('/')])
+          newString = f'{parentString} ? {newString}: ""'
           outputList.append(newString)
         else:
-          outputList.append('doc["'+name+'"]')
+          outputList.append(f'doc["{name}"]')
       outputStr = ','.join(outputList)
       viewCode[docType.replace('/','__')]       = commentString+js.replace('$outputList$', outputStr)
       viewCode[docType.replace('/','__')+'All'] = commentString+jsAll.replace('$outputList$', outputStr)
     self.saveView('viewDocType', viewCode)
     # print('SB result of columnNames',oldColumnNames)
     return
 
@@ -125,16 +127,21 @@
       dict: docType and ,-separated list of names as string
     """
     if '_design/viewDocType' not in self.db:
       return {}
     try:
       comments = [v['map'].split('\n// ')[1].split('\n')[0] for v in self.db['_design/viewDocType']['views'].values()]
       return {i.split(' : ')[0]:i.split(' : ')[1] for i in comments}
-    except: #old views that do not have comment
-      return {}
+    except Exception:
+      defaultColumnNames = {'-':','.join([i['name'] for i in defaultOntologyNode if 'name' in i])}
+      for docType in self.ontology:
+        if docType[0] in ['_','-']:
+          continue
+        defaultColumnNames[docType] = ','.join([i['name'] for i in self.ontology[docType]['prop'] if 'name' in i])
+      return defaultColumnNames
 
 
   def initGeneralViews(self) -> None:
     """
     general views: Hierarchy, Identify
     """
     tracebackString(True, 'initGeneralView')
@@ -159,16 +166,15 @@
         if ('shasum' in doc){doc['-branch'].forEach(function(branch,idx){if(branch.path){emit(branch.path,[branch.stack,doc['-type'],branch.child,doc.shasum,idx]);}});}
         else                {doc['-branch'].forEach(function(branch,idx){if(branch.path){emit(branch.path,[branch.stack,doc['-type'],branch.child,''        ,idx]);}});}
       }
     '''
     self.saveView('viewHierarchy',{'viewHierarchy':jsHierarchy,'viewPaths':jsPath,\
                                    'viewHierarchyAll':jsHierarchyAll,'viewPathsAll':jsPathAll})
     jsSHA= "if (doc['-type'][0]==='measurement'){emit(doc.shasum, doc['-name']);}"
-    jsQR = "if (doc.qrCode.length > 0)"
-    jsQR+= "{doc.qrCode.forEach(function(thisCode) {emit(thisCode, doc['-name']);});}"
+    jsQR = "if (doc.qrCode.length > 0) {doc.qrCode.forEach(function(thisCode) {emit(thisCode, doc['-name']);});}"
     jsTags="if ('-tags' in doc && (doc['-branch'][0].show.every(function(i) {return i;})))"+\
               "{doc['-tags'].forEach(function(tag){emit(tag,[doc['-name'], doc['-type'].join('/')]);});}"
     jsTagsAll="if ('-tags' in doc){doc['-tags'].forEach(function(tag){emit(tag,[doc['-name'], doc['-type'].join('/')]);});}"
     views = {'viewQR':jsQR, 'viewSHAsum':jsSHA, 'viewTags':jsTags, 'viewTagsAll':jsTagsAll}
     self.saveView('viewIdentify', views)
     return
 
@@ -198,15 +204,15 @@
 
     Returns:
         dict: json representation of document
     """
     return dict(self.db[docID])
 
 
-  def saveDoc(self, doc:dict[str,Any]) ->dict[str,Any]:
+  def saveDoc(self, doc:dict[str,Any]) -> dict[str,Any]:
     """
     Wrapper for save to database function
 
     Discussion on -branch['path']:
     - full path (from basePath) allows to easily create a view of all paths and search through them
       during each scan, which happens rather often
     - just the incremental path (file-name, folder-name) allows to easily change that if the user wants
@@ -224,15 +230,15 @@
       del doc['-branch']['op']  #remove operation, saveDoc creates and therefore always the same
       if 'show' not in doc['-branch']:
         doc['-branch']['show'] = self.createShowFromStack(doc['-branch']['stack'])
       doc['-branch'] = [doc['-branch']]
     try:
       res = self.db.create_document(doc)
       logging.debug('successfully saved doc with type and branch '+doc['_id']+' '+'/'.join(doc['-type'])+'  |  '+str(doc['-branch'])+'\n')
-    except:
+    except Exception:
       logging.error('could not save, likely JSON issue')
       if 'image' in doc:
         del doc['image']
       logging.error(str(doc))
       logging.error(traceback.format_exc())
       res=None
     return res
@@ -249,15 +255,15 @@
     Args:
         change (dict): item to update
         docID (string):  id of document to change
 
     Returns:
         dict: json representation of updated document
     """
-    change['-client'] = tracebackString(False, 'updateDoc:'+docID)
+    change['-client'] = tracebackString(False, f'updateDoc:{docID}')
     newDoc = self.db[docID]  #this is the document that stays live
     initialDocCopy = dict(newDoc)
     if 'edit' in change:     #if delete
       oldDoc = dict(newDoc)
       for item in oldDoc:
         if item not in ('_id', '_rev', '-branch'):
           del newDoc[item]
@@ -267,29 +273,29 @@
       # nothingChanged = True
       # handle branch
       if '-branch' in change:# and len(change['-branch']['stack'])>0:
         op = change['-branch'].pop('op')
         oldpath = change['-branch'].pop('oldpath',None)
         if change['-branch']['path'] is None:
           change['-branch']['path']=newDoc['-branch'][0]['path']
-        if not change['-branch'] in newDoc['-branch']:       #skip if new branch is already in branch
+        if change['-branch'] not in newDoc['-branch']:       #skip if new branch is already in branch
           oldDoc['-branch'] = newDoc['-branch'].copy()
           for branch in newDoc['-branch']:
             if op=='c' and branch['path']==change['-branch']['path']:
               op='u'
           if op=='c':    #create, append
             change['-branch']['show'] = self.createShowFromStack(change['-branch']['stack'])
             newDoc['-branch'] += [change['-branch']]
             # nothingChanged = False
           elif op=='u':  #update
             if oldpath is not None:
               for branch in newDoc['-branch']:
                 if branch['path'].startswith(oldpath):
                   if os.path.basename(branch['path']) == newDoc['-name'] and \
-                     os.path.basename(str(change['-branch']['path']))!='':
+                         os.path.basename(str(change['-branch']['path']))!='':
                     newDoc['-name'] = os.path.basename(str(change['-branch']['path']))
                   branch['path'] = branch['path'].replace(oldpath ,change['-branch']['path'])
                   branch['stack']= change['-branch']['stack']
                   branch['show'] = self.createShowFromStack(change['-branch']['stack'])
                   break
             else:
               newDoc['-branch'][0] = change['-branch'] #change the initial one
@@ -307,16 +313,18 @@
       for item in change:
         if item in ['_id','_rev','-branch']:                #skip items cannot do not result in change
           continue
         if item=='-type' and change['-type']==['--']:          #skip non-set type
           continue
         if item=='image' and change['image']=='':          #skip if non-change in image
           continue
-        if change[item] is None or (isinstance(change[item], str) and change[item].strip()=='') or \
-           (isinstance(change[item], list) and len(change[item])==0):      #skip empty entries
+        if change[item] is None:
+          # DO CHANGE TO EMPTY: if user wants it
+          # or (isinstance(change[item], str) and change[item].strip()=='') or \
+          #    (isinstance(change[item], list) and len(change[item])==0):      #skip empty entries
           continue
         ## Discussion: What if content only differs by whitespace changes?
         # These changes should occur in the database, the user wanted it so
         # Do these changes justify a new revision?
         # Hence one could update the doc and previous-revision(with the current _rev)
         #  - but that would lead to special cases, more code, chaos
         #  - also not sure how often simple white space changes occur, how important
@@ -338,15 +346,15 @@
       #   logging.debug('database.update.2: doc not updated-nothing changed: '+newDoc['_id']+' '+newDoc['-name'])
       #   return newDoc
     #For both cases: delete and update
     if '_curated' not in newDoc['-tags'] and newDoc['-type'][0][0]!='x':
       newDoc['-tags'].append('_curated')
     try:
       newDoc.save()
-    except:
+    except Exception:
       logging.error('database.update: update unsuccessful: '+newDoc['_id']+' '+newDoc['-name'])
       print('**ERROR: could not update document. Likely version conflict. Initial and current version:')
       print(initialDocCopy)
       print(newDoc)
       return {}
     attachmentName = 'v0.json'
     if '_attachments' in newDoc:
@@ -368,36 +376,36 @@
       stack (list):  new list of ids
       path (str): new path; None is acceptable
 
     Returns:
       str, str: old path, new path
     """
     doc = self.db[docID]
-    doc['-client'] = tracebackString(False, 'updateBranch:'+docID)
+    doc['-client'] = tracebackString(False, f'updateBranch:{docID}')
     if len(doc['-branch'])<=branch:
-      print('**ERROR Cannot delete branch that does not exist '+str(branch)+'in doc '+docID)
-      logging.error('**ERROR Cannot delete branch that does not exist '+str(branch)+'in doc '+docID)
+      print(f'**ERROR Cannot delete branch that does not exist {branch}in doc {docID}')
+      logging.error('**ERROR Cannot delete branch that does not exist %s in doc %s', branch, docID)
     oldPath = doc['-branch'][branch]['path']
     if oldPath is None:
       path = None
     if path=='':
-      name = f'{child:03d}'+'_'+'_'.join(oldPath.split('/')[-1].split('_')[1:])
+      name = f'{child:03d}_' + '_'.join(oldPath.split('/')[-1].split('_')[1:])
       path = '/'.join(oldPath.split('/')[:-1]+[name])
     # test if path already exists
     if docID[0]=='x' and path is not None:
       if not (self.basePath/path/'.id_pastaELN.json').exists():
         logging.debug('Target folder\'s json does not exist: '+path)
         oldDocID = ''
       else:
         with open(self.basePath/path/'.id_pastaELN.json', 'r', encoding='utf-8') as fIn:
           oldJsonContent = json.load(fIn)
           oldDocID = oldJsonContent['_id']
       if path is not None and (self.basePath/path).exists() and docID!=oldDocID:
-        print('**ERROR** Target folder already exist: '+path+'. Try to create a new path name')
-        logging.error('Target folder already exist: '+path+'. Try to create a new path name')
+        print(f'**ERROR** Target folder already exist: {path}. Try to create a new path name')
+        logging.error('Target folder already exist: %s. Try to create a new path name', path)
       while path is not None and (self.basePath/path).exists() and docID!=oldDocID:
         if re.search(r"_\d+$", path) is None:
           path += '_1'
         else:
           path = '_'.join(path.split('_')[:-1])+'_'+str(int(path.split('_')[-1])+1)
     # assemble data
     doc['-branch'][branch]['path']=path
@@ -427,15 +435,15 @@
             branchLine['path'] = path+branchLine['path'][len(oldPath):]
             flagNotChanged = False
           if stack is not None and '/'.join(branchLine['stack']).startswith('/'.join(stackOld)):
             branchLine['stack'] = stack+branchLine['stack'][len(stackOld):]
             branchLine['show']  = self.createShowFromStack( branchLine['stack'] )
             flagNotChanged = False
         if flagNotChanged:
-          print("**Unsure** Not updated"+str(line))
+          print(f"**Unsure** Not updated{str(line)}")
         docLine.save()
         # update .json on disk
         for branchLine in docLine['-branch']:
           if line['id'][0]=='x'  and (self.basePath/branchLine['path']).exists():
             with open(self.basePath/branchLine['path']/'.id_pastaELN.json', 'w', encoding='utf-8') as fOut:
               fOut.write(json.dumps(docLine))
     return oldPath, path
@@ -466,15 +474,15 @@
 
     Args:
       docID (string): id of document to remove
 
     Returns:
       dict: document that was removed
     """
-    tracebackString(True, 'remove:'+docID)
+    tracebackString(True, f'remove:{docID}')
     doc = self.db[docID]
     res = dict(doc)
     doc.delete()
     return res
 
 
   def addAttachment(self, docID:str, name:str, content:dict[str,Any]) -> bool:
@@ -487,23 +495,23 @@
         content (dict): dictionary of content to be added (should include user,date,docID,remark)
 
     Returns:
         bool: success of method
     """
     try:
       doc = self.db[docID]
-      if not '-attachment' in doc:
+      if '-attachment' not in doc:
         doc['-attachment'] = {}
       if name in doc['-attachment']:
         doc['-attachment'][name] += [content]
       else:
         doc['-attachment'][name] = [content]
       doc.save()
       return True
-    except:
+    except Exception:
       return False
 
 
 
   def getView(self, thePath:str, startKey:Optional[str]=None, preciseKey:Optional[str]=None) -> list[dict[str,Any]]:
     """
     Wrapper for getting view function
@@ -517,20 +525,20 @@
         list: list of documents in this view
     """
     from cloudant.view import View
     designDoc = self.db.get_design_document(thePath.split('/')[0])
     v = View(designDoc, thePath.split('/')[1])
     try:
       if startKey is not None:
-        res = v(startkey=startKey, endkey=startKey+'zzz')['rows']
+        res = v(startkey=startKey, endkey=f'{startKey}zzz')['rows']
       elif preciseKey is not None:
         res = v(key=preciseKey)['rows']
       else:
         res = list(v.result)
-    except:
+    except Exception:
       print('**ERROR dgv01: Database / Network problem for path |',thePath[0],thePath[1])
       print(traceback.format_exc())
       res = []
     return res
 
 
   def saveView(self, designName:str, viewCode:dict[str,str]) -> None:
@@ -538,24 +546,24 @@
     Adopt the view by defining a new jsCode
 
     Args:
         designName (string): name of the design
         viewCode (dict): viewName: js-code
     """
     from cloudant.design_document import DesignDocument
-    if '_design/'+designName in self.db:
-      designDoc = self.db['_design/'+designName]
+    if f'_design/{designName}' in self.db:
+      designDoc = self.db[f'_design/{designName}']
       designDoc.delete()
     designDoc = DesignDocument(self.db, designName)
     for view in viewCode:
       thisJsCode = 'function (doc) {\n' + viewCode[view] + '\n}'
       designDoc.add_view(view, thisJsCode)
     try:
       designDoc.save()
-    except:
+    except Exception:
       print('**ERROR dsv01: something unexpected has happend. Log-file has traceback')
     return
 
 
   def getHierarchy(self, start:str, allItems:bool=False) -> Node:
     """
     get hierarchy tree for projects, ...
@@ -576,24 +584,24 @@
     levelNum = 1
     while True:
       level = [i for i in view if len(i['key'].split())==levelNum]
       if levelNum==1:
         if len(level)==1:
           dataTree = Node(id=level[0]['key'], docType=level[0]['value'][1], name=level[0]['value'][2])
         else:
-          print('**ERROR getHierarchy Did not find corresponding '+str(levelNum) )
+          print(f'**ERROR getHierarchy Did not find corresponding {str(levelNum)}')
           dataTree = Node(id=None, name='')
       else:
         childList = [i['value'][0] for i in level]   #temporary list to allow sorting for child-number
         # https://stackoverflow.com/questions/6618515/sorting-list-based-on-values-from-another-list
         for node in [x for (_,x) in sorted(zip(childList, level), key=lambda pair: pair[0])]:
           parentID = node['key'].split()[-2]
           parentNode = find_by_attr(dataTree, parentID, name='id')
           _ = Node(id=node['id'], parent=parentNode, docType=node['value'][1], name=node['value'][2])
-      if len(level)==0:
+      if not level: #if len(level)==0
         break
       levelNum += 1
     # print(RenderTree(dataTree, style=AsciiStyle()))
     return dataTree
 
 
   def hideShow(self, stack:Union[str,list[str]]) -> None:
@@ -604,24 +612,24 @@
       stack (list, str): stack of docID; docID (str)
     """
     flippedOnce = False
     if isinstance(stack, str):
       doc = self.db[stack]
       for idx, _ in enumerate(doc['-branch']):
         doc['-branch'][idx]['show'][-1] = not doc['-branch'][idx]['show'][-1]
-        logging.debug('flipped str: '+str(stack))
+        logging.debug('flipped str: %s',str(stack))
       doc.save()
       if stack[0]=='x':
         stack = doc['-branch'][0]['stack']+[stack]
       flippedOnce = True
     if isinstance(stack, list):
       iFlip = len(stack)-1
-      logging.debug('  database list '+str(stack)+' '+str(iFlip) )
+      logging.debug('  database list %s %s',str(stack),str(iFlip))
       for item in self.getView('viewHierarchy/viewHierarchyAll', startKey=' '.join(stack)):
-        logging.debug('  docID: '+str(item['id']))
+        logging.debug('  docID: %s',item['id'])
         doc = self.db[item['id']]
         for idx, branch in enumerate(doc['-branch']):
           if not flippedOnce or iFlip!=len(branch['stack']):
             doc['-branch'][idx]['show'][iFlip] = not doc['-branch'][idx]['show'][iFlip]
         doc.save()
     if doc['-type'][0][0]=='x':
       with open(self.basePath/doc['-branch'][0]['path']/'.id_pastaELN.json','w', encoding='utf-8') as fOut:
@@ -642,25 +650,17 @@
         str: report
     """
     progressBar.show()
     try:
       rep = Replicator(self.client)
       try:
         client2 = CouchDB(dbInfo['user'], dbInfo['password'], url=dbInfo['url'], connect=True)
-      except:
+      except Exception:
         return '<b>ERROR drp01: Could not connect to remote server. Abort replication.</b><br>'+\
-               'user:'+dbInfo['user']+'<br>password:'+dbInfo['password']+'<br>url:'+dbInfo['url']
-      try:
-        listAllDataBases = client2.all_dbs()
-        if dbInfo['database'] in listAllDataBases and removeAtStart:
-          client2.delete_database(dbInfo['database'])
-        if not dbInfo['database'] in listAllDataBases:
-          db2 = client2.create_database(dbInfo['database'])
-      except:
-        pass
+                 'user:'+dbInfo['user']+'<br>password:'+dbInfo['password']+'<br>url:'+dbInfo['url']
       db2 = client2[dbInfo['database']]
       replResult = rep.create_replication(self.db, db2, create_target=False, continuous=False)
       logging.info('Start replication '+replResult['_id']+'.')
       progressBar.setValue(10)
       #try every 10sec whether replication success. Do that for max. of 5min
       startTime = time.time()
       while True:
@@ -669,65 +669,67 @@
           logging.info('Stop waiting for replication '+replResult['_id']+'.')
           progressBar.hide()
           return "Waited for 5min. No replication success in that time"
         replResult.fetch()        # get updated, latest version from the server
         if '_replication_state' in replResult:
           logging.info('Success replication '+replResult['_id']+'.')
           progressBar.hide()
-          return "Replication success state: "+replResult['_replication_state']
+          reply = f"Replication success state: {replResult['_replication_state']}\n" + \
+                  f"  time of reporting: {replResult['_replication_state_time']}\n"
+          stats = dict(replResult['_replication_stats'])
+          del stats['checkpointed_source_seq']
+          return reply+'\n  '.join([f"{k.replace('_',' ')}:{v}" for k,v in stats.items()])
         time.sleep(10)
-    except:
+    except Exception:
       progressBar.hide()
       return "**ERROR drp02: replicate error |\n"+traceback.format_exc()
 
 
 
   def historyDB(self) -> dict[str,Any]:
     """
     Collect last modification days of documents
     """
     from datetime import datetime
     import numpy as np
     collection:dict[str,Any] = {}
     for doc in self.db:
-      if doc['_id'][1]=='-' and len(doc['_id'])==34:
-        if '-type' in doc and '-date' in doc:
-          docType = doc['-type'][0]
-          date = doc['-date'][:-1]
-          if len(date)==22:
-            date += '0'
-          date    = datetime.fromisoformat( date ).timestamp()
-          if docType in collection:
-            collection[docType] = collection[docType] + [date]
-          else:
-            collection[docType] = [date]
+      if doc['_id'][1]=='-' and len(doc['_id'])==34 and '-type' in doc and '-date' in doc:
+        docType = doc['-type'][0]
+        date = doc['-date'][:-1]
+        if len(date)==22:
+          date += '0'
+        date    = datetime.fromisoformat( date ).timestamp()
+        if docType in collection:
+          collection[docType] = collection[docType] + [date]
+        else:
+          collection[docType] = [date]
     #determine bins for histogram
     firstSubmit = datetime.now().timestamp()
-    for key,value in collection.items():
+    for value in collection.values():
       if np.min(value) < firstSubmit:
         firstSubmit = np.min(value)
     bins = np.linspace(firstSubmit, datetime.now().timestamp(), 100 )
     #calculate histgram and save it
     collectionCopy = dict(collection)
     for key,value in collection.items():
       hist, _ = np.histogram(value, bins)
       collectionCopy[key] = hist
     collectionCopy['-bins-'] = (bins[:-1]+bins[1:])/2
     #calculate score
     bias = np.exp(( collectionCopy['-bins-']-collectionCopy['-bins-'][-1] ) / 1.e7)
-    score = {}
-    for key,value in collectionCopy.items():
-      score[key] = np.sum(value*bias)
+    score = {key: np.sum(value*bias) for key, value in collectionCopy.items()}
     #reformat dates into string
     collectionCopy['-bins-'] = [datetime.fromtimestamp(i).isoformat() for i in collectionCopy['-bins-']]
     collectionCopy['-score-']= score
     return collectionCopy
 
 
   def checkDB(self, outputStyle:str='text', repair:bool=False, minimal:bool=False) -> str:
+    # sourcery skip: lift-duplicated-conditional, merge-else-if-into-elif
     """
     Check database for consistencies by iterating through all documents
     - slow since no views used
     - check views
     - only reporting, no repair
     - custom changes are possible with normal scan
     - no interaction with harddisk
@@ -841,121 +843,116 @@
         #
         #   #   if len(doc['-branch'][0]['stack']) == len(doc['-branch'][0]['path'].split('/'))-1 :
         #   #     doc['-type'] = ["x"+str(len(doc['-branch'][0]['stack'])) ]
         #   # print("after ",doc.keys(),doc['_id'])
 
         #branch test
         if '-branch' not in doc:
-          outstring+= outputString(outputStyle,'error','dch01: branch does not exist '+doc['_id'])
+          outstring+= outputString(outputStyle,'error',f"dch01: branch does not exist {doc['_id']}")
           continue
         if len(doc['-branch'])>1 and doc['-type'] =='x':                 #text elements only one branch
-          outstring+= outputString(outputStyle,'error','dch02: branch length >1 for text'+doc['_id']+' '+str(doc['-type']))
+          outstring+= outputString(outputStyle,'error',f"dch02: branch length >1 for text {doc['_id']} {str(doc['-type'])}")
         for branch in doc['-branch']:
           for item in branch['stack']:
             if not item.startswith('x-'):
-              outstring+= outputString(outputStyle,'error','dch03: non-text in stack '+doc['_id'])
+              outstring+= outputString(outputStyle,'error',f"dch03: non-text in stack {doc['_id']}")
 
           if len(branch['stack'])==0 and doc['-type']!=['x0']: #if no inheritance
             if doc['-type'][0] == 'measurement' or  doc['-type'][0][0] == 'x':
-              outstring+= outputString(outputStyle,'warning','branch stack length = 0: no parent '+doc['_id'])
-            else:
-              if not minimal:
-                outstring+= outputString(outputStyle,'okish','branch stack length = 0: no parent for procedure/sample '+doc['_id']+'|'+doc['-name'])
-          if not '-type' in doc or len(doc['-type'])==0:
-            outstring+= outputString(outputStyle,'unsure','dch04: no type in (removed data?)'+doc['_id'])
+              outstring+= outputString(outputStyle,'warning',f"branch stack length = 0: no parent {doc['_id']}")
+            elif not minimal:
+              outstring+= outputString(outputStyle,'okish',f"branch stack length = 0: no parent for procedure/sample {doc['_id']} | {doc['-name']}")
+          if '-type' not in doc or len(doc['-type'])==0:
+            outstring+= outputString(outputStyle,'unsure',f"dch04: no type in (removed data?) {doc['_id']}")
             continue
           if doc['-type'][0][0]=='x':
             try:
               dirNamePrefix = branch['path'].split(os.sep)[-1].split('_')[0]
               if dirNamePrefix.isdigit() and branch['child']!=int(dirNamePrefix): #compare child-number to start of directory name
-                outstring+= outputString(outputStyle,'error','dch05: child-number and dirName dont match '+doc['_id'])
-            except:
+                outstring+= outputString(outputStyle,'error',f"dch05: child-number and dirName dont match {doc['_id']}")
+            except Exception:
               pass  #handled next lines
           if branch['path'] is None:
             if doc['-type'][0][0] == 'x':
-              outstring+= outputString(outputStyle,'error','dch06: branch path is None '+doc['_id'])
+              outstring+= outputString(outputStyle,'error',f"dch06: branch path is None {doc['_id']}")
             elif doc['-type'][0] == 'measurement':
               if not minimal:
                 outstring+= outputString(outputStyle,'okish','measurement branch path is None=no data '+doc['_id']+' '+doc['-name'])
-            else:
-              if not minimal:
-                outstring+= outputString(outputStyle,'ok','procedure/sample with empty path '+doc['_id'])
-          else:                                                            #if sensible path
+            elif not minimal:
+              outstring+= outputString(outputStyle,'ok',f"procedure/sample with empty path {doc['_id']}")
+          else:                                                    #if sensible path
             if len(branch['stack'])+1 != len(branch['path'].split(os.sep)):#check if length of path and stack coincide
               if doc['-type'][0] == 'procedure':
                 if not minimal:
-                  outstring+= outputString(outputStyle,'ok','procedure: branch stack and path lengths not equal: '+doc['_id']+'|'+branch['path'][:30])
+                  outstring+= outputString(outputStyle,'ok',f"procedure: branch stack and path lengths not equal: {doc['_id']} | {branch['path'][:30]}")
               else:
-                outstring+= outputString(outputStyle,'unsure','branch stack and path lengths not equal: '+doc['_id']+'|'+branch['path'][:30])
+                outstring+= outputString(outputStyle,'unsure',f"branch stack and path lengths not equal: {doc['_id']} | {branch['path'][:30]}")
             if branch['child'] != 9999:
-              for parentID in branch['stack']:                              #check if all parents in doc have a corresponding path
+              for parentID in branch['stack']:                  #check if all parents in doc have a corresponding path
                 parentDoc = self.getDoc(parentID)
                 if '-branch' not in parentDoc:
-                  outstring+= outputString(outputStyle,'error','dch07: branch not in parent with id '+parentID)
+                  outstring += outputString(outputStyle, 'error', f'dch07: branch not in parent with id {parentID}')
                   continue
                 parentDocBranches = parentDoc['-branch']
-                onePathFound = False
-                for parentBranch in parentDocBranches:
-                  if parentBranch['path'] is not None and parentBranch['path'] in branch['path']:
-                    onePathFound = True
+                onePathFound = any(parentBranch['path'] is not None and parentBranch['path'] in branch['path'] for parentBranch in parentDocBranches)
                 if not onePathFound:
-                  outstring+= outputString(outputStyle,'unsure','dch08: parent does not have corresponding path (remote content) '+doc['_id']+'| parentID '+parentID)
+                  outstring+= outputString(outputStyle,'unsure',f"dch08: parent does not have corresponding path (remote content) {doc['_id']} | parentID {parentID}")
           if 'show' not in branch:
-            outstring+= outputString(outputStyle,'error','dch08a: branch does not have show: '+doc['_id'])
+            outstring+= outputString(outputStyle,'error',f"dch08a: branch does not have show: {doc['_id']}")
           elif len(branch['show']) != len(branch['stack'])+1:
-            outstring+= outputString(outputStyle,'error','dch08b: branch-show not same length as branch-stack: '+doc['_id'])
-          #TODO_P5 moreChecksDB: if parent has corresponding show
+            outstring+= outputString(outputStyle,'error',f"dch08b: branch-show not same length as branch-stack: {doc['_id']}")
+                #TODO_P5 moreChecksDB: if parent has corresponding show
 
         #every doc should have a name
-        if not '-name' in doc:
-          outstring+= outputString(outputStyle,'unsure','dch17: -name not in (deleted doc?)'+doc['_id'])
+        if '-name' not in doc:
+          outstring+= outputString(outputStyle,'unsure',f"dch17: -name not in (deleted doc?){doc['_id']}")
           if repair and 'name' in doc:  #repair from v0.9.9->1.0.0
             doc['-name']=doc['name']
             del doc['name']
             doc.save()
 
-        if not '-tags' in doc:
-          outstring+= outputString(outputStyle,'error','dch17b: -tags not in doc'+doc['_id'])
+        if '-tags' not in doc:
+          outstring+= outputString(outputStyle,'error',f"dch17b: -tags not in doc{doc['_id']}")
 
         #doc-type specific tests
         if '-type' in doc and doc['-type'][0] == 'sample':
           if 'qrCode' not in doc:
-            outstring+= outputString(outputStyle,'error','dch09: qrCode not in sample '+doc['_id'])
+            outstring+= outputString(outputStyle,'error',f"dch09: qrCode not in sample {doc['_id']}")
         elif '-type' in doc and doc['-type'][0] == 'measurement':
           if 'shasum' not in doc:
-            outstring+= outputString(outputStyle,'error','dch10: shasum not in measurement '+doc['_id'])
+            outstring+= outputString(outputStyle,'error',f"dch10: shasum not in measurement {doc['_id']}")
           if 'image' not in doc:
-            outstring+= outputString(outputStyle,'error','dch11: image not in measurement '+doc['_id'])
+            outstring+= outputString(outputStyle,'error',f"dch11: image not in measurement {doc['_id']}")
           else:
             if doc['image'].startswith('data:image'):  #for jpg and png
               try:
                 imgdata = base64.b64decode(doc['image'][22:])
                 Image.open(io.BytesIO(imgdata))  #can convert, that is all that needs to be tested
-              except:
-                outstring+= outputString(outputStyle,'error','dch12: jpg-image not valid '+doc['_id'])
+              except Exception:
+                outstring+= outputString(outputStyle,'error',f"dch12: jpg-image not valid {doc['_id']}")
             elif doc['image'].startswith('<?xml'):
               #from https://stackoverflow.com/questions/63419010/check-if-an-image-file-is-a-valid-svg-file-in-python
               SVG_R = r'(?:<\?xml\b[^>]*>[^<]*)?(?:<!--.*?-->[^<]*)*(?:<svg|<!DOCTYPE svg)\b'
               SVG_RE = re.compile(SVG_R, re.DOTALL)
               if SVG_RE.match(doc['image']) is None:
-                outstring+= outputString(outputStyle,'error','dch13: svg-image not valid '+doc['_id'])
+                outstring+= outputString(outputStyle,'error',f"dch13: svg-image not valid {doc['_id']}")
             elif doc['image']=='':
-              outstring+= outputString(outputStyle,'unsure','image not valid '+doc['_id']+' '+doc['image'])
+              outstring+= outputString(outputStyle,'unsure',f"image not valid {doc['_id']} {doc['image']}")
             else:
-              outstring+= outputString(outputStyle,'error','dch14: image not valid '+doc['_id']+' '+doc['image'])
+              outstring+= outputString(outputStyle,'error',f"dch14: image not valid {doc['_id']} {doc['image']}")
 
-      except: #if test of document fails
-        outstring+= outputString(outputStyle,'error','dch15: critical error in '+doc['_id']+'\n'+traceback.format_exc())
+      except Exception:
+        outstring+= outputString(outputStyle,'error', f"dch15: critical error in {doc['_id']}\n {traceback.format_exc()}")
 
     ##TEST views
     outstring+= outputString(outputStyle,'h2','List problematic database tables')
     view = self.getView('viewIdentify/viewSHAsum')
     shasumKeys = []
     for item in view:
       if item['key']=='':
-        outstring+= outputString(outputStyle,'error','measurement without shasum: '+item['id']+' '+item['value'])
+        outstring+= outputString(outputStyle,'error', f"measurement without shasum: {item['id']} {item['value']}")
       else:
         if item['key'] in shasumKeys:
-          key = item['key'] if item['key'] else '- empty string -'
-          outstring+= outputString(outputStyle,'error','dch16: shasum twice in view: '+key+' '+item['id']+' '+item['value'])
+          key = item['key'] or '- empty string -'
+          outstring += outputString(outputStyle, 'error', f"dch16: shasum twice in view: {key} {item['id']} {item['value']}")
         shasumKeys.append(item['key'])
     return outstring
```

## pasta_eln/dialogConfigAuthors.py

```diff
@@ -45,37 +45,39 @@
       item (str): property name in configuration file
       label (str): label used in form
 
     Returns:
       QTextEdit: text-edit widget with content
     """
     rightW = QLineEdit()
-    if item in ['organization','rorid']:
+    if item in {'organization','rorid'}:
       rightW.setText(self.backend.configuration['authors'][0]['organizations'][0][item])
     else:
       rightW.setText(self.backend.configuration['authors'][0][item])
     rightW.setAccessibleName(item)
-    if item in ['rorid','orcid']:
+    if item in {'rorid','orcid'}:
       rightW.editingFinished.connect(self.changedID)
     self.tabAppearanceL.addRow(QLabel(label), rightW)
     return rightW
 
 
   def changedID(self) -> None:
     """
     Autofill based on orcid and rorid
     """
     sender = self.sender().accessibleName()
     if sender == 'rorid':
       if re.match(r'^\w{9}$', self.userRorid.text().strip() ) is not None:
-        reply = requests.get('https://api.ror.org/organizations/'+self.userRorid.text().strip())
+        reply = requests.get(
+            f'https://api.ror.org/organizations/{self.userRorid.text().strip()}')
         self.userOrganization.setText(reply.json()['name'])
     elif sender == 'orcid':
       if re.match(r'^\w{4}-\w{4}-\w{4}-\w{4}$', self.userOrcid.text().strip() ) is not None:
-        reply = requests.get('https://pub.orcid.org/v3.0/'+self.userOrcid.text().strip())
+        reply = requests.get(
+            f'https://pub.orcid.org/v3.0/{self.userOrcid.text().strip()}')
         text = reply.content.decode()
         first = text.split('<personal-details:given-names>')[1].split('</personal-details:given-names>')[0]
         last = text.split('<personal-details:family-name>')[1].split('</personal-details:family-name>')[0]
         self.userFirst.setText(first)
         self.userLast.setText(last)
     else:
       print('**ERROR: did not understand sender')
```

## pasta_eln/dialogConfigSetupWindows.py

```diff
@@ -51,16 +51,17 @@
 
     Args:
       number (int): integer to move to
     """
     self.progress1.setValue(number)
     return
 
-
+  # create windows package: Packaging Pyside6 applications for Windows with PyInstaller & InstallForge
   def analyse(self) -> None:
+    # sourcery skip: extract-duplicate-method, inline-immediately-returned-variable
     """
     Main method that does all the analysis: open dialogs, ...
     """
     flagContinue = True
     flagInstalledSoftware = False
     logging.info('Windows setup analyse start')
 
@@ -74,15 +75,15 @@
         button = QMessageBox.question(self, "CouchDB installation", couchDBWindows)
         if button == QMessageBox.Yes:
           res = couchdb('install')
           flagInstalledSoftware = True
           if len(res.split('|'))==3:
             password=res.split('|')[1]
           else:
-            logging.error('Could not retrieve password :'+str(res))
+            logging.error('Could not retrieve password :%s',str(res))
         else:
           self.mainText = self.mainText.replace('- CouchDB','- CouchDB: user chose to NOT install' )
           self.text1.setMarkdown(self.mainText)
           flagContinue = False
 
     #Configuration
     if flagContinue:
```

## pasta_eln/dialogForm.py

```diff
@@ -1,15 +1,16 @@
 """ New/Edit dialog (dialog is blocking the main-window, as opposed to create a new widget-window)"""
-import logging, re, copy
+import logging, re, copy, subprocess, platform, os
 from typing import Any, Union
-from PySide6.QtWidgets import QDialog, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QTextEdit, QPushButton,\
-                              QPlainTextEdit, QComboBox, QLineEdit, QDialogButtonBox, QSplitter, QSizePolicy # pylint: disable=no-name-in-module
+from pathlib import Path
+from PySide6.QtWidgets import QDialog, QWidget, QVBoxLayout, QHBoxLayout, QDialogButtonBox, QSplitter, QSizePolicy, QMenu # pylint: disable=no-name-in-module
+from PySide6.QtWidgets import QLabel, QTextEdit, QPushButton, QPlainTextEdit, QComboBox, QLineEdit # pylint: disable=no-name-in-module
 from PySide6.QtGui import QRegularExpressionValidator # pylint: disable=no-name-in-module
-from PySide6.QtCore import QSize                      # pylint: disable=no-name-in-module
-from .style import Image, TextButton, IconButton, Label, showMessage, widgetAndLayout
+from PySide6.QtCore import QSize, Qt, QPoint                  # pylint: disable=no-name-in-module
+from .style import Image, TextButton, IconButton, Label, Action, showMessage, widgetAndLayout
 from .fixedStrings import defaultOntologyNode
 from .handleDictionaries import fillDocBeforeCreate
 from .miscTools import createDirName
 from .communicate import Communicate
 
 class Form(QDialog):
   """ New/Edit dialog (dialog is blocking the main-window, as opposed to create a new widget-window)"""
@@ -20,15 +21,15 @@
     Args:
       comm (Communicate): communication channel
       doc (dict):  document to change / create
     """
     super().__init__()
     self.comm = comm
     self.db   = self.comm.backend.db
-    self.doc  = dict(doc)
+    self.doc  = copy.deepcopy(doc)
     if '_attachments' in self.doc:
       del self.doc['_attachments']
     self.flagNewDoc = True
     if '_id' in self.doc or '_ids' in self.doc:
       self.flagNewDoc = False
     if self.flagNewDoc:
       self.setWindowTitle('Create new entry')
@@ -37,18 +38,21 @@
       self.setWindowTitle('Edit content')
     self.setMinimumWidth(600)
 
     # GUI elements
     mainL = QVBoxLayout(self)
     if 'image' in self.doc:
       width = self.comm.backend.configuration['GUI']['imageSizeDetails'] \
-                if hasattr(self.comm.backend, 'configuration') else 300
-      Image(self.doc['image'], mainL, anyDimension=width)
-    _, self.formL = widgetAndLayout('Form', mainL, 's')
+                  if hasattr(self.comm.backend, 'configuration') else 300
+      imageW, imageL = widgetAndLayout('V', mainL)
+      Image(self.doc['image'], imageL, anyDimension=width)
+      imageW.setContextMenuPolicy(Qt.CustomContextMenu)
+      imageW.customContextMenuRequested.connect(self.contextMenu)
 
+    _, self.formL = widgetAndLayout('Form', mainL, 's')
     #Add things that are in ontology
     if '_ids' not in self.doc:  #normal form
       setattr(self, 'key_-name', QLineEdit(self.doc['-name']))
       getattr(self, 'key_-name').setValidator(QRegularExpressionValidator("[\\w\\ .-]+"))
       self.formL.addRow('Name', getattr(self, 'key_-name'))
     if self.doc['-type'][0] in self.db.ontology:
       ontologyNode = self.db.ontology[self.doc['-type'][0]]['prop']
@@ -65,34 +69,39 @@
         continue
       # print("Key:value in form | "+key+':'+str(value))
       if key in ['comment','content']:
         labelW, labelL = widgetAndLayout('V')
         labelL.addWidget(QLabel(key.capitalize()))
         TextButton('More', self.btnFocus, labelL, key, checkable=True)  # type: ignore # btnFocus req. bool, cannot get it to work
         rightSideW, rightSideL = widgetAndLayout('V')
-        setattr(self, 'buttonBarW_'+key, QWidget())
-        getattr(self, 'buttonBarW_'+key).hide()
-        buttonBarL = QHBoxLayout(getattr(self, 'buttonBarW_'+key))
+        setattr(self, f'buttonBarW_{key}', QWidget())
+        getattr(self, f'buttonBarW_{key}').hide()
+        buttonBarL = QHBoxLayout(getattr(self, f'buttonBarW_{key}'))
         for name, tooltip in [['bold','Bold text'],['italic','Italic text'],['list-ul','Bullet list'],\
-                              ['list-ol','Numbered list']]:
-          IconButton('fa5s.'+name, self.btnText, buttonBarL, name+'_'+key, tooltip)
+                                ['list-ol','Numbered list']]:
+          IconButton(f'fa5s.{name}', self.btnText, buttonBarL, f'{name}_{key}', tooltip)
         for i in range(1,4):
-          IconButton('mdi.format-header-'+str(i), self.btnText, buttonBarL, 'heading'+str(i)+'_'+key, \
-                     'Heading '+str(i))
-        rightSideL.addWidget(getattr(self, 'buttonBarW_'+key))
-        setattr(self, 'textEdit_'+key, QPlainTextEdit(value))
-        getattr(self, 'textEdit_'+key).setAccessibleName(key)
-        getattr(self, 'textEdit_'+key).textChanged.connect(self.textChanged)
-        setattr(self, 'textShow_'+key, QTextEdit(value))
-        getattr(self, 'textShow_'+key).setReadOnly(True)
-        getattr(self, 'textShow_'+key).hide()
+          IconButton(
+              f'mdi.format-header-{str(i)}',
+              self.btnText,
+              buttonBarL,
+              f'heading{str(i)}_{key}',
+              f'Heading {str(i)}',
+          )
+        rightSideL.addWidget(getattr(self, f'buttonBarW_{key}'))
+        setattr(self, f'textEdit_{key}', QPlainTextEdit(value))
+        getattr(self, f'textEdit_{key}').setAccessibleName(key)
+        getattr(self, f'textEdit_{key}').textChanged.connect(self.textChanged)
+        setattr(self, f'textShow_{key}', QTextEdit(value))
+        getattr(self, f'textShow_{key}').setReadOnly(True)
+        getattr(self, f'textShow_{key}').hide()
         splitter= QSplitter()
         splitter.setSizePolicy(QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding))
-        splitter.addWidget(getattr(self, 'textEdit_'+key))
-        splitter.addWidget(getattr(self, 'textShow_'+key))
+        splitter.addWidget(getattr(self, f'textEdit_{key}'))
+        splitter.addWidget(getattr(self, f'textShow_{key}'))
         rightSideL.addWidget(splitter)
         self.formL.addRow(labelW, rightSideW)
       elif key == '-tags':
         tagsBarMainW, tagsBarMainL = widgetAndLayout('H', spacing='s')
         _, self.tagsBarSubL = widgetAndLayout('H', tagsBarMainL, spacing='s', right='m') #part which shows all the tags
         self.otherChoices = QComboBox()   #part/combobox that allow user to select
         self.otherChoices.setEditable(True)
@@ -106,53 +115,51 @@
         self.gradeChoices.setIconSize(QSize(0,0))
         self.gradeChoices.addItems(['','\u2605','\u2605'*2,'\u2605'*3,'\u2605'*4,'\u2605'*5])
         self.gradeChoices.currentTextChanged.connect(self.addTag)
         tagsBarMainL.addWidget(self.gradeChoices)
         self.formL.addRow(QLabel('Tags:'), tagsBarMainW)
         self.updateTagsBar()
         self.otherChoices.currentIndexChanged.connect(self.addTag) #connect to slot only after all painting is done
-      elif isinstance(value, list):       #list of items, qrCodes in sample
+      elif isinstance(value, list):   #list of items, qrCodes in sample
         if len(value)>0 and isinstance(value[0], str):
-          setattr(self, 'key_'+key, QLineEdit(' '.join(value)))
+          setattr(self, f'key_{key}', QLineEdit(' '.join(value)))
         else:
-          setattr(self, 'key_'+key, QLineEdit('-- strange content --'))
-        self.formL.addRow(QLabel(key.capitalize()), getattr(self, 'key_'+key))
-      elif isinstance(value, str):        #string
+          setattr(self, f'key_{key}', QLineEdit('-- strange content --'))
+        self.formL.addRow(QLabel(key.capitalize()), getattr(self, f'key_{key}'))
+      elif isinstance(value, str):    #string
         ontologyItem = [i for i in ontologyNode if i['name']==key]
-        if len(ontologyItem)==1 and 'list' in ontologyItem[0]:             #choice dropdown
-          setattr(self, 'key_'+key, QComboBox())
-          if isinstance(ontologyItem[0]['list'], list):                    #ontology-defined choices
-            getattr(self, 'key_'+key).addItems(ontologyItem[0]['list'])
-          else:                                                            #choice among docType
+        if len(ontologyItem)==1 and 'list' in ontologyItem[0]:       #choice dropdown
+          setattr(self, f'key_{key}', QComboBox())
+          if isinstance(ontologyItem[0]['list'], list):            #ontology-defined choices
+            getattr(self, f'key_{key}').addItems(ontologyItem[0]['list'])
+          else:                                                    #choice among docType
             listDocType = ontologyItem[0]['list']
-            getattr(self, 'key_'+key).addItem('- no link -', userData='')
-            for line in self.db.getView('viewDocType/'+listDocType):
-              getattr(self, 'key_'+key).addItem(line['value'][0], userData=line['id'])
+            getattr(self, f'key_{key}').addItem('- no link -', userData='')
+            for line in self.db.getView(f'viewDocType/{listDocType}'):
+              getattr(self, f'key_{key}').addItem(line['value'][0], userData=line['id'])
               if line['value'][0] == value:
-                getattr(self, 'key_'+key).setCurrentText(line['value'][0])
-        else:                                         #text area
-          setattr(self, 'key_'+key, QLineEdit(value))
-        self.formL.addRow(QLabel(key.capitalize()), getattr(self, 'key_'+key))
+                getattr(self, f'key_{key}').setCurrentText(line['value'][0])
+        else:                                   #text area
+          setattr(self, f'key_{key}', QLineEdit(value))
+        self.formL.addRow(QLabel(key.capitalize()), getattr(self, f'key_{key}'))
       else:
         print("**ERROR dialogForm: unknown value type",key, value)
     #add extra questions at bottom of form
     allowProjectAndDocTypeChange = '_id' in self.doc and self.doc['-type'][0][0]!='x'
     if '_ids' in self.doc: #if group edit
-      allowProjectAndDocTypeChange = True
-      for docID in self.doc['_ids']:
-        if docID[0]=='x':
-          allowProjectAndDocTypeChange = False
+      allowProjectAndDocTypeChange = not any(docID[0]=='x' for docID in self.doc['_ids'])
     if allowProjectAndDocTypeChange: #if not-new and non-folder
       self.formL.addRow(QLabel('Special properties:'), QLabel('') )
     label = '- unassigned -' if self.flagNewDoc else '- no change -'
     if allowProjectAndDocTypeChange or ('_id' not in self.doc and self.doc['-type'][0][0]!='x'): #if new and non-folder
       self.projectComboBox = QComboBox()
       self.projectComboBox.addItem(label, userData='')
       for line in self.db.getView('viewDocType/x0'):
-        self.projectComboBox.addItem(line['value'][0], userData=line['id'])
+        if not '-branch' in self.doc or not any(line['id']==branch['stack'][0] for branch in self.doc['-branch']):
+          self.projectComboBox.addItem(line['value'][0], userData=line['id'])
       self.formL.addRow(QLabel('Project'), self.projectComboBox)
     if allowProjectAndDocTypeChange: #if not-new and non-folder
       self.docTypeComboBox = QComboBox()
       self.docTypeComboBox.addItem(label, userData='')
       for key, value in self.db.dataLabels.items():
         if key[0]!='x':
           self.docTypeComboBox.addItem(value, userData=key)
@@ -161,19 +168,21 @@
     #final button box
     buttonBox = QDialogButtonBox(QDialogButtonBox.Cancel | QDialogButtonBox.Save)
     if self.flagNewDoc: #new dataset
       buttonBox.addButton('Save && Next', QDialogButtonBox.ApplyRole)
     buttonBox.clicked.connect(self.save)
     mainL.addWidget(buttonBox)
 
+  # TODO_P2 make markdown format correctly immediately
+  # TODO_P2 move folder to different folder: use unidentified for notes
   # TODO_P4 add splitter to increase / decrease image
-  # TODO_P3 image does not allow for easy context aware clicks
   # TODO_P3 form: add button to add key-values
-  # TODO_P3 other items as non-edible things that can be copy-pasted
+  # TODO_P3 form: other items as non-edible things that can be copy-pasted
   def save(self, btn:QPushButton) -> None:
+    # sourcery skip: merge-else-if-into-elif
     """
     Action upon save / cancel
     """
     if self.otherChoices.hasFocus():
       return
     if btn.text().endswith('Cancel'):
       self.reject()
@@ -181,52 +190,59 @@
       # create the data that has to be saved
       if hasattr(self, 'key_-name'):
         self.doc['-name'] = getattr(self, 'key_-name').text().strip()
         if self.doc['-name'] == '':
           showMessage(self, 'Error', 'A created item has to have a valid name')
           return
         if self.doc['-type'][0]=='x0':  #prevent project-directory names that are identical
-          others = [i['value'][0] for i in self.comm.backend.db.getView('viewDocType/x0All')]
-          others = [createDirName(i,'x0', 0) for i in others]
-          while createDirName(self.doc['-name'],'x0', 0) in others:
+          others = self.comm.backend.db.getView('viewDocType/x0All')
+          if '_id' in self.doc:
+            others = [i for i in others if i['id']!=self.doc['_id']] # create list of names but filter own name
+          others = [i['value'][0] for i in others]
+          othersList = [createDirName(str(i),'x0', 0) for i in others] #create names
+          while createDirName(self.doc['-name'],'x0', 0) in othersList:
             if re.search(r"_\d+$", self.doc['-name']) is None:
               self.doc['-name'] += '_1'
             else:
               self.doc['-name'] = '_'.join(self.doc['-name'].split('_')[:-1])+'_'+str(int(self.doc['-name'].split('_')[-1])+1)
       # loop through all the subitems
       for key, valueOld in self.doc.items():
-        if key[0] in ['_','-'] or key in ['image','metaVendor','metaUser'] or \
-            (not hasattr(self, 'key_'+key) and not hasattr(self, 'textEdit_'+key)):
+        if (key[0] in ['_', '-'] or key in ['image', 'metaVendor', 'metaUser']
+            or not hasattr(self, f'key_{key}') and not hasattr(self, f'textEdit_{key}')):
           continue
         if key in ['comment','content']:
-          text = getattr(self, 'textEdit_'+key).toPlainText().strip()
-          if ('_ids' in self.doc and text!='') or '_id' in self.doc:  #if group edit, text has to have text
+          text = getattr(self, f'textEdit_{key}').toPlainText().strip()
+          if not ('_ids' in self.doc and not text):  #if group edit, text has to have text
             self.doc[key] = text
             if key == 'content' and '-branch' in self.doc:
               for branch in self.doc['-branch']:
                 if branch['path'] is not None:
                   if branch['path'].endswith('.md'):  #TODO_P5 only write markdown files for now
                     with open(self.comm.backend.basePath/branch['path'], 'w', encoding='utf-8') as fOut:
                       fOut.write(self.doc['content'])
                     logging.debug('Wrote new content to '+branch['path'])
                   else:
                     showMessage(self, 'Information', 'Did update the database but not the file on harddisk, since PASTA-ELN cannot write this format')
         elif isinstance(valueOld, list):  #items that are comma separated in the text-field
-          self.doc[key] = getattr(self, 'key_'+key).text().strip().split(' ')
+          self.doc[key] = getattr(self, f'key_{key}').text().strip().split(' ')
         elif isinstance(valueOld, str):
-          if isinstance(getattr(self, 'key_'+key), QComboBox):
-            valueNew         = getattr(self, 'key_'+key).currentText()
-            if valueNew!='- no link -' and getattr(self, 'key_'+key).currentData() is not None and \
-              re.search(r"^[a-z\-]-[a-z0-9]{32}$",getattr(self, 'key_'+key).currentData()) is not None:
+          if isinstance(getattr(self, f'key_{key}'), QComboBox):
+            valueNew = getattr(self, f'key_{key}').currentText()
+            if (valueNew != '- no link -'
+                and getattr(self, f'key_{key}').currentData() is not None
+                and re.search(
+                    r"^[a-z\-]-[a-z0-9]{32}$",
+                    getattr(self, f'key_{key}').currentData(),
+                ) is not None):
               #if docID is stored in currentData
-              self.doc[key] = getattr(self, 'key_'+key).currentData()
+              self.doc[key] = getattr(self, f'key_{key}').currentData()
             elif valueNew!='- no link -' :
               self.doc[key] = valueNew
-          else:                                  #normal text field
-            self.doc[key] = getattr(self, 'key_'+key).text().strip()
+          else:                          #normal text field
+            self.doc[key] = getattr(self, f'key_{key}').text().strip()
         elif valueOld is None and key in self.doc:  #important entry, set to empty string
           self.doc[key]=''
         else:
           print("**ERROR dialogForm unknown value type",key, valueOld)
       # ---- if project changed: only branch save; remaining data still needs saving
       newProjID = []
       if hasattr(self, 'projectComboBox') and self.projectComboBox.currentData() != '':
@@ -235,38 +251,37 @@
           for docID in self.doc['_ids']:
             doc = self.db.getDoc(docID)
             if doc['-branch'][0]['stack']!=self.projectComboBox.currentData(): #only if project changed
               if doc['-branch'][0]['path'] is None:
                 newPath    = ''
               else:
                 oldPath    = self.comm.backend.basePath/doc['-branch'][0]['path']
-                newPath    = parentPath+'/'+oldPath.name
+                newPath = f'{parentPath}/{oldPath.name}'
                 oldPath.rename(self.comm.backend.basePath/newPath)
               self.db.updateBranch( doc['_id'], 0, 9999, [self.projectComboBox.currentData()], newPath)
-        elif '-branch' in self.doc:                   # sequential or single update
+        elif '-branch' in self.doc:             # sequential or single update
           if self.doc['-branch'][0]['stack']!=self.projectComboBox.currentData(): #only if project changed
             if self.doc['-branch'][0]['path'] is None:
               newPath    = ''
             else:
               oldPath    = self.comm.backend.basePath/self.doc['-branch'][0]['path']
-              newPath    = parentPath+'/'+oldPath.name
+              newPath = f'{parentPath}/{oldPath.name}'
             self.db.updateBranch( self.doc['_id'], 0, 9999, [self.projectComboBox.currentData()], newPath)
         else:
           newProjID = [self.projectComboBox.currentData()]
       # ---- if docType changed: save; no further save to db required ----
       if hasattr(self, 'docTypeComboBox') and self.docTypeComboBox.currentData() != '':
         self.doc['-type'] = [self.docTypeComboBox.currentData()]
         if '_ids' in self.doc: #group update
           for docID in self.doc.pop('_ids'):
             doc = self.db.getDoc(docID)
             doc.update( self.doc )
             self.db.remove(doc['_id'])
             del doc['_id']
             del doc['_rev']
-            doc['-name'] = doc['-name'] if doc['-branch'][0]['path'] is None else doc['-branch'][0]['path']
             doc = fillDocBeforeCreate(doc, self.docTypeComboBox.currentData())
             self.db.saveDoc(doc)
         else:                  #single or sequential update
           self.db.remove(self.doc['_id'])
           del self.doc['_id']
           del self.doc['_rev']
           self.doc = fillDocBeforeCreate(self.doc, self.docTypeComboBox.currentData())
@@ -296,39 +311,102 @@
         self.accept()  #close
         self.close()
     else:
       print('dialogForm: did not get a fitting btn ',btn.text())
     return
 
 
+  def contextMenu(self, pos:QPoint) -> None:
+    # sourcery skip: extract-method
+    """
+    Create a context menu
+
+    Args:
+      pos (position): Position to create context menu at
+    """
+    context = QMenu(self)
+    # for extractors
+    extractors = self.comm.backend.configuration['extractors']
+    extension = Path(self.doc['-branch'][0]['path']).suffix[1:]
+    if extension.lower() in extractors:
+      extractors = extractors[extension.lower()]
+      baseDocType= self.doc['-type'][0]
+      choices= {key:value for key,value in extractors.items() \
+                  if key.startswith(baseDocType)}
+      for key,value in choices.items():
+        Action(value, self.changeExtractor, context, self, name=key)
+      context.addSeparator()
+      Action('Save image',                       self.changeExtractor, context, self, name='_saveAsImage_')
+    #TODO_P2 not save now: when opening text files, system can crash
+    # Action('Open file with another application', self.changeExtractor, context, self, name='_openExternal_')
+    Action('Open folder in file browser',        self.changeExtractor, context, self, name='_openInFileBrowser_')
+    context.exec(self.mapToGlobal(pos))
+    return
+
+
+  def changeExtractor(self) -> None:
+    """
+    What happens when user changes extractor
+    """
+    menuName = self.sender().data()
+    filePath = Path(self.doc['-branch'][0]['path'])
+    if menuName in ['_openInFileBrowser_','_openExternal_']:
+      filePath = self.comm.backend.basePath/filePath
+      filePath = filePath if menuName=='_openExternal_' else filePath.parent
+      if platform.system() == 'Darwin':       # macOS
+        subprocess.call(('open', filePath))
+      elif platform.system() == 'Windows':    # Windows
+        os.startfile(filePath) # type: ignore[attr-defined]
+      else:                                   # linux variants
+        subprocess.call(('xdg-open', filePath))
+    elif menuName =='_saveAsImage_':
+      image = self.doc['image']
+      if image.startswith('data:image/'):
+        imageType = image[11:14] if image[14]==';' else image[11:15]
+      else:
+        imageType = 'svg'
+      saveFilePath = self.comm.backend.basePath/filePath.parent/f'{filePath.stem}_PastaExport.{imageType.lower()}'
+      path = Path(self.doc['-branch'][0]['path'])
+      if not path.as_posix().startswith('http'):
+        path = self.comm.backend.basePath/path
+      self.comm.backend.testExtractor(path, recipe='/'.join(self.doc['-type']), saveFig=str(saveFilePath))
+    else:
+      self.doc['-type'] = menuName.split('/')
+      self.comm.backend.useExtractors(filePath, self.doc['shasum'], self.doc)  #any path is good since the file is the same everywhere; data-changed by reference
+      if len(self.doc['-type'])>1 and len(self.doc['image'])>1:
+        self.doc = self.comm.backend.db.updateDoc({'image':self.doc['image'], '-type':self.doc['-type']}, self.doc['_id'])
+        self.comm.changeTable.emit('','')
+        self.comm.changeDetails.emit(self.doc['_id'])
+    return
+
 
   def btnFocus(self, status:bool) -> None:
     """
     Action if advanced button is clicked
     """
     key = self.sender().accessibleName()  #comment or content
     unknownWidget = []
     if status:
-      getattr(self, 'textShow_'+key).hide()
-      getattr(self, 'buttonBarW_'+key).hide()
+      getattr(self, f'textShow_{key}').hide()
+      getattr(self, f'buttonBarW_{key}').hide()
       for i in range(self.formL.count()):
         widget = self.formL.itemAt(i).widget()
         if isinstance(widget, (QLabel, QComboBox, QLineEdit)):
           widget.show()
         else:
           unknownWidget.append(i)
       if key=='content' and len(unknownWidget)==4:  #show / hide label and right-side of non-content and non-comment
         self.formL.itemAt(unknownWidget[0]).widget().show()
         self.formL.itemAt(unknownWidget[1]).widget().show()
       if key=='comment' and len(unknownWidget)==4:
         self.formL.itemAt(unknownWidget[2]).widget().show()
         self.formL.itemAt(unknownWidget[3]).widget().show()
     else:
-      getattr(self, 'textShow_'+key).show()
-      getattr(self, 'buttonBarW_'+key).show()
+      getattr(self, f'textShow_{key}').show()
+      getattr(self, f'buttonBarW_{key}').show()
       for i in range(self.formL.count()):
         widget = self.formL.itemAt(i).widget()
         if isinstance(widget, (QLabel, QComboBox, QLineEdit)):
           widget.hide()
         else:
           unknownWidget.append(i)
       if key=='content' and len(unknownWidget)==4:
@@ -342,33 +420,35 @@
 
   def btnText(self) -> None:
     """
     Add help to text area
     """
     command, key = self.sender().accessibleName().split('_')
     if command=='bold':
-      getattr(self, 'textEdit_'+key).insertPlainText('**TEXT**')
+      getattr(self, f'textEdit_{key}').insertPlainText('**TEXT**')
     elif command=='italic':
-      getattr(self, 'textEdit_'+key).insertPlainText('*TEXT*')
+      getattr(self, f'textEdit_{key}').insertPlainText('*TEXT*')
     elif command=='list-ul':
-      getattr(self, 'textEdit_'+key).insertPlainText('\n- item 1\n- item 2')
+      getattr(self, f'textEdit_{key}').insertPlainText('\n- item 1\n- item 2')
     elif command=='list-ol':
-      getattr(self, 'textEdit_'+key).insertPlainText('\n1. item 1\n1. item 2')
+      getattr(self, f'textEdit_{key}').insertPlainText('\n1. item 1\n1. item 2')
     elif command.startswith('heading'):
-      getattr(self, 'textEdit_'+key).insertPlainText('#'*int(command[-1])+' Heading\n')
+      getattr(self, f'textEdit_{key}').insertPlainText('#' * int(command[-1]) +
+                                                       ' Heading\n')
     else:
       print('**ERROR dialogForm: unknowCommand',command)
     return
 
   def textChanged(self) -> None:
     """
     Text changed in editor -> update the display on the right
     """
     key = self.sender().accessibleName()
-    getattr(self, 'textShow_'+key).setMarkdown( getattr(self, 'textEdit_'+key).toPlainText())
+    getattr(self, f'textShow_{key}').setMarkdown(
+        getattr(self, f'textEdit_{key}').toPlainText())
     return
 
   def delTag(self, _:str, tag:str) -> None:
     """
     Clicked button to delete tag
     """
     self.doc['-tags'].remove(tag)
@@ -379,18 +459,18 @@
     """
     Clicked to add tag. Since one needs to use indexChanged to allow the user to enter text, that delivers a int. To allow to differentiate
     between both comboboxes, they cannot be the same (both int), hence grades has to be textChanged
 
     Args:
       tag (str, int): index (otherTags) or text (grades)
     """
-    if isinstance(tag, str):  #text from grades
+    if isinstance(tag, str):#text from grades
       if tag!='':
         self.doc['-tags'] = [i for i in self.doc['-tags'] if i[0]!='_']
-        self.doc['-tags']+= ['_'+str(len(tag))]
+        self.doc['-tags'] += [f'_{len(tag)}']
         self.gradeChoices.setCurrentText('')
     elif tag<1:               #zero index from other-tags
       return
     else:
       tag = self.otherChoices.currentText()
       if tag not in self.doc['-tags']:
         self.doc['-tags'] += [tag]
```

## pasta_eln/dialogOntology.py

```diff
@@ -31,12 +31,12 @@
 
   #++ TODO ontologyCheck: all names must be different
   def save(self, btn:QPushButton) -> None:
     """ save selectedList to configuration and exit """
     if btn.text().endswith('Cancel'):
       self.reject()
     elif btn.text().endswith('Save'):
-      #TODO_P3 finish ontology dialog
+      #TODO_P2 finish ontology dialog
       self.accept()  #close
     else:
       print('dialogOntology: did not get a fitting btn ',btn.text())
     return
```

## pasta_eln/dialogProjectGroup.py

```diff
@@ -96,20 +96,20 @@
     print('project group press',btn.text() )
     if btn.text().endswith('Cancel'):
       self.reject()
     elif 'Save' in btn.text() and self.checkEntries():
       name = self.projectGroupName.text() if self.selectGroup.isHidden() else self.selectGroup.currentText()
       if btn.text().endswith('Save'):
         local = {'user':self.userNameL.text(), 'password':self.passwordL.text(), \
-                'database':self.databaseL.text(), 'path':self.pathL.text()}
+                  'database':self.databaseL.text(), 'path':self.pathL.text()}
         remote = {'user':self.userNameR.text(), 'password':self.passwordR.text(), \
-                'database':self.databaseR.text(), 'url':self.serverR.text()}
+                  'database':self.databaseR.text(), 'url':self.serverR.text()}
       elif btn.text().endswith('Save encrypted'):
-        credL = upIn(self.userNameL.text()+':'+self.passwordL.text())
-        credR = upIn(self.userNameR.text()+':'+self.passwordR.text())
+        credL = upIn(f'{self.userNameL.text()}:{self.passwordL.text()}')
+        credR = upIn(f'{self.userNameR.text()}:{self.passwordR.text()}')
         local = {'cred':credL, 'database':self.databaseL.text(), 'path':self.pathL.text()}
         remote = {'cred':credR, 'database':self.databaseR.text(), 'url':self.serverR.text()}
       newGroup = {'local':local, 'remote':remote}
       self.backend.configuration['projectGroups'][name] = newGroup
       self.backend.configuration['defaultProjectGroup'] = name
       with open(Path.home()/'.pastaELN.json', 'w', encoding='utf-8') as fConf:
         fConf.write(json.dumps(self.backend.configuration,indent=2))
```

## pasta_eln/dialogTableHeader.py

```diff
@@ -86,18 +86,20 @@
 
   def save(self, btn:IconButton) -> None:
     """ save selectedList to configuration and exit """
     if btn.text().endswith('Cancel'):
       self.reject()
     elif btn.text().endswith('Save'):
       specialFields = ['name', 'type', 'tags', 'user', 'date']
-      self.selectedList = ['-'+i if i in specialFields else i  for i in self.selectedList]
+      self.selectedList = [
+          f'-{i}' if i in specialFields else i for i in self.selectedList
+      ]
       self.comm.backend.db.initDocTypeViews(self.comm.backend.configuration['tableColumnsMax'],
                                             docTypeChange=self.docType, columnsChange=self.selectedList)
       restart()
-      # self.comm.changeTable.emit('','')
-      # self.accept()  #close
+        # self.comm.changeTable.emit('','')
+        # self.accept()  #close
     elif btn.text().endswith('Help'):
       showMessage(self, 'Help on individual entry', tableHeaderHelp)
     else:
       print('dialogTableHeader: did not get a fitting btn ',btn.text())
     return
```

## pasta_eln/gui.py

```diff
@@ -1,14 +1,14 @@
 """ Graphical user interface includes all widgets """
 import os, logging, webbrowser, json, sys
-from typing import Any
+from typing import Any, Optional
 from pathlib import Path
 from PySide6.QtWidgets import QMainWindow, QApplication, QFileDialog, QScrollArea # pylint: disable=no-name-in-module
 from PySide6.QtCore import Qt, Slot      # pylint: disable=no-name-in-module
-from PySide6.QtGui import QIcon, QPixmap  # pylint: disable=no-name-in-module
+from PySide6.QtGui import QIcon, QPixmap, QShortcut  # pylint: disable=no-name-in-module
 from qt_material import apply_stylesheet  #of https://github.com/UN-GCPDS/qt-material
 
 from pasta_eln import __version__
 from .backend import Backend
 from .communicate import Communicate
 from .widgetSidebar import Sidebar
 from .widgetBody import Body
@@ -24,16 +24,16 @@
 
 # Subclass QMainWindow to customize your application's main window
 class MainWindow(QMainWindow):
   """ Graphical user interface includes all widgets """
   def __init__(self) -> None:
     #global setting
     super().__init__()
-    venv = ' without venv' if sys.prefix == sys.base_prefix else ' in venv'
-    self.setWindowTitle("PASTA-ELN "+__version__+venv)
+    venv = ' without venv' if sys.prefix == sys.base_prefix and 'CONDA_PREFIX' not in os.environ else ' in venv'
+    self.setWindowTitle(f"PASTA-ELN {__version__}{venv}")
     self.setWindowState(Qt.WindowMaximized) # type: ignore
     resourcesDir = Path(__file__).parent/'Resources'
     self.setWindowIcon(QIcon(QPixmap(resourcesDir/'Icons'/'favicon64.png')))
     self.backend = Backend()
     self.comm = Communicate(self.backend)
     self.comm.formDoc.connect(self.formDoc)
 
@@ -46,22 +46,28 @@
     Action('&Exit',                 self.executeAction, projectMenu, self, name='exit')
 
     viewMenu = menu.addMenu("&Lists")
     if hasattr(self.backend, 'db'):
       for docType, docLabel in self.comm.backend.db.dataLabels.items():
         if docType[0]=='x' and docType[1]!='0':
           continue
-        Action(docLabel, self.viewMenu, viewMenu, self, \
-          "Ctrl+"+shortCuts[docType] if docType in shortCuts else None, docType)
+        Action(
+            docLabel,
+            self.viewMenu,
+            viewMenu,
+            self,
+            f"Ctrl+{shortCuts[docType]}" if docType in shortCuts else None,
+            docType,
+        )
         if docType=='x0':
           viewMenu.addSeparator()
       viewMenu.addSeparator()
       Action('&Tags',         self.viewMenu, viewMenu, self, 'Ctrl+T', '_tags_')
       Action('&Unidentified', self.viewMenu, viewMenu, self, 'Ctrl+U', name='-')
-      #TODO_P5 create list of unaccessible files: linked with accessible files
+        #TODO_P5 create list of unaccessible files: linked with accessible files
 
     systemMenu = menu.addMenu("&System")
     Action('&Project groups',        self.executeAction, systemMenu, self, name='projectGroups')
     changeProjectGroups = systemMenu.addMenu("&Change project group")
     if hasattr(self.backend, 'configuration'):                       #not case in fresh install
       for name in self.backend.configuration['projectGroups'].keys():
         Action(name, self.changeProjectGroup, changeProjectGroups, self, name=name)
@@ -69,24 +75,30 @@
     Action('&Questionaires',         self.executeAction, systemMenu, self, name='ontology')
     systemMenu.addSeparator()
     Action('&Test extraction from a file',   self.executeAction, systemMenu, self, name='extractorTest')
     Action('Test &selected item extraction', self.executeAction, systemMenu, self, name='extractorTest2',
            shortcut='F2')
     Action('Update &Extractor list',         self.executeAction, systemMenu, self, name='updateExtractors')
     systemMenu.addSeparator()
-    Action('&Verify database',       self.executeAction, systemMenu, self, name='verifyDB', shortcut='Ctrl+?')
-    Action('&Restart',               self.executeAction, systemMenu, self, name='restart', shortcut='F9')
     Action('&Configuration',         self.executeAction, systemMenu, self, name='configuration', shortcut='Ctrl+.')
 
     helpMenu = menu.addMenu("&Help")
     Action('&Website',               self.executeAction, helpMenu, self, name='website')
+    Action('&Verify database',       self.executeAction, helpMenu, self, name='verifyDB', shortcut='Ctrl+?')
     Action('Shortcuts',              self.executeAction, helpMenu, self, name='shortcuts')
     Action('Todo list',              self.executeAction, helpMenu, self, name='todo')
     helpMenu.addSeparator()
+    #shortcuts for advanced usage (user should not need)
+    QShortcut('F9', self, lambda : self.executeAction('restart'))
+    #TODO_P3 -> lambda and change buttons/actions: cleaner code
+    #  Action    ('Todo list',  self,  'todo',     helpMenu, 'Ctrl+H')
+    #  Action    ('&Tags',      self,  '_tags_', viewMenu, 'Ctrl+T', call=self.viewMenu)
+    #  TextButton('Add Filter', self,  'addFilter', headerL)
 
+    #TODO_P3 export to dataverse
     #GUI elements
     mainWidget, mainLayout = widgetAndLayout('H')
     self.setCentralWidget(mainWidget)      # Set the central widget of the Window
     body = Body(self.comm)        #body with information
     self.sidebar = Sidebar(self.comm)  #sidebar with buttons
     # sidebarScroll = QScrollArea()
     # sidebarScroll.setWidget(self.sidebar)
@@ -124,19 +136,20 @@
     act on user pressing an item in view
     """
     docType = self.sender().data()
     self.comm.changeTable.emit(docType, '')
     return
 
 
-  def executeAction(self) -> None:
+  def executeAction(self, menuName:Optional[str]=None) -> None:
     """
     action after clicking menu item
     """
-    menuName = self.sender().data()
+    if menuName is None or not menuName :
+      menuName = self.sender().data()
     if menuName=='configuration':
       dialog = Configuration(self.comm.backend)
       dialog.exec()
     elif menuName=='projectGroups':
       dialog = ProjectGroup(self.comm.backend)
       dialog.exec()
     elif menuName=='ontology':
@@ -167,15 +180,15 @@
       showMessage(self, 'Keyboard shortcuts', shortcuts)
     elif menuName=='restart':
       restart()
     elif menuName=='todo':
       try:
         from .tempStrings import todoString
         showMessage(self, 'List of items on todo list',todoString)
-      except:
+      except Exception:
         pass
     elif menuName=='export':
       if self.comm.projectID == '':
         showMessage(self, 'Error', 'You have to open a project to export', 'Warning')
         return
       fileName = QFileDialog.getSaveFileName(self,'Save data into .eln file',str(Path.home()),'*.eln')[0]
       status = exportELN(self.comm.backend, self.comm.projectID, fileName)
@@ -183,15 +196,18 @@
     elif menuName=='import':
       fileName = QFileDialog.getOpenFileName(self,'Load data from .eln file',str(Path.home()),'*.eln')[0]
       status = importELN(self.comm.backend, fileName)
       showMessage(self, 'Finished', status, 'Information')
       self.comm.changeSidebar.emit('redraw')
       self.comm.changeTable.emit('x0','')
     else:
-      showMessage(self, 'ERROR','menu not implemented yet: '+menuName, icon='Warning')
+      showMessage(self,
+                  'ERROR',
+                  f'menu not implemented yet: {menuName}',
+                  icon='Warning')
     return
 
 
   def changeProjectGroup(self) -> None:
     """
     change default project group in configuration file and restart
     """
@@ -219,15 +235,15 @@
   logging.info('Start PASTA GUI')
   # remainder
   app = QApplication()
   window = MainWindow()
   logging.getLogger().setLevel(getattr(logging, window.backend.configuration['GUI']['loggingLevel']))
   theme = window.backend.configuration['GUI']['theme']
   if theme!='none':
-    apply_stylesheet(app, theme=theme+'.xml')
+    apply_stylesheet(app, theme=f'{theme}.xml')
   # qtawesome and matplot cannot coexist
   import qtawesome as qta
   if not isinstance(qta.icon('fa5s.times'), QIcon):
     logging.error('qtawesome: could not load. Likely matplotlib is included and can not coexist.')
     print('qtawesome: could not load. Likely matplotlib is included and can not coexist.')
   # end test coexistance
   window.show()
```

## pasta_eln/handleDictionaries.py

```diff
@@ -16,29 +16,29 @@
      tableFormat (dict): tableFormat branch from .pastaELN.json
 
   Returns:
      dict: dictionary
   """
   dataDict = {}
   hierarchyDict = {}
-  for key in ontology.keys():
+  for key in ontology:
     if key in ['_id', '_rev']:
       continue
     label = None
     if key in tableFormat and '-label-' in tableFormat[key]:  #use label from tableFormat
       label = tableFormat[key]['-label-']
     elif key[0]=='x':                                         #use default structural elements
       label = ['Projects','Tasks','Subtasks','Subsubtasks'][int(key[1])]
     else:                                                     #default system  sample->Samples
       label = key[0].upper()+key[1:]+'s'
     if key[0]=='x':
       hierarchyDict[key] = label
     else:
       dataDict[key] = label
-  dataDict.update(hierarchyDict)  #join hierarchy and datalabels because reason for separation unclear
+  dataDict |= hierarchyDict
   return dataDict
 
 
 def fillDocBeforeCreate(data:dict[str,Any], docType:list[str]) -> dict[str,Any]:
   """ Fill the data before submission to database with common data
   - type, project, childs
   - separate comment into tags, fields
@@ -98,17 +98,17 @@
       data[aList[1]] = aList[2]
   data['comment'] = re.sub(r':[\S]+:[\S]+:','',data['comment'])  #remove :field:data: information
   if isinstance(data['-tags'], str):
     data['-tags'] = data['-tags'].split(' ')
   data['-tags'] = [i.strip()[1:] if i.strip()[0]=='#' else i.strip() for i in data['-tags']]
   data['-tags'] = list(set(data['-tags']))  #ensure only one is inside
   #other cleaning
-  if 'links' in data and isinstance(data['links'], list):
-    if len(data['links'])==0 or (len(data['links'])==1 and data['links'][0]==''):
-      del data['links']
+  if ('links' in data and isinstance(data['links'], list)) and \
+     (len(data['links'])==0 or (len(data['links'])==1 and data['links'][0]=='')):
+    del data['links']
   #individual verification of documents
   if data['-type'][0]=='sample':
     if 'qrCode' not in data:
       data['qrCode']=[]
     if isinstance(data['qrCode'], str):
       data['qrCode'] = data['qrCode'].split(' ')
   if data['-type'][0] == 'measurement':
@@ -142,29 +142,29 @@
   ignoreKeys = ['-client','_rev']
   outString = ''
   dict2Copy = dict(dict2)
   for key,value in dict1.items():
     if key in ignoreKeys:
       continue
     if key not in dict2Copy:
-      outString += 'key not in dictionary 2: '+key+'\n'
+      outString += f'key not in dictionary 2: {key}' + '\n'
       continue
     if value != dict2Copy[key]:
       if key=='-branch':
         if len(value) != len(dict2Copy[key]):
           outString += 'branches have different lengths\n   '+str(value)+'\n   '+str(dict2Copy[key])+'\n'
         else:
           for idx,_ in enumerate(value):
             branch1 = value[idx]
             branch2 = dict2Copy['-branch'][idx]
             del branch1['show']
             del branch2['show']
             if branch1!=branch2:
               outString += 'branches differ\n   '+str(value)+'\n   '+str(dict2Copy[key])+'\n'
       else:
-        outString += 'values differ for key: '+key+'\n   '+str(value)+'\n   '+str(dict2Copy[key])+'\n'
+        outString += (f'values differ for key: {key}\n   {str(value)}\n   {str(dict2Copy[key])}\n')
     del dict2Copy[key]
-  for key in dict2Copy.keys():
+  for key in dict2Copy:
     if key in ignoreKeys:
       continue
-    outString += 'key not in dictionary 1: '+key+'\n'
+    outString += f'key not in dictionary 1: {key}\n'
   return outString
```

## pasta_eln/inputOutput.py

```diff
@@ -54,30 +54,27 @@
   '''
   elnName = ''
   elnVersion = ''
   with ZipFile(elnFileName, 'r', compression=ZIP_DEFLATED) as elnFile:
     files = elnFile.namelist()
     logging.info('All files '+', '.join(files))
     dirName=Path(files[0]).parts[0]
-    if dirName+'/ro-crate-metadata.json' not in files:
+    if f'{dirName}/ro-crate-metadata.json' not in files:
       print('**ERROR: ro-crate does not exist in folder. EXIT')
       return '**ERROR: ro-crate does not exist in folder. EXIT'
-    graph = json.loads(elnFile.read(dirName+'/ro-crate-metadata.json'))["@graph"] #list
+    graph = json.loads(elnFile.read(f'{dirName}/ro-crate-metadata.json'))["@graph"]
     #find information from master node
     rocrateNode = [i for i in graph if i["@id"]=="ro-crate-metadata.json"][0]
     if 'sdPublisher' in rocrateNode:
       elnName     = rocrateNode['sdPublisher']['name']
-    if 'version' in rocrateNode:
-      elnVersion  = rocrateNode['version']
-    else:
-      elnVersion  = ''
-    logging.info('Import '+elnName+' '+elnVersion)
+    elnVersion = rocrateNode['version'] if 'version' in rocrateNode else ''
+    logging.info('Import %s %s', elnName, elnVersion)
     if elnName=='eLabFTW':
       json2pasta.update(elabFTW)
-    logging.info('ELN and translator:'+elnName+' '+str(json2pasta))
+    logging.info('ELN and translator: %s %s', elnName, str(json2pasta))
     mainNode    = [i for i in graph if i["@id"]=="./"][0]
 
     ################
     # subfunctions #
     ################
     def json2pastaFunction(inputData:dict[str,Any]) -> tuple[dict[str,Any], str, list[Any], str]:
       """
@@ -98,16 +95,16 @@
       dataType = inputData['@type']
       for key, value in inputData.items():
         if key in ['@id','@type','hasPart','author','contentSize', 'sha256']:
           continue
         if key in json2pasta:
           output[json2pasta[key]] = value
         else:
-          print('**Warning: could not translate: '+key+'   from eln:'+elnName)
-          output['imported_'+key] = value
+          print(f'**Warning: could not translate: {key}   from eln:{elnName}')
+          output[f'imported_{key}'] = value
       return output, elnID, children, dataType
 
     def processPart(part:dict[str,str]) -> int:
       """
       recursive function call to process this node
 
       Args:
@@ -142,28 +139,28 @@
         with elnFile.open(supplementalInfo.as_posix()) as fIn:
           jsonContent = json.loads( fIn.read() )
           if isinstance(jsonContent, list):
             jsonContent = jsonContent[0]
           if elnName == 'PASTA ELN':
             doc.update( jsonContent )
           else:
-            doc['from '+elnName] = jsonContent
+            doc[f'from {elnName}'] = jsonContent
       elif re.match(r'^metadata_.-\w{32}\.json$', elnID.split('/')[-1]) is None:
         if elnName == 'PASTA ELN':
           if elnID.endswith('datastructure.json'):
             return 0
           metadataPath = Path(dirName)/(elnID.replace('.','_')+'_metadata.json')
           with elnFile.open(metadataPath.as_posix()) as fIn:
             doc.update( json.loads( fIn.read() ) )
         elif elnName == 'eLabFTW' and elnID.endswith('export-elabftw.json'):
           return 0
         else:
           print('**ERROR got a file which I do not understand ',elnID)
           target = open(fullPath, "wb")
-          source = elnFile.open(dirName+'/'+elnID)
+          source = elnFile.open(f'{dirName}/{elnID}')
           with source, target:  #extract one file to its target directly
             shutil.copyfileobj(source, target)
       else:
         metadataPath = Path(dirName)/elnID
         with elnFile.open(metadataPath.as_posix()) as fIn:
           doc.update( json.loads( fIn.read() ) )
       # save
@@ -174,19 +171,21 @@
           with open(fullPath/'.id_pastaELN.json', 'w', encoding='utf-8') as fOut:
             fOut.write(json.dumps(doc))
         elif re.match(r'^metadata_.-\w{32}\.json$', elnID.split('/')[-1]) is None:
           if not fullPath.parent.exists():
             fullPath.parent.mkdir()
           target = open(fullPath, "wb")
           try:
-            source = elnFile.open(dirName+'/'+part['@id'])
+            source = elnFile.open(f'{dirName}/' + part['@id'])
             with source, target:  #extract one file to its target directly
               shutil.copyfileobj(source, target)
-          except:
-            logging.warning('--------- could not read file from zip: '+dirName+'/'+part['@id'])
+          except Exception:
+            logging.warning(
+                f'--------- could not read file from zip: {dirName}/' +
+                part['@id'])
       else:  # OTHER VENDORS
         if dataType.lower()=='dataset':
           docType = 'x'+str(len(elnID.split('/')) - 1)
           backend.cwd = backend.basePath / Path(elnID).parent
         else:
           docType = '-'
         if docType=='x0':
@@ -230,15 +229,15 @@
     ######################
     #main function
     #iteratively go through list
     addedDocuments = 0
     for part in mainNode['hasPart']:
       if not part['@id'].endswith('ro-crate-metadata.json'):
         addedDocuments += processPart(part)
-  return 'Success: imported '+str(addedDocuments)+' documents from file '+elnFileName+' from ELN '+elnName+' '+elnVersion
+  return f'Success: imported {str(addedDocuments)} documents from file {elnFileName} from ELN {elnName} {elnVersion}'
 
 
 
 ##########################################
 ###               EXPORT               ###
 ##########################################
 def exportELN(backend:Backend, projectID:str, fileName:str='') -> str:
@@ -253,15 +252,15 @@
   Returns:
     str: report of exportation
   """
   # define initial information
   keysInSupplemental:set[str] = set()
   docProject = backend.db.getDoc(projectID)
   dirNameProject = docProject['-branch'][0]['path']
-  fileName = dirNameProject+'.eln' if fileName=='' else fileName
+  fileName = fileName or f'{dirNameProject}.eln'
 
   def iterateTree(nodeHier:Node, graph:list[dict[str,Any]]) -> str:
     """
     Recursive function to translate the hierarchical node into a tree-node
 
     Args:
       nodeHier (Anytree.Node): anytree node
@@ -273,43 +272,43 @@
     # separate into main and supplemental information
     doc = backend.db.getDoc(nodeHier.id)
     path = doc['-branch'][0]['path']
     fileAttached = True
     if path is None or path.startswith('https:'):
       parentID = doc['-branch'][0]['stack'][-1]
       path = backend.db.getDoc(parentID)['-branch'][0]['path']
-      path += '/metadata_'+nodeHier.id+'.json'
+      path += f'/metadata_{nodeHier.id}.json'
       fileAttached = False
     docMain= {'@id': path}
     docSupp = {}
     for key, value in doc.items():
       if key in pasta2json and pasta2json[key] is not None:
         docMain[pasta2json[key]] = value
       else:
         docSupp[key] = value
     # remove personal data
     docMain['author'] = '_'
     del docSupp['-user']
     # get path to metadata file
     if fileAttached:
       if nodeHier.id[0]=='x':
-        pathMetadata = path+'/metadata.json'
+        pathMetadata = f'{path}/metadata.json'
       else:
         pathArray = list(Path(path).as_posix().split('/'))
         pathArray[-1] = pathArray[-1].replace('.','_')+'_metadata.json'
         pathMetadata = '/'.join(pathArray)
     # add structural information: dataset, hasPart
     if nodeHier.id[0]=='x':
       hasPart = []
       for child in nodeHier.children:
         res = iterateTree(child, graph)
         if res is not None:
           hasPart.append( res )
       docMain['hasPart'] = [{'@id':pathMetadata}]
-      if len(hasPart)>0:
+      if hasPart:
         docMain['hasPart'] += [{'@id':i} for i in hasPart]
       docMain['@type'] = 'dataset'
     else:
       docMain['@type'] = 'data'
     # prepare the supplemental
     nonlocal keysInSupplemental
     keysInSupplemental = keysInSupplemental.union(docSupp)
@@ -318,99 +317,121 @@
       roCrateMetadata = {'description':'JSON export',
                          'contentType':'application/json',
                          'contentSize':str(len(zipContent)),
                          'sha256':hashlib.sha256(zipContent.encode()).hexdigest(),
                          '@id':pathMetadata,
                          docMain['@type']:'data'}
       graph.append(roCrateMetadata)
-      elnFile.writestr(dirNameProject+'/'+pathMetadata, zipContent)
+      elnFile.writestr(f'{dirNameProject}/{pathMetadata}', zipContent)
     else:
       if (backend.basePath/path).exists():
         with open(backend.basePath/path, 'rb') as fIn:
           fileContent = fIn.read()
           docMain['contentSize'] = str(len(fileContent))
           docMain['sha256']      = hashlib.sha256(fileContent).hexdigest()
       else:
         docMain['contentSize'] = str(len(zipContent))
         docMain['sha256']      = hashlib.sha256(zipContent.encode()).hexdigest()
-      elnFile.writestr(dirNameProject+'/'+path, zipContent)
+      elnFile.writestr(f'{dirNameProject}/{path}', zipContent)
     # write data file
     graph.append(docMain)
     return docMain['@id']
+
   #
   #
   # == MAIN FUNCTION ==
-  logging.info('Create eln file '+fileName)
+  logging.info('Create eln file %s',fileName)
   with ZipFile(fileName, 'w', compression=ZIP_DEFLATED) as elnFile:
     # ------- Create main graph -------------------
     listHier = backend.db.getHierarchy(projectID, allItems=False)
     graph:list[dict[str,Any]] = []
     iterateTree(listHier, graph)  # create json object from anytree
 
     # ------------------- create ro-crate-metadata.json header -----------------------
     index:dict[str,Any] = {}
     index['@context']= 'https://w3id.org/ro/crate/1.1/context'
     # master node ro-crate-metadata.json
     graphMaster:list[dict[str,Any]] = []
-    masterNodeInfo  = {\
-      '@id':'ro-crate-metadata.json',\
-      '@type':'CreativeWork',\
-      'about': {'@id': './'},\
-      'conformsTo': {'@id': 'https://w3id.org/ro/crate/1.1'},\
-      'schemaVersion': 'v1.0',\
-      'dateCreated': datetime.now().isoformat(),\
-      'sdPublisher': {'@type':'Organization', 'name': 'PASTA ELN',\
-        'logo': 'https://raw.githubusercontent.com/PASTA-ELN/desktop/main/pasta.png',\
-        'slogan': 'The favorite ELN for experimental scientists',\
-        'url': 'https://github.com/PASTA-ELN/',\
-        'description':'Version '+__version__},\
-      'version': '1.0'}
+    masterNodeInfo = {
+        '@id': 'ro-crate-metadata.json',
+        '@type': 'CreativeWork',
+        'about': {
+            '@id': './'
+        },
+        'conformsTo': {
+            '@id': 'https://w3id.org/ro/crate/1.1'
+        },
+        'schemaVersion': 'v1.0',
+        'dateCreated': datetime.now().isoformat(),
+        'sdPublisher': {
+            '@type': 'Organization',
+            'name': 'PASTA ELN',
+            'logo':
+            'https://raw.githubusercontent.com/PASTA-ELN/desktop/main/pasta.png',
+            'slogan': 'The favorite ELN for experimental scientists',
+            'url': 'https://github.com/PASTA-ELN/',
+            'description': f'Version {__version__}',
+        },
+        'version': '1.0',
+    }
     graphMaster.append(masterNodeInfo)
-    dataStructureInfo  = {\
-      '@id':dirNameProject+'/'+dirNameProject+'/datastructure.json',\
-      '@type':'DigitalDocument'}
+    dataStructureInfo = {
+        '@id': f'{dirNameProject}/{dirNameProject}/datastructure.json',
+        '@type': 'DigitalDocument',
+    }
     graphMaster.append(dataStructureInfo)
     authors = backend.configuration['authors']
-    masterNodeRoot  = {'@id':'./', '@type':['Dataset'],
-                       'hasPart': [{'@id':dirNameProject},
-                                   {'@id':dirNameProject+'/ro-crate-metadata.json'},
-                                   {'@id':dirNameProject+'/'+dirNameProject+'/datastructure.json'}],
-                        # default items mwo-ontology
-                       'context': [{'mwo': 'http://purls.helmholtz-metadaten.de/mwo'},{'nfdicore': 'https://nfdi.fiz-karlsruhe.de/ontology'}],
-                       'type': 'mwo:ExperimentalWorkflow',
-                       'license': 'CC BY 4.0',
-                       'format':  [{'fileExtension': '.json'}],
-                        # publisher information
-                       'authors': [
-                         {'firstName':authors[0]['first'], 'surname':authors[0]['last'], 'title':authors[0]['title'],
-                          'emailAddress':authors[0]['email'], 'ORCID': authors[0]['orcid'],
-                          'affiliation': [{'organization': authors[0]['organizations'][0]['organization'],
-                                           'RORID':        authors[0]['organizations'][0]['rorid']}] }
-                       ],
-                       'datePublished': datetime.now().isoformat()
-                      }
-    elnFile.writestr(dirNameProject+'/'+dirNameProject+'/datastructure.json',
-                     json.dumps(backend.db.getDoc('-ontology-')))
+    masterNodeRoot = {
+        '@id':
+        './',
+        '@type': ['Dataset'],
+        'hasPart': [
+            {'@id': dirNameProject},
+            {'@id': f'{dirNameProject}/ro-crate-metadata.json'},
+            {'@id': f'{dirNameProject}/{dirNameProject}/datastructure.json'}
+        ],
+        'context': [
+            {'mwo': 'http://purls.helmholtz-metadaten.de/mwo'},
+            {'nfdicore': 'https://nfdi.fiz-karlsruhe.de/ontology'},
+        ],
+        'type':'mwo:ExperimentalWorkflow',
+        'license':'CC BY 4.0',
+        'format': [{'fileExtension': '.json'}],
+        'authors': [{
+            'firstName': authors[0]['first'],
+            'surname': authors[0]['last'],
+            'title': authors[0]['title'],
+            'emailAddress': authors[0]['email'],
+            'ORCID': authors[0]['orcid'],
+            'affiliation': [{
+                'organization': authors[0]['organizations'][0]['organization'],
+                'RORID': authors[0]['organizations'][0]['rorid'],
+            }],
+        }],
+        'datePublished':datetime.now().isoformat(),
+    }
+    elnFile.writestr(f'{dirNameProject}/{dirNameProject}/datastructure.json', json.dumps(backend.db.getDoc('-ontology-')))
     graphMaster.append(masterNodeRoot)
 
     # ------------------ copy data-files --------------------------
     # datafiles are already in the graph-graph: only copy and no addition to graph
     for path, _, files in os.walk(backend.basePath/dirNameProject):
       if '/.git' in path:  #if use datalad
         continue
       relPath = os.path.relpath(path, backend.basePath) #path of the folder
-      for iFile in files:                               #iterate through all files in folder
+      for iFile in files:                         #iterate through all files in folder
         if iFile.startswith('.git') or iFile=='.id_pastaELN.json':
           continue
-        elnFile.write(path+'/'+iFile, dirNameProject+'/'+relPath+'/'+iFile)   #zip file
+        elnFile.write(f'{path}/{iFile}', f'{dirNameProject}/{relPath}/{iFile}')
 
     #finalize file
     index['@graph'] = graphMaster+graph
-    elnFile.writestr(dirNameProject+'/'+'ro-crate-metadata.json', json.dumps(index, indent=2))
-    # temporary json output
-    with open(fileName[:-3]+'json','w', encoding='utf-8') as fOut:
-      fOut.write( json.dumps(index, indent=2) )
+    elnFile.writestr(f'{dirNameProject}/ro-crate-metadata.json',
+                     json.dumps(index, indent=2))
+      # # temporary json output
+      # with open(fileName[:-3]+'json','w', encoding='utf-8') as fOut:
+      #   fOut.write( json.dumps(index, indent=2) )
   keysInSupplemental = {i for i in keysInSupplemental if i not in pasta2json}
   logging.info('Keys in supplemental information'+', '.join(keysInSupplemental))
-  return 'Success: exported '+str(len(graph))+' graph-nodes into file '+fileName
+  return f'Success: exported {len(graph)} graph-nodes into file {fileName}'
 
 # SimStack (matsci.org/c/simstack), PMD Meeting september KIT
```

## pasta_eln/installationTools.py

```diff
@@ -18,48 +18,48 @@
     string: os + pythonEnvironment
   '''
   operatingSys = platform.system()
   # Get base/real prefix, or sys.prefix if there is none
   get_base_prefix_compat = getattr(sys, 'base_prefix', None) or getattr(sys, 'real_prefix', None) or sys.prefix
   in_virtualenv = get_base_prefix_compat != sys.prefix
   environment = sys.prefix if in_virtualenv else '_system_'
-  return operatingSys+' '+environment
+  return f'{operatingSys} {environment}'
 
 
 def createDefaultConfiguration(user:str, password:str, pathPasta:Optional[Path]=None) -> dict[str,Any]:
   '''
   Check configuration file .pastaELN.json for consistencies
 
   Args:
     user (str): user name (for windows)
     password (str): password (for windows)
     pathPasta (Path): place to store pasta data
 
   Returns:
     dict: dictionary of configuration
   '''
-  if user == '':
+  if not user:
     user = input('Enter user name: ')
-  if password == '':
+  if not password:
     password = input('Enter password: ')
   if pathPasta is None:
     if platform.system()=='Windows':
       pathPasta = Path.home()/'Documents'/'PASTA_ELN'
     else:
       pathPasta = Path.home()/'PASTA_ELN'
-  conf:dict[str,Any] = {}
-  conf['defaultProjectGroup']     = 'research'
-  conf['projectGroups']       = {'research':{\
-                          'local':{'user':user, 'password':password, 'database':'research',
-                                   'path':str(pathPasta)},
-                          'remote':{}  }}
-  conf['version']     = 2
+  conf: dict[str, Any] = {
+      'defaultProjectGroup': 'research',
+      'projectGroups': {
+          'research': {
+              'local': {'user': user, 'password': password, 'database': 'research', 'path': str(pathPasta)},
+              'remote': {},
+          }}, 'version': 2}
   try:
     conf['userID']      = os.getlogin()
-  except:   #github action
+  except Exception:   #github action
     conf['userID']      = 'github_user'
   #create pastaDir if it does not exist
   if not pathPasta.exists():
     pathPasta.mkdir()
   return conf
 
 
@@ -76,15 +76,15 @@
   '''
   import win32con, win32event, win32process
   from win32com.shell.shell import ShellExecuteEx
   from win32com.shell import shellcon
   procInfo = ShellExecuteEx(nShow=win32con.SW_SHOWNORMAL,
                             fMask=shellcon.SEE_MASK_NOCLOSEPROCESS,
                             lpVerb='runas',  # causes UAC elevation prompt.
-                            lpFile= '"'+cmdLine[0]+'"',
+                            lpFile= f'"{cmdLine[0]}"',
                             lpParameters=" ".join(cmdLine[1:]))
   procHandle = procInfo['hProcess']
   _ = win32event.WaitForSingleObject(procHandle, win32event.INFINITE)
   _   = win32process.GetExitCodeProcess(procHandle)
   return
 
 
@@ -100,15 +100,15 @@
   '''
   if command == 'test':
     try:
       with urllib.request.urlopen('http://127.0.0.1:5984') as package:
         contents = package.read()
         if json.loads(contents)['couchdb'] == 'Welcome':
           return ''
-    except:
+    except Exception:
       pass
     return '**ERROR**'
 
   elif command == 'install':
     if platform.system()=='Linux':
       return '**ERROR should not be called'
     elif platform.system()=='Windows':
@@ -117,24 +117,24 @@
       path = Path.home()/'Downloads'/'apache-couchdb-3.1.1.msi'
       logging.info('Start download of couchdb')
       _, _ = urllib.request.urlretrieve(url, path)
       ## Old version with installer
       # cmd = ['cmd.exe','/K ',str(resultFilePath)]
       # _ = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, check=True)
       ## New version without questions
-      password = ''.join(random.choice(string.ascii_letters) for i in range(12))
-      logging.info('PASSWORD: '+password)
+      password = ''.join(random.choice(string.ascii_letters) for _ in range(12))
+      logging.info('PASSWORD: %s',password)
       pathS = str(path).replace('\\','\\\\')
       cmd = ['msiexec','/i',pathS,'/quiet','COOKIEVALUE=abcdefghijklmo','INSTALLSERVICE=1','ADMINUSER=admin',\
-             'ADMINPASSWORD='+password,'/norestart','/l*','log.txt']
+             f'ADMINPASSWORD={password}','/norestart','/l*','log.txt']
       logging.info('COMMAND: '+' '.join(cmd))
       runAsAdminWindows(cmd)
       logging.info('CouchDB ending')
-      return 'Installed couchDB with password |'+password+'|'
-    return '**ERROR: Unknown operating system '+platform.system()
+      return f'Installed couchDB with password |{password}|'
+    return f'**ERROR: Unknown operating system {platform.system()}'
   return '**ERROR: Unknown command'
 
 
 def couchdbUserPassword(username:str, password:str) -> bool:
   '''
   test if username and password are correct
 
@@ -144,15 +144,15 @@
 
   Returns:
     bool: True if success, False if failure
   '''
   try:
     _ = CouchDB(username, password, url='http://127.0.0.1:5984', connect=True)
     return True
-  except:
+  except Exception:
     return False
 
 
 def installLinuxRoot(couchDBExists:bool, pathPasta:Path=Path(''), password:str='') -> str:
   '''
   Install all packages in linux using the root-password
 
@@ -164,66 +164,67 @@
   Returns:
     string: ''=success, else error messages
   '''
   logging.info('InstallLinuxRoot starting ...')
   bashCommand = []
   password = ''
   if not couchDBExists:
-    if password=='':
-      password = ''.join(random.choice(string.ascii_letters) for i in range(12))
-      logging.info('PASSWORD: '+password)
+    if not password:
+      password = ''.join(random.choice(string.ascii_letters) for _ in range(12))
+      logging.info('PASSWORD: %s',password)
     #create or adopt .pastaELN.json
     path = Path.home()/'.pastaELN.json'
     if path.exists():
       with open(path,'r', encoding='utf-8') as fConf:
         conf = json.load(fConf)
       logging.info('.pastaELN.json exists, do not change it')
     else:
       conf = createDefaultConfiguration('admin', password, pathPasta)
       with open(path,'w', encoding='utf-8') as fConf:
         fConf.write(json.dumps(conf, indent=2) )
-    bashCommand += [
+    bashCommand = [
       'sudo snap install couchdb',
-      'sudo snap set couchdb admin='+password,
+      f'sudo snap set couchdb admin={password}',
       'sudo snap start couchdb',
       'sudo snap connect couchdb:mount-observe',
       'sudo snap connect couchdb:process-control',
       'sleep 5',
-      'curl -X PUT http://admin:'+password+'@127.0.0.1:5984/_users',
-      'curl -X PUT http://admin:'+password+'@127.0.0.1:5984/_replicator',
-      'curl -X PUT http://admin:'+password+'@127.0.0.1:5984/_global_changes',
-      'curl -X PUT http://admin:'+password+'@127.0.0.1:5984/_node/_local/_config/couch_httpd_auth/timeout/ -d \'"60000"\'',
+      f'curl -X PUT http://admin:{password}@127.0.0.1:5984/_users',
+      f'curl -X PUT http://admin:{password}@127.0.0.1:5984/_replicator',
+      f'curl -X PUT http://admin:{password}@127.0.0.1:5984/_global_changes',
+      f'curl -X PUT http://admin:{password}@127.0.0.1:5984/_node/_local/_config/couch_httpd_auth/timeout/ -d \'"60000"\'',
       'sleep 10',
       'echo DONE-Press-Key',
       'read']  #TODO_P5 if successful in Aug2023: remove "echo....read"
   #Try all terminals
   scriptFile = Path.home()/'pastaELN_Install.sh'
   with open(scriptFile,'w', encoding='utf-8') as shell:
     shell.write('\n'.join(bashCommand))
   os.chmod(scriptFile, 0o0777)
   terminals = ['xterm -e bash -c ','qterminal -e bash -c ','gnome-terminal -- ']
-  logging.info('Command: '+str(bashCommand))
-  resultString = 'Password: '+password
+  logging.info('Command: %s',str(bashCommand))
+  resultString = f'Password: {password}'
   for term in terminals:
     # _ = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, check=True)
     res = os.system(term+scriptFile.as_posix())
-    logging.info('Linux install terminal '+term+' '+str(res) )
+    logging.info('Linux install terminal %s  %s',term,str(res))
     if res == 0:
       break
     if terminals.index(term)==len(terminals)-1:
       logging.error('**ERROR: Last terminal failed')
       res = os.system('\n'.join(bashCommand[:-2]))
-      logging.info('Finished using straight Bash command result='+str(res))
+      logging.info('Finished using straight Bash command result=%s',str(res))
       resultString = '**ERROR: Last terminal failed'
   success = 'CouchDB works' if couchdbUserPassword('admin',password) else 'CouchDB FAILED'
-  logging.info('InstallLinuxRoot ending. '+success)
+  logging.info('InstallLinuxRoot ending. %s',success)
   return resultString
 
 
 def configuration(command:str='test', user:str='', password:str='', pathPasta:Path=Path('')) -> str:
+  # sourcery skip: hoist-similar-statement-from-if, merge-duplicate-blocks, merge-else-if-into-elif, remove-redundant-if, swap-if-else-branches, swap-nested-ifs
   '''
   #TODO_P4 change to string-output
   Check configuration file .pastaELN.json for consistencies
 
   Args:
     command (str): 'test' or 'repair'
     user (str): user name (for windows)
@@ -234,15 +235,15 @@
     string: ''=success, else error messages
   '''
   logging.info('Configuration starting ...')
   output = ''
   try:
     with open(Path.home()/'.pastaELN.json','r', encoding='utf-8') as fConf:
       conf = json.load(fConf)
-  except:
+  except Exception:
     output += '**ERROR configuration file does not exist\n'
     conf = {}
     if command == 'repair':
       conf = createDefaultConfiguration(user, password, pathPasta)
   logging.info(json.dumps(conf, indent=2))
 
   if 'version' not in conf or conf['version']!=2:
@@ -311,15 +312,15 @@
     "loggingLevel": "INFO",
     "tableColumns": {}}
   for key, value in guiItems.items():
     if 'GUI' in conf and key not in conf['GUI']:
       if command == 'repair':
         conf['GUI'][key] = value
       else:
-        output += '**ERROR: key: '+key+' not in GUI configuration\n'
+        output += f'**ERROR: key: {key} not in GUI configuration\n'
   # Authors
   if 'authors' not in conf:
     if command == 'repair':
       conf['authors'] = [    {"first":"", "last":"", "title":"", "email":"", "orcid":"","organizations":[{"organization":"", "rorid":""}]}]
     else:
       output += '**ERROR: No authors in config file\n'
   if command == 'repair':
@@ -327,42 +328,38 @@
       f.write(json.dumps(conf,indent=2))
   logging.info('Configuration ending')
   return output
 
 
 
 def ontology(command:str='test') -> str:
+  # sourcery skip: switch
   '''
   Check configuration file .pastaELN.json for consistencies
 
   Args:
     command (string): 'test' or 'install'
 
   Returns:
     string: ''=success, else error messages
   '''
-  output = ''
   backend = Backend()
-
   if command == 'test':
     if not hasattr(backend.db, 'db'):
       return '**ERROR: couchDB not initialized'
-    output += 'database name:'+backend.db.db.database_name+'\n'
-    designDocuments = backend.db.db.design_documents()
-    output += 'Design documents'+'\n'
-    for item in designDocuments:
+    output = 'database name: {backend.db.db.database_name}\nDesign documents\n'
+    for item in backend.db.db.design_documents():
       numViews = len(item['doc']['views']) if 'views' in item['doc'] else 0
       output += '  '+item['id']+'   Num. of views:'+str(numViews)+'\n'
     try:
       _ = backend.db.getDoc('-ontology-')
       output += 'Ontology exists on server'+'\n'
-    except:
+    except Exception:
       output += '**ERROR: Ontology does NOT exist on server'+'\n'
     return output
-
   elif command == 'install':
     logging.info('ontology starting ...')
     doc = defaultOntology
     logging.info(str(doc))
     logging.info('ontology ending ...')
     # _ = backend.db.create_document(doc)
     return ''
@@ -513,38 +510,37 @@
   if platform.system()=='Linux':
     content ='[Desktop Entry]\nName=PASTA ELN\nComment=PASTA electronic labnotebook\n'
     if sys.prefix==sys.base_prefix:   #normal installation into user-space
       content+='Exec=pastaELN\n'
     else:                             #installation in a virtual environment
       logging.info('In virtual environment, create an alias')
       with open(Path.home()/'.bashrc','a', encoding='utf-8') as fOut:
-        alias = "alias pastaELN='"+sys.prefix+"/bin/python3 -m pasta_eln.gui'"
+        alias = f"alias pastaELN='{sys.prefix}/bin/python3 -m pasta_eln.gui'"
         logging.info(alias)
-        fOut.write(alias+'\n')
-      content+='Exec='+sys.prefix+'/bin/python3 -m pasta_eln.gui\n'
+        fOut.write(f'{alias}\n')
+      content += f'Exec={sys.prefix}/bin/python3 -m pasta_eln.gui\n'
     content+='Icon='+ (Path(__file__).parent/'Resources'/'Icons'/'favicon64.png').as_posix() + '\n'
-    content+='Terminal=false\nType=Application\nCategories=Utility;Application;\n'
+    content+='Terminal=false\nType=Application\nCategories=Science;Application;\n'
     try:
       linkString = (Path.home()/'Desktop'/'pastaELN.desktop').as_posix()
       with open(linkString,'w', encoding='utf-8') as fOut:
         fOut.write(content)
-        os.system('gio set '+linkString+' metadata::trusted true') #for ubuntu systems
+        os.system(f'gio set {linkString} metadata::trusted true') #for ubuntu systems
         os.chmod(Path.home()/'Desktop'/'pastaELN.desktop', 0o775)
-    except:
+    except Exception:
       pass
     try:
       with open(Path.home()/'.local'/'share'/'applications'/'pastaELN.desktop','w', encoding='utf-8') as fOut:
         fOut.write(content)
         os.chmod(Path.home()/'.local'/'share'/'applications'/'pastaELN.desktop', 0o777)
-    except:
+    except Exception:
       pass
   elif platform.system()=='Windows':
     import winshell
     from win32com.client import Dispatch
-
     shell = Dispatch('WScript.Shell')
     shortcut = shell.CreateShortCut( os.path.join(winshell.desktop(), "pastaELN.lnk") )
     shortcut.Targetpath = r"pastaELN"
     shortcut.WorkingDirectory = str(Path.home())
     shortcut.IconLocation = str(Path(__file__).parent/'Resources'/'Icons'/'favicon64.ico')
     shortcut.save()
   logging.info('Create shortcut end')
@@ -569,19 +565,19 @@
   existsCouchDB = res==''
   print('chouchDB     :', res)
   res = configuration()
   flagConfiguration = 'ERROR' in res
   print('configuration:', res)
   try:
     res = '\n'+ontology()
-  except:
+  except Exception:
     res = ' **ERROR**'
     #No new 'raise' so that it install-script continues its path
   flagOntology = 'ERROR' in res
-  print('ontology     :'+res)
+  print(f'ontology     :{res}')
 
   print('Add "install" argument to install PASTA-ELN.')
   if len(sys.argv)>1 and 'install' in sys.argv:
     if platform.system()=='Linux':
       print('---- Create PASTA-ELN installation Linux ----')
       if not existsCouchDB:
         print('install with root credentials...')
```

## pasta_eln/miscTools.py

```diff
@@ -25,15 +25,15 @@
     OKGREEN = '\033[92m'
     WARNING = '\033[93m'
     FAIL = '\033[91m'
     ENDC = '\033[0m'
     BOLD = '\033[1m'
     UNDERLINE = '\033[4m'
 
-def outputString(fmt:str='print', level:str='info', message:str='') ->str:
+def outputString(fmt:str='print', level:str='info', message:str='') -> str:
   """ Output a message into different formats:
     - print: print to stdout
     - logging; log to file
     - text: return text string (superseeds html)
     - html: return html string https://doc.qt.io/qtforpython/overviews/richtext-html-subset.html#supported-html-subset
     - else: no output
     - formats can be union ('print,text')
@@ -48,26 +48,26 @@
     txtOutput+= ' ***' if '***' in prefixes[level] else ''
     txtOutput+= f'{Bcolors.ENDC}\n'
   else:
     print('ERROR level not in prefixes ',level)
   # depend on format
   if 'print' in fmt:
     print(txtOutput)
-  if 'logging' in fmt and level in ['info','warning','error']:
+  if 'logging' in fmt and level in {'info', 'warning', 'error'}:
     getattr(logging,level)(message)
   if 'text' in fmt:
     return txtOutput
   if fmt=='html':
     colors = {'info':'black','error':'red','warning':'orange','ok':'green','okish':'blue','unsure':'magenta'}
     if level[0]=='h':
-      return '<'+level+'>'+message+'</'+level+'>'
+      return f'<{level}>{message}</{level}>'
     if level not in colors:
-      print('**ERROR: wrong level '+level)
+      print(f'**ERROR: wrong level {level}')
       return ''
-    return '<font color="'+colors[level]+'">'+message.replace('\n','<br>')+'</font><br>'
+    return f'<font color="{colors[level]}">' + message.replace('\n', '<br>') + '</font><br>'
   return ''
 
 
 def tracebackString(log:bool=False, docID:str='') -> str:
   """ Create a formatted string of traceback
 
   Args:
@@ -76,15 +76,15 @@
 
   Returns:
     str: | separated string of call functions
   """
   tracebackList = traceback.format_stack()[2:-2]
   reply = '|'.join([item.split('\n')[1].strip() for item in tracebackList])  #| separated list of stack excluding last
   if log:
-    logging.info(' traceback '+docID+': '+ reply)
+    logging.info(' traceback %s %s', docID, reply)
   return reply
 
 
 def camelCase(text:str) -> str:
   """
   Produce camelCase from normal string
   - file names abcdefg.hij are only replaced spaces
@@ -110,17 +110,15 @@
 
   Returns:
     string: directory name with leading number
   """
   if docType == 'x0':
     return camelCase(name)
   #steps, tasks
-  if isinstance(thisChildNumber, str):
-    thisChildNumber = int(thisChildNumber)
-  return f'{thisChildNumber:03d}'+'_'+camelCase(name)
+  return f'{thisChildNumber:03d}_{camelCase(name)}'
 
 
 def generic_hash(path:Path, forceFile:bool=False) -> str:
   """
   Hash an object based on its mode.
 
   inspired by:
@@ -143,20 +141,20 @@
   from urllib import request
   if str(path).startswith('http'):                      #Remote file:
     try:
       with request.urlopen(path.as_posix().replace(':/','://')) as site:
         meta = site.headers
         size = int(meta.get_all('Content-Length')[0])
         return blob_hash(site, size)
-    except:
+    except Exception:
       logging.error('Could not download content / hashing issue '+path.as_posix().replace(':/','://')+'\n'+\
         traceback.format_exc())
       return ''
   if path.is_dir():
-    raise ValueError('This seems to be a directory '+path.as_posix())
+    raise ValueError(f'This seems to be a directory {path.as_posix()}')
   if forceFile and path.is_symlink():
     path = path.resolve()
   if path.is_symlink():    #if link, hash the link
     shasum = symlink_hash(path)
   elif path.is_file():  #Local file
     with open(path, 'rb') as stream:
       shasum = blob_hash(stream, path.stat().st_size)
@@ -168,18 +166,15 @@
   key (str): key
   """
   import keyring as cred
   keys = key.split() if ' ' in key else [key]
   keys_ = []
   for keyI in keys:
     key_ = cred.get_password('pastaDB',keyI)
-    if key_ is None:
-      key_ = ':'
-    else:
-      key_ = ':'.join(key_.split('bcA:Maw'))
+    key_ = ':' if key_ is None else ':'.join(key_.split('bcA:Maw'))
     keys_.append(key_)
   return keys_
 
 
 def upIn(key:str) -> str:
   """
   key (str): key
@@ -255,15 +250,15 @@
 
   Returns:
     bool: success
   """
   verboseDebug = False
   extractorsAll = {}
   for fileName in os.listdir(directory):
-    if fileName.endswith('.py') and fileName not in ['testExtractor.py','tutorial.py','commit.py'] :
+    if fileName.endswith('.py') and fileName not in {'testExtractor.py','tutorial.py','commit.py'}:
       #start with file
       with open(directory/fileName,'r', encoding='utf-8') as fIn:
         if verboseDebug: print('\n'+fileName)
         lines = fIn.readlines()
         extractorsThis = {}
         ifInFile, headerState, header = False, True, []
         for idx,line in enumerate(lines):
@@ -288,27 +283,27 @@
               linePart = line.split('recipe')[1].strip()
               linePart = linePart.split(':')[1].split(',')[0].strip(" '"+'"')
             elif line.count('recipe')==2:
               possLines = [i.strip() for i in lines if ('recipe' in i and '=' in i and 'def' not in i)]
               if len(possLines)==1:
                 linePart=possLines[0].split('=')[1].strip(" '"+'"')
               elif len(possLines)>1:
-                print('**Warning: Could not decipher '+fileName,' Take shortest!')
+                print(f'**Warning: Could not decipher {fileName} Take shortest!')
                 linePart=sorted(possLines)[0].split('=')[1].strip(" '"+'"')
               else:
-                print('**ERROR: Could not decipher '+fileName,' File does not work!')
+                print(f'**ERROR: Could not decipher {fileName} File does not work!')
                 linePart=''
             extractorsThis[linePart]='Default'
             if verboseDebug:
               print('  return', linePart)
         if verboseDebug:
           print('Extractors', extractorsThis)
         ending = fileName.split('_')[1].split('.')[0]
         extractorsAll[ending]=extractorsThis
-        #header not used for now
+                    #header not used for now
   #update configuration file
   print('\n\nFound extractors:')
   print(yaml.dump(extractorsAll))
   with open(Path.home()/'.pastaELN.json','r', encoding='utf-8') as f:
     configuration = json.load(f)
   configuration['extractors'] = extractorsAll
   with open(Path.home()/'.pastaELN.json','w', encoding='utf-8') as f:
@@ -318,15 +313,15 @@
 
 def restart() -> None:
   """
   Complete restart: cold restart
   """
   try:
     os.execv('pastaELN',[''])  #installed version
-  except:
+  except Exception:
     os.execv(sys.executable, ['python3','-m','pasta_eln.gui']) #started for programming or debugging
   return
 
 
 class DummyProgressBar():
   """ Class representing a progressbar that does not do anything
   """
```

## pasta_eln/mixin_cli.py

```diff
@@ -17,53 +17,47 @@
 
     Returns:
         string: output incl. \n
     """
     outString = []
     widthArray = [25,25,25,25]
     for idx,item in enumerate(self.db.ontology[docType]['prop']):
-      if not 'name' in item:    #heading
+      if 'name' not in item:    #heading
         continue
-      if idx<len(widthArray):
-        width = widthArray[idx]
-      else:
-        width = 0
+      width = widthArray[idx] if idx<len(widthArray) else 0
       if width!=0:
         formatString = '{0: <'+str(abs(width))+'}'
         outString.append(formatString.format(item['name'].replace('-','')) )
     outString = '|'.join(outString)+'\n'
     outString += '-'*104+'\n'
-    for lineItem in self.db.getView('viewDocType/'+docType):
+    for lineItem in self.db.getView(f'viewDocType/{docType}'):
       rowString = []
       for idx, item in enumerate(self.db.ontology[docType]['prop']):
-        if idx<len(widthArray):
-          width = widthArray[idx]
-        else:
-          width = 0
+        width = widthArray[idx] if idx<len(widthArray) else 0
         if width!=0:
           formatString = '{0: <'+str(abs(width))+'}'
           if isinstance(lineItem['value'][idx], str ):
             contentString = lineItem['value'][idx]
           elif isinstance(lineItem['value'][idx], (bool,int)):
             contentString = str(lineItem['value'][idx])
           elif lineItem['value'][idx] is None:
             contentString = '--'
           else: #list
             contentString = ' '.join(lineItem['value'][idx])
           contentString = contentString.replace('\n',' ')
           if width<0:  #test if value as non-trivial length
-            if lineItem['value'][idx]=='true' or lineItem['value'][idx]=='false':
+            if lineItem['value'][idx] in ['true', 'false']:
               contentString = lineItem['value'][idx]
             elif isinstance(lineItem['value'][idx], bool ) or lineItem['value'][idx] is None:
               contentString = str(lineItem['value'][idx])
             elif len(lineItem['value'][idx])>1 and len(lineItem['value'][idx][0])>3:
               contentString = 'true'
             else:
               contentString = 'false'
-            # contentString = True if contentString=='true' else False
+                    # contentString = True if contentString=='true' else False
           rowString.append(formatString.format(contentString)[:abs(width)] )
       if printID:
         rowString.append(' '+lineItem['id'])
       outString += '|'.join(rowString)+'\n'
     return outString
 
 
@@ -75,35 +69,30 @@
     Args:
       tag (string): tag to be listed, if empty: print all
       **kwargs (dict): additional parameter
 
     Returns:
         string: output incl. \n
     """
-    outString = []
-    outString.append(f'{0: <10}'.format('Tags') )
-    outString.append(f'{0: <60}'.format('Name') )
-    outString.append(f'{0: <10}'.format('ID') )
+    outString = [f'{0: <10}'.format('Tags'), f'{0: <60}'.format('Name'), f'{0: <10}'.format('ID')]
     outString = '|'.join(outString)+'\n'
     outString += '-'*106+'\n'
     view = None
     if tag=='':
       view = self.db.getView('viewIdentify/viewTags')
     else:
-      view = self.db.getView('viewIdentify/viewTags',preciseKey='#'+tag)
+      view = self.db.getView('viewIdentify/viewTags', preciseKey=f'#{tag}')
     for lineItem in view:
-      rowString = []
-      rowString.append(f'{0: <10}'.format(lineItem['key']))
-      rowString.append(f'{0: <60}'.format(lineItem['value']))
-      rowString.append(f'{0: <10}'.format(lineItem['id']))
+      rowString = [f'{0: <10}'.format(lineItem['key']), f'{0: <60}'.format(lineItem['value']), f'{0: <10}'.format(lineItem['id'])]
       outString += '|'.join(rowString)+'\n'
     return outString
 
 
   def outputHierarchy(self, onlyHierarchy=True, addID=False, addTags=None, **kwargs):
+    # sourcery skip: inline-immediately-returned-variable, use-join
     """
     output hierarchical structure in database
     - convert view into native dictionary
     - ignore key since it is always the same
 
     Args:
        onlyHierarchy (bool): only print project,steps,tasks or print all (incl. measurements...)[default print all]
@@ -156,10 +145,10 @@
 
     Returns:
         string: output incl. \n
     """
     outString = f"{'SHAsum': <32}|{'Name': <40}|{'ID': <25}\n"
     outString += '-'*110+'\n'
     for item in self.db.getView('viewIdentify/viewSHAsum'):
-      key = item['key'] if item['key'] else '-empty-'
+      key = item['key'] or '-empty-'
       outString += f"{key[:32]: <32}|{item['value'][:40]: <40}|{item['id']: <25}\n"
     return outString
```

## pasta_eln/printer.py

```diff
@@ -60,21 +60,17 @@
   import numpy as np
   from PIL import Image, ImageDraw, ImageFont
   fnt = ImageFont.truetype("arial.ttf", page['font'])
   offset    = int((page['size'][0]+page['margin'])/page['tiles'])
   qrCodeSize= min(offset-page['font']-page['margin'], page['size'][1])
   print("Effective label size",page['size'], "offset",offset, 'qrCodeSize',qrCodeSize)
   cropQRCode  = 40         #created by qrcode library
-  numCodes = 0
   image = Image.new('RGBA', page['size'], color=(255,255,255,255) )
-  for idx in range(page['tiles']):
-    if idx<len(codes):
-      codeI, text = codes[idx]
-    else:
-      codeI, text =  '', ''
+  for numCodes, idx in enumerate(range(page['tiles'])):
+    codeI, text = codes[idx] if idx<len(codes) else ('', '')
     if len(codeI)==0:
       codeI = uuid.uuid4().hex
     # add text
     width, height = fnt.getsize(text)
     txtImage = Image.new('L', (width, height), color=255)
     d = ImageDraw.Draw(txtImage)
     d.text( (0, 0), text,  font=fnt, fill=0)
@@ -83,15 +79,14 @@
       txtImage=txtImage.crop((0,width-page['size'][1],height,width))
     image.paste(txtImage, (numCodes*offset+qrCodeSize-4, int((page['size'][1]-txtImage.size[1])/2)   ))
     # add qrcode
     qrCode = qrcode.make(codeI, error_correction=qrcode.constants.ERROR_CORRECT_M)
     qrCode = qrCode.crop((cropQRCode, cropQRCode, qrCode.size[0]-cropQRCode, qrCode.size[0]-cropQRCode))
     qrCode = qrCode.resize((qrCodeSize, qrCodeSize))
     image.paste(qrCode, (numCodes*offset, int((page['size'][1]-qrCodeSize)/2)))
-    numCodes += 1
   tmpFileName = tempfile.gettempdir()+os.sep+'tmpQRcode.png'
   print('Create temp-file',tmpFileName)
   image.save(tmpFileName)
   cmd = 'brother_ql -b pyusb -m '+printer['model']+' -p usb://'+printer['dev']+' print -l '+printer['size']+' -r auto '+tmpFileName
   reply = os.system(cmd)
   if reply>0:
     print('**ERROR mpq01: Printing error')
```

## pasta_eln/serverActions.py

```diff
@@ -22,15 +22,15 @@
 def passwordDecrypt(message:bytes) -> str:
   """
   de-obfuscate message
   """
   return base64.b64decode(message).decode('utf-8')
 
 #global variables
-headers:CaseInsensitiveDict[str]= requests.structures.CaseInsensitiveDict()
+headers:CaseInsensitiveDict[str]= CaseInsensitiveDict()
 headers["Content-Type"] = "application/json"
 
 
 def createUserDatabase(url:str, auth:AuthBase, userName:str) -> None:
   '''
   create a new user and database
 
@@ -39,64 +39,66 @@
     auth (object): HTTPBasicAuth object
     userName (string): user name, e.g. m.miller
   '''
   userPW = secrets.token_urlsafe(13)
   userDB = userName.replace('.','_')
 
   # create database
-  resp = requests.put(url+'/'+userDB, headers=headers, auth=auth, timeout=10)
+  resp = requests.put(f'{url}/{userDB}', headers=headers, auth=auth, timeout=10)
   if not resp.ok:
     print("**ERROR 1: put not successful",resp.reason)
     return
 
   # create user
-  dataDict:dict[str,Any] = {"docs":[{"_id":"org.couchdb.user:"+userName,"name": userName,"password":userPW,
-    "roles":[userDB+"-W"], "type": "user", "orcid": ""}]}
+  userDict = {"_id": f"org.couchdb.user:{userName}", "name": userName, "password": userPW, "roles": [f"{userDB}-W"], "type": "user", "orcid": ""}
+  dataDict: dict[str, Any] = { "docs": [userDict] }
   data = json.dumps(dataDict)
-  resp = requests.post(url+'/_users/_bulk_docs', headers=headers, auth=auth, data=data, timeout=10)
+  resp = requests.post(f'{url}/_users/_bulk_docs', headers=headers, auth=auth, data=data, timeout=10)
   if not resp.ok:
     print("**ERROR 2: post not successful",resp.reason)
     return
 
   # create _security in database
-  dataDict = {"admins": {"names":[],"roles":[userDB+"-W"]},
-          "members":{"names":[],"roles":[userDB+"-R"]}}
+  dataDict = {
+      "admins": {"names": [], "roles": [f"{userDB}-W"]},
+      "members": {"names": [], "roles": [f"{userDB}-R"]},
+  }
   data = json.dumps(dataDict)
-  resp = requests.put(url+'/'+userDB+'/_security', headers=headers, auth=auth, data=data, timeout=10)
+  resp = requests.put(f'{url}/{userDB}/_security', headers=headers, auth=auth, data=data, timeout=10)
   if not resp.ok:
     print("**ERROR 3: post not successful",resp.reason)
     return
 
   # create _design/authentication in database
   dataDict = {"validate_doc_update": "function(newDoc, oldDoc, userCtx) {"+\
     "if (userCtx.roles.indexOf('"+userDB+"-W')!==-1){return;} "+\
     "else {throw({unauthorized:'Only Writers (W) may edit the database'});}}"}
   data = json.dumps(dataDict)
-  resp = requests.put(url+'/'+userDB+'/_design/authentication',headers=headers,auth=auth,data=data,timeout=10)
+  resp = requests.put(f'{url}/{userDB}/_design/authentication', headers=headers, auth=auth, data=data, timeout=10)
   if not resp.ok:
     print("**ERROR 4: post not successful",resp.reason)
     return
 
   print('SUCCESS: Server interaction')
   #create image
   img = Image. new('RGB', (500, 500), color = (0, 65, 118))
   d = ImageDraw. Draw(img)
   font = ImageFont.truetype("arial.ttf", 24)
   d.text((30, 30),  "configuration name: remote", fill=(240,240,240), font=font)
-  d.text((30, 70),  "user-name: "+userName, fill=(240,240,240), font=font)
-  d.text((30,110),  "password: " +userPW,   fill=(240,240,240), font=font)
-  d.text((30,150),  "database: " +userDB,   fill=(240,240,240), font=font)
-  d.text((30,190),  "Remote configuration", fill=(240,240,240), font=font)
-  d.text((30,230),  "Server:   " +url, fill=(240,240,240), font=font)
-  img.save(userDB+'.png')
+  d.text((30, 70), f"user-name: {userName}", fill=(240,240,240), font=font)
+  d.text((30,110), f"password: {userPW}",    fill=(240,240,240), font=font)
+  d.text((30,150), f"database: {userDB}",    fill=(240,240,240), font=font)
+  d.text((30,190),  "Remote configuration",  fill=(240,240,240), font=font)
+  d.text((30,230), f"Server:   {url}",       fill=(240,240,240), font=font)
+  img.save(f'{userDB}.png')
   #create key file
   dataDict = {"configuration name":"remote","user-name":userName,"password":userPW,"database":userDB,\
     "Remote configuration":"true","Server":url}
   dataBin = passwordEncrypt(json.dumps(dataDict))
-  with open(userDB+'.key','bw') as fOut:
+  with open(f'{userDB}.key','bw') as fOut:
     fOut.write(dataBin)
   return
 
 
 def listUsers(url:str, auth:AuthBase, verbose:bool=True) -> dict[str,Any]:
   '''
   list (and test) all users
@@ -105,96 +107,96 @@
     url (string): url incl. http and port
     auth (object): HTTPBasicAuth object
     verbose (bool): verbose output
 
   Returns:
     dict: user information
   '''
-  resp = requests.get(url+'/_users/_all_docs', headers=headers, auth=auth, timeout=10)
+  resp = requests.get(f'{url}/_users/_all_docs', headers=headers, auth=auth, timeout=10)
   if not resp.ok:
     print("**ERROR: get not successful",resp.reason)
     return {}
   if verbose:
     print("List of users:")
   results = {}
   for i in json.loads(resp.text)['rows']:
     if i['id']=='_design/_auth':
       continue
     if verbose:
       print(i['id'][17:]+'       key:'+i['key'][17:])
-    responseI = requests.get(url+'/_users/'+i['id'], headers=headers, auth=auth, timeout=10)
+    responseI = requests.get(f'{url}/_users/'+i['id'], headers=headers, auth=auth, timeout=10)
     respI = json.loads(responseI.text)
     results[respI['name']] = respI['roles']
     if verbose:
       print('  Roles',respI['roles'])
       print('  Name ',respI['name'])
       if respI['name'].replace('.','_')+'-W' in respI['roles']:
         print('  -> corresponds to role-name convention')
       else:
         print('  -> DOES NOT correspond to role-name convention:',respI['name'])
       if i['id'].endswith(respI['name']):
         print('  -> corresponds to id-name convention')
       else:
         print('  -> DOES NOT correspond to id-name convention:',respI['name'])
       print('  Orcid',respI['orcid'])
-  if verbose:
-    return {}
-  return results
+  return {} if verbose else results
 
 
 def listDB(url:str, auth:AuthBase, verbose:bool) -> dict[str,Any]:
   '''
   list (and test) all databases
 
   Args:
     url (string): url incl. http and port
     auth (object): HTTPBasicAuth object
     verbose (bool): verbose output
 
   Returns:
     dict: database information
   '''
-  resp = requests.get(url+'/_all_dbs', headers=headers, auth=auth, timeout=10)
+  resp = requests.get(f'{url}/_all_dbs', headers=headers, auth=auth, timeout=10)
   if not resp.ok:
     print("**ERROR: get not successful",resp.reason)
     return {}
   if verbose:
     print("List of databases:")
   results = {}
   for i in json.loads(resp.text):
     if i in ['_replicator','_users']:
       continue
     if verbose:
       print(i)
     # test security
-    responseI = requests.get(url+'/'+i+'/_security', headers=headers, auth=auth, timeout=10)
+    responseI = requests.get(f'{url}/{i}/_security', headers=headers, auth=auth, timeout=10)
     respI = json.loads(responseI.text)
     security = [respI['admins']['roles'], respI['members']['roles']]
     if verbose:
       print('  Write',respI['admins']['roles'])
       print('  Read ',respI['members']['roles'])
       if (respI['admins']['roles'][0].endswith('-W') and
           respI['members']['roles'][0].endswith('-R') and
           respI['admins']['roles'][0].split('-')[0] == respI['members']['roles'][0].split('-')[0]):
         print('  -> everything ok')
       else:
         print('  -> **ERROR** security')
     # test authentication
-    respI = requests.get(url+'/'+i+'/_design/authentication', headers=headers, auth=auth, timeout=10)
-    respI = json.loads(respI.text)['validate_doc_update']
-    respI = respI.split('indexOf')[1].split('!==')[0].strip()[2:-2]
-    results[i] = security+[respI]
-    if verbose:
-      if respI == i+'-W':
-        print('  -> everything ok')
-      else:
-        print('  -> **ERROR** authentication',respI)
-  if verbose:
-    return {}
-  return results
+    respI = requests.get(f'{url}/{i}/_design/authentication', headers=headers, auth=auth, timeout=10)
+    respI = json.loads(respI.text)
+    if 'validate_doc_update' in respI:
+      respI = respI['validate_doc_update']
+      respI = respI.split('indexOf')[1].split('!==')[0].strip()[2:-2]
+      results[i] = security+[respI]
+      if verbose:
+        if respI == f'{i}-W':
+          print('  -> everything ok')
+        else:
+          print('  -> **ERROR** authentication',respI)
+    else:
+      print("**ERROR <url>/<userDB>/_design/authentication' does not exist. Everybody can access!")
+  return {} if verbose else results
 
 
 def testUser(url:str, auth:AuthBase, userName:str, userPassword:str) -> None:
   '''
   test if configuration for this user is correct
   '''
   # Test if server exists
@@ -220,22 +222,22 @@
       if write.endswith('-W') and read.endswith('-R') and authen.endswith('-W') and \
         write[:-2] == read[:-2] and write[:-2] == authen[:-2]:
         print("-> User database and user-name correct")
       else:
         print("**ERROR: ",write,read,authen,iDB)
         break
     #test server with user credentials 1
-    resp = requests.get(url+'/'+iDB, headers=headers, auth=authUser, timeout=10)
+    resp = requests.get(f'{url}/{iDB}', headers=headers, auth=authUser, timeout=10)
     if resp.ok:
       print("-> Database can be read")
     else:
       print("**ERROR: Database cannot be read")
       break
     #test server with user credentials 2
-    resp = requests.get(url+'/'+iDB+'/_design/authentication', headers=headers, auth=authUser, timeout=10)
+    resp = requests.get(f'{url}/{iDB}/_design/authentication', headers=headers, auth=authUser, timeout=10)
     if resp.ok:
       print("-> Authentication can be read")
     else:
       print("**ERROR: Authentication  cannot be read")
       break
   return
 
@@ -261,15 +263,15 @@
   authUser = requests.auth.HTTPBasicAuth(userName, password)
   resp = requests.get('http://127.0.0.1:5984/_all_dbs', headers=headers, auth=authUser, timeout=10)
   if resp.ok:
     answer += 'success: Local username and password ok\n'
   else:
     answer += 'ERROR: Local username or password incorrect\n'
   if database!='':
-    resp = requests.get('http://127.0.0.1:5984/'+database, headers=headers, auth=authUser, timeout=10)
+    resp = requests.get(f'http://127.0.0.1:5984/{database}', headers=headers, auth=authUser, timeout=10)
     if resp.ok:
       answer += 'success: Local database exists\n'
     else:
       answer += 'Warning: Local database does not exist\n'
   return answer
 
 
@@ -289,100 +291,123 @@
   answer = ''
   resp = requests.get(url, headers=headers, timeout=10)
   if resp.ok:
     answer += 'success: Remote server exists\n'
   else:
     answer += 'ERROR: Remote server is not working\n'
   authUser = requests.auth.HTTPBasicAuth(userName, password)
-  resp = requests.get(url+'/'+database, headers=headers, auth=authUser, timeout=10)
+  resp = requests.get(f'{url}/{database}', headers=headers, auth=authUser, timeout=10)
   if resp.ok:
     answer += 'success: Remote database exists\n'
   else:
     answer += 'ERROR: Remote username, password, database incorrect\n'
   return answer
 
 
+def listDocuments(url:str, userName:str, password:str, database:str, full:bool=True) -> str:
+  """
+  list documents in database
+
+  Args:
+    url (str): url of remote server
+    userName (str): user name at remote server
+    password (str): password at remote server
+    database (str): couchdb database
+    full (bool): full list or just number
+
+  Returns:
+    str: success and errors in '\n'-string
+  """
+  authUser = requests.auth.HTTPBasicAuth(userName, password)
+  resp = requests.get(f'{url}/{database}/_all_docs', headers=headers, auth=authUser, timeout=10)
+  if resp.status_code != 200:
+    print('**ERROR response for _all_dbs wrong', resp.text)
+    print('Username and password', userName, password)
+    return 'ERROR!'
+  print(f"\nNumber of docs: {resp.json()['total_rows']}")
+  if full:
+    print(', '.join([doc['id'] for doc in resp.json()['rows']]))
+  return 'Success'
+
+
 def backupCouchDB(location:str='', userName:str='', password:str='') -> None:
   """
   Backup everything of the CouchDB installation accross all databases and all configurations
   - remote location uses username/password combo in local keystore
   - local location requires username and password
 
   Args:
     location (str): 'local', 'remote', else: ask user via CLI
     userName (str): username
     password (str): password
   """
   # get username and password
-  if location=='':
+  if not location:
     location = 'remote' if input('Enter location: [r] remote; else local: ')=='r' else 'local'
   if location=='local':
     location = '127.0.0.1'
-    if userName=='':
+    if not userName:
       userName = input('Enter username: ').strip()
-    if password=='':
+    if not password:
       password = input('Enter password: ').strip()
   elif location=='remote':
     try:
       myString = cred.get_password('pastaDB','admin')
       if myString is None:
         print("**ERROR Could not get credentials from keyring 2. Please create manually.")
         return
       location, userName, password = myString.split(':')
       print("URL and credentials successfully read from keyring")
-    except:
+    except Exception:
       print("**ERROR Could not get credentials from keyring 2b. Please create manually.")
       return
   else:
     print('**ERROR: wrong location given.')
     return
   # use information
   authUser = requests.auth.HTTPBasicAuth(userName, password)
-  resp = requests.get('http://'+location+':5984/_all_dbs',
-                      headers=headers, auth=authUser, timeout=10)
+  resp = requests.get(f'http://{location}:5984/_all_dbs', headers=headers, auth=authUser, timeout=10)
   if resp.status_code != 200:
     print('**ERROR response for _all_dbs wrong', resp.text)
     print('Username and password', userName, password)
     return
   timestamp = datetime.now().isoformat().split('.')[0].replace('-','').replace(':','')
   zipFileName = 'couchDB_backup_'+location.replace('.','')+'_'+timestamp
-  print('Create zip-file '+zipFileName+'.zip')
+  print(f'Create zip-file {zipFileName}.zip')
   databases = resp.json()
-  with ZipFile(zipFileName+'.zip', 'w', compression=ZIP_DEFLATED) as zipFile:
+  with ZipFile(f'{zipFileName}.zip', 'w', compression=ZIP_DEFLATED) as zipFile:
     for database in databases:
       if database.startswith('_'):
         print('Special database', database, ': Nothing to do')
       else:
         print('Backup normal database ',database)
-        resp = requests.get('http://'+location+':5984/'+database+'/_all_docs',
-                            headers=headers, auth=authUser, timeout=10)
+        resp = requests.get(f'http://{location}:5984/{database}/_all_docs', headers=headers, auth=authUser, timeout=10)
         for item in resp.json()['rows']:
           docID = item['id']
-          doc   = requests.get('http://'+location+':5984/'+database+'/'+docID,
-                              headers=headers, auth=authUser, timeout=10).json()
-          zipFile.writestr(zipFileName+'/'+database+'/'+docID, json.dumps(doc))
+          doc   = requests.get(f'http://{location}:5984/{database}/{docID}', headers=headers, auth=authUser, timeout=10).json()
+          zipFile.writestr(f'{zipFileName}/{database}/{docID}', json.dumps(doc))
           if '_attachments' in doc:
             for att in doc['_attachments']:
-              docAttach = requests.get('http://'+location+':5984/'+database+'/'+docID+'/'+att,
+              docAttach = requests.get(f'http://{location}:5984/{database}/{docID}/{att}',
                                         headers=headers, auth=authUser, timeout=10).json()
-              zipFile.writestr(zipFileName+'/'+database+'/'+docID+'_attach/'+att, json.dumps(docAttach))
+              zipFile.writestr(f'{zipFileName}/{database}/{docID}_attach/{att}', json.dumps(docAttach))
         #_design/authentication is automatically included
         #_security
-        doc   = requests.get('http://'+location+':5984/'+database+'/_security',
+        doc   = requests.get(f'http://{location}:5984/{database}/_security',
                               headers=headers, auth=authUser, timeout=10).json()
-        zipFile.writestr(zipFileName+'/'+database+'/_security', json.dumps(doc))
+        zipFile.writestr(f'{zipFileName}/{database}/_security', json.dumps(doc))
     with open(Path.home()/'.pastaELN.json', encoding='utf-8') as fIn:
       configuration = json.loads(fIn.read())
       for projectG in configuration['projectGroups']:
         for site in ['local','remote']:
           subsection = configuration['projectGroups'][projectG][site]
           if 'cred' in subsection and ('user' not in subsection or 'password' not in subsection):
             key = cred.get_password('pastaDB', subsection['cred'])
             subsection['user'], subsection['password'] = ['',''] if key is None else key.split('bcA:Maw')
-      zipFile.writestr(zipFileName+'/pastaELN.json', json.dumps(configuration))
+      zipFile.writestr(f'{zipFileName}/pastaELN.json', json.dumps(configuration))
   return
 
 
 def restoreCouchDB(location:str='', userName:str='', password:str='', fileName:str='') -> None:
   """
   restore everything to the CouchDB installation accross all databases and all configurations
   - remote location uses username/password combo in local keystore
@@ -391,98 +416,91 @@
   Args:
     location (str): 'local', 'remote', else: ask user via CLI
     userName (str): username
     password (str): password
     fileName (str): file used for restoration
   """
   # get username and password
-  if location=='':
+  if not location:
     location = 'remote' if input('Enter location: [r]emote; else local: ')=='r' else 'local'
   if location=='local':
     location = '127.0.0.1'
-    if userName=='':
+    if not userName:
       userName = input('Enter username: ').strip()
-    if password=='':
+    if not password:
       password = input('Enter password: ').strip()
   elif location=='remote':
     try:
       myString = cred.get_password('pastaDB','admin')
       if myString is None:
         print("**ERROR Could not get credentials from keyring 3. Please create manually.")
         return
       location, userName, password = myString.split(':')
       print("URL and credentials successfully read from keyring")
-    except:
+    except Exception:
       print("**ERROR Could not get credentials from keyring 3b. Please create manually.")
       return
   else:
     print('**ERROR: wrong location given.')
     return
-  if fileName=='':
+  if not fileName:
     possFiles = [i for i in os.listdir('.') if i.startswith('couchDB') and i.endswith('.zip')]
     for idx, i in enumerate(possFiles):
-      print('['+str(idx+1)+'] '+i)
-    fileName = input('Which file to use for restored? (1-'+str(len(possFiles))+') ')
+      print(f'[{str(idx + 1)}] {i}')
+    fileName = input(f'Which file to use for restored? (1-{len(possFiles)}) ')
     fileName = possFiles[int(fileName)-1]
   # use information
   authUser = requests.auth.HTTPBasicAuth(userName, password)
   with ZipFile(fileName, 'r', compression=ZIP_DEFLATED) as zipFile:
     files = zipFile.namelist()
     #first run through: create documents and design documents
     for fileI in files:
       fileParts = fileI.split('/')[1:]
       database = fileParts[0]
       docID = fileParts[1]
       if docID.endswith('_attach'):
         continue #Do in second loop
       #test if database is exists: create otherwise
-      resp = requests.get('http://'+location+':5984/'+database+'/_all_docs',
-                              headers=headers, auth=authUser, timeout=10)
+      resp = requests.get(f'http://{location}:5984/{database}/_all_docs', headers=headers, auth=authUser, timeout=10)
       if resp.status_code != 200 and resp.json()['reason']=='Database does not exist.':
-        resp = requests.put('http://'+location+':5984/'+database,
-                            headers=headers, auth=authUser, timeout=10)
+        resp = requests.put(f'http://{location}:5984/{database}', headers=headers, auth=authUser, timeout=10)
         if not resp.ok:
           print("**ERROR: could not create database",resp.reason)
           return
       #test if document is exists: create otherwise
       if docID=='_design':
         docID = '/'.join(fileParts[1:])
-      resp = requests.get('http://'+location+':5984/'+database+'/'+docID,
-                          headers=headers, auth=authUser, timeout=10)
+      resp = requests.get(f'http://{location}:5984/{database}/{docID}', headers=headers, auth=authUser, timeout=10)
       if resp.status_code != 200 and resp.json()['reason']=='missing':
         with zipFile.open(fileI) as dataIn:
           doc = json.loads( dataIn.read() )  #need doc conversion since deleted from it
           del doc['_rev']
           if '_attachments' in doc:
             del doc['_attachments']
-          resp = requests.put('http://'+location+':5984/'+database+'/'+docID, data=json.dumps(doc),
-                              headers=headers, auth=authUser, timeout=10)
+          resp = requests.put(f'http://{location}:5984/{database}/{docID}', data=json.dumps(doc), headers=headers, auth=authUser, timeout=10)
           if resp.ok:
             print('Saved document:', database, docID)
           else:
             print("**ERROR: could not save document:",resp.reason, database, docID, '\n', doc)
     #second run through: create attachments
     for fileI in files:
       fileParts = fileI.split('/')[1:]
       database = fileParts[0]
       docID = fileParts[1]
       if not docID.endswith('_attach'):
         continue #Did already in the first loop
       #test if attachement exists: create otherwise
-      attachPath =docID[:-7]+'/'+fileParts[-1]
-      resp = requests.get('http://'+location+':5984/'+database+'/'+attachPath,
-                              headers=headers, auth=authUser, timeout=10)
+      attachPath = f'{docID[:-7]}/{fileParts[-1]}'
+      resp = requests.get(f'http://{location}:5984/{database}/{attachPath}', headers=headers, auth=authUser, timeout=10)
       if resp.status_code == 404 and 'missing' in resp.json()['reason']:
         with zipFile.open(fileI) as dataIn:
           attachDoc = dataIn.read()
-          resp = requests.get('http://'+location+':5984/'+database+'/'+docID[:-7],
-                              headers=headers, auth=authUser, timeout=10)
+          resp = requests.get(f'http://{location}:5984/{database}/{docID[:-7]}', headers=headers, auth=authUser, timeout=10)
           headers['If-Match'] = resp.json()['_rev'] #will be overwritten each time
-          resp = requests.put('http://'+location+':5984/'+database+'/'+attachPath, data=attachDoc,
-                              headers=headers, auth=authUser, timeout=10)
+          resp = requests.put(f'http://{location}:5984/{database}/{attachPath}', data=attachDoc, headers=headers, auth=authUser, timeout=10)
           if resp.ok:
             print('Saved attachment:', database, attachPath)
           else:
             print('\n**ERROR: could not save attachment:',resp.reason, database, attachPath,'\n', doc)
   return
 
 
@@ -494,54 +512,73 @@
   #  myString = url+':'+adminUserName+':'+adminPassword
   #  url without http and port
   #  cred.set_password('pastaDB','admin',myString)
   try:
     myString = cred.get_password('pastaDB','admin')
     if myString is None:
       print("**ERROR Could not get credentials from keyring 1. Please create manually.")
+      print("import keyring as cred\nmyString = url+':'+adminUserName+':'+adminPassword\n#  url without http and port\ncred.set_password('pastaDB','admin',myString)")
       sys.exit(1)
     url, administrator, password = myString.split(':')
     print("URL and credentials successfully read from keyring")
-  except:
+  except Exception:
     print("Could not get credentials from keyring.")
     ## URL
     url = input('Enter the URL without http and without port: ')
     if len(url)<2:
       print('* No legit URL entered: exit')
       sys.exit(1)
     ## User-name, password
     administrator = input('Enter the administrator username: ')
     password =      input('Enter the administrator password: ')
   #assemble information
-  url = 'http://'+url+':5984'
+  url = f'http://{url}:5984'
   auth = requests.auth.HTTPBasicAuth(administrator, password)
 
+  print('\n-------------------------------------------------------------------------')
+  print(  'Manage users and databases for PASTA-ELN on a remote couchDB installation')
+  print(  '-------------------------------------------------------------------------')
   while True:
-    print('\nAdopt a server to PASTA-ELN\nCommands: [q]uit; [n]ew user; list [u]ser; list [d]atabases; '+\
-          '[t]est user; [b]ackup data; [r]estore data')
+    print('\nCommands: [q]uit; [n]ew user; list [u]ser; list [d]atabases; '+\
+          '[t]est username and password; [b]ackup data; [r]estore data; [c]redentials; [l]ist documents in database')
     command = input('> ')
     userName, userPassword = '', ''
     if command == 'q':
       break
     # ask questions for parameters
-    if command in ['n', 't']:
+    if command in ['n', 't', 'l']:
       userName =      input('Enter the user-name, e.g. m.miller: ')
-    if command in ['t']:
-      userPassword =      input('Enter the user-password: ')
+    if command in ['t', 'l']:
+      userPassword =  input('Enter the user-password: ')
     # execute command
     if command == 'n' and userName and len(userName)>2:
       createUserDatabase(url, auth, userName)
     elif command == 'u':
       listUsers(url, auth)
     elif command == 'd':
       listDB(url, auth, True)
     elif command == 'b':
       backupCouchDB()
     elif command == 'r':
       restoreCouchDB()
+    elif command == 'c':
+      print('``` python')
+      print('import json, requests')
+      print('from requests.structures import CaseInsensitiveDict')
+      print('headers:CaseInsensitiveDict[str]= CaseInsensitiveDict()')
+      print('headers["Content-Type"] = "application/json"\n')
+      print(f'url = "{url}"')
+      print(f'administrator = "{administrator}"')
+      print(f'password = "{password}"\n')
+      print('auth = requests.auth.HTTPBasicAuth(administrator, password)')
+      print('```')
+    elif command == 'l':
+      database = input('Enter the database: ')
+      full     = input('Full output [yN] ')=='y'
+      listDocuments(url, userName, userPassword, database, full)
     elif command == 't' and userName and userPassword and len(userName)>2 and len(userPassword)>2:
       testUser(url, auth, userName, userPassword)
     else:
       print("Unknown command or incomplete entries.")
 
 
 if __name__ ==  '__main__':
```

## pasta_eln/style.py

```diff
@@ -38,15 +38,15 @@
   # theme = get_theme(themeName)
   # print(theme)
   ## For dark-blue:
   ## {'primaryColor': '#448aff', 'primaryLightColor': '#83b9ff', 'secondaryColor': '#232629', 'secondaryLightColor': '#4f5b62',
   ##  'secondaryDarkColor': '#31363b', 'primaryTextColor': '#000000', 'secondaryTextColor': '#ffffff'}
   if themeName == 'none':
     return '#000000'
-  return get_theme(themeName+'.xml')[color+'Color']
+  return get_theme(f'{themeName}.xml')[f'{color}Color']
 
 
 class TextButton(QPushButton):
   """ Button that has only text"""
   def __init__(self, label:str, function:Optional[Callable[[],None]], layout:Optional[QLayout], name:str='',
                tooltip:str='', checkable:bool=False, style:str='', hide:bool=False, backend:Optional[Backend]=None):
     """
@@ -74,15 +74,15 @@
     else:
       if backend is None:
         primaryColor = '#448aff'
         secTextColor = '#eeeeee'
       else:
         primaryColor = getColor(backend, 'primary')
         secTextColor = getColor(backend, 'secondaryText')
-      self.setStyleSheet('border-width: 0px; background-color: '+primaryColor+'; color: '+secTextColor)
+      self.setStyleSheet(f'border-width: 0px; background-color: {primaryColor}; color: {secTextColor}')
     if hide:
       self.hide()
     if layout is not None:
       layout.addWidget(self)
 
 
 class IconButton(QPushButton):
@@ -108,41 +108,44 @@
     self.setText(text)
     self.clicked.connect(function)
     self.setFixedHeight(30)
     if name != '':
       self.setAccessibleName(name)
     if tooltip != '':
       self.setToolTip(tooltip)
-    if style == '':
+    if not style:
       self.setStyleSheet("border-width:0")
     else:
       self.setStyleSheet(style)
     if hide:
       self.hide()
     if layout is not None:
       layout.addWidget(self)
 
 
 class Action(QAction):
   """ QAction and assign function to menu"""
   def __init__(self, label:str, function:Callable[[],None], menu:QMenu, parent:QWidget,
-               shortcut:Optional[str]=None, name:Optional[str]=None):
+               shortcut:Optional[str]=None, name:Optional[str]=None, icon:str=''):
     """
     Args:
       label (str): label printed on submenu
       function (function): function to be called
       menu (QMenu): button to be added to this menu
       parent (QWidget): parent widget
       shortcut (str): shortcut (e.g. Ctrl+K)
       name (str): additional data to transport
+      icon (str): icon name
     """
     super().__init__()
     self.setParent(parent)
     self.setText(label)
     self.triggered.connect(function)
+    if icon:
+      self.setIcon(qta.icon(icon, scale_factor=1))
     if menu is not None:
       menu.addAction(self)
     if shortcut is not None:
       self.setShortcut(QKeySequence(shortcut))
     if name is not None:
       self.setData(name)
 
@@ -193,15 +196,15 @@
         if imageW.height()>imageW.width():
           imageW.setMaximumSize(int(float(imageW.width())/float(imageW.height())*anyDimension) ,anyDimension)
         else:
           imageW.setMaximumSize(anyDimension, int(float(imageW.height())/float(imageW.width())*anyDimension))
       if layout is not None:
         layout.addWidget(imageW, alignment=Qt.AlignHCenter) # type: ignore
     elif len(data)>2:
-      print('WidgetProjectLeaf:What is this image |'+data[:50]+'|')
+      print(f'WidgetProjectLeaf:What is this image |{data[:50]}|')
     return
 
 
 class Label(QLabel):
   """ Label widget: headline, ... """
   def __init__(self, text:str='', size:str='', layout:Optional[QLayout]=None,
                function:Optional[Callable[[str, str],None]]=None, docID:str='', tooltip:str=''):
@@ -212,19 +215,19 @@
       layout (QLayout): layout to which to add the label
       function (function): function to call on mouse click
       docID (str): docID on other string to connect to this label
       tooltip (str): tooltip shown when mouse hovers the button
     """
     super().__init__()
     self.setText(text)
-    if size == 'h1' :
+    if size == 'h1':
       self.setStyleSheet('font-size: 14pt')
-    if size == 'h2' :
+    elif size == 'h2':
       self.setStyleSheet('font-size: 12pt')
-    if size == 'h3' :
+    elif size == 'h3':
       self.setStyleSheet('font-size: 10pt')
     if layout is not None:
       layout.addWidget(self)
     self.mouseFunction = function
     self.identifier = docID
     if tooltip != '':
       self.setToolTip(tooltip)
@@ -250,15 +253,15 @@
     text (str): text in box
     icon (str): icon: 'Information','Warning','Critical'
     style (str): css style
   """
   dialog = QMessageBox(parent)
   dialog.setWindowTitle(title)
   dialog.setText(text)
-  if icon in ['Information','Warning','Critical']:
+  if icon in {'Information', 'Warning', 'Critical'}:
     dialog.setIcon(getattr(QMessageBox, icon))
   if style!='':
     dialog.setStyleSheet(style)
   dialog.exec()
   return
```

## pasta_eln/tempStrings.py

```diff
@@ -3,45 +3,50 @@
 
 <h3>Very important show stopper</h3>
 <ul>
 </ul>
 
 <h3>Things currently working on</h3>
 <ul>
+<li> design: make the checkboxes larger!
+<li> finish ontology dialog
+<li> make markdown format correctly immediately
+<li> move folder to different folder: use unidentified for notes
+<li> not save now: when opening text files, system can crash
+<li> not save now: when opening text files, system can crash
+<li> render comment nicely without screwing up the rest
+<li> table: shift-select
 </ul>
 
 <h3>Improvement to convenience</h3>
 <ul>
-<li> design ProjectView: Currently, the comment is more highlighted than the title of an item due
-<li> design: make the checkboxes larger!
-<li> export: export via extractor in high resolution: change order: first save, then rescale
+<li> -> lambda and change buttons/actions: cleaner code
+<li> export to dataverse
 <li> extractor: creates links to sample/instrument
-<li> finish ontology dialog
 <li> form: add button to add key-values
-<li> image does not allow for easy context aware clicks
-<li> other items as non-edible things that can be copy-pasted
-<li> projectTree design: If folders and other items have boxes of slightly different brightness
-<li> projectView: if table-row click, move to view it project
-<li> projectView: selection does not scroll; one cannot select a row
-<li> table: shift-select
+<li> form: other items as non-edible things that can be copy-pasted
+<li> move all changeExtractor of this type to separate function
+<li> move all context menu of this type to separate function
 </ul>
 
 <h3>Bigger things implemented soon</h3>
 <ul>
 <li> add nice glyphs later, see also below \u00D7')
 <li> add splitter to increase / decrease image
 <li> addToConfig
 <li> can you sort for true false in tables too?
 <li> change to string-output
 <li> configuration
 <li> from config file
 <li> not sure this will be important
+<li> projectTree can select sub-folders: if table-row click, move to view it project
 <li> projectTree: allow right click on measurement to change recipe
 <li> projectTree: drag&drop of external files
 <li> projectTree: select multiple items to edit... What is use case
+<li> projectTree: selection does not scroll; one cannot select a row
 <li> redraw/reread only part of the tree
 <li> sidebar-scroll cannot figure out issue
 </ul>
 
 <h3>Things worthwile remembering/uncritical</h3>
 <ul>
 <li> allow to add more users and each user can have multiple organizations
```

## pasta_eln/widgetBody.py

```diff
@@ -1,9 +1,8 @@
 """ Central widget: everything that is not sidebar: switches between project-view and table-details """
-import logging
 from PySide6.QtWidgets import QWidget, QVBoxLayout   # pylint: disable=no-name-in-module
 from PySide6.QtCore import Slot   # pylint: disable=no-name-in-module
 
 from .widgetDocTypes import DocTypes
 from .widgetProject import Project
 from .communicate import Communicate
```

## pasta_eln/widgetDetails.py

```diff
@@ -1,15 +1,14 @@
 """ widget that shows the details of the items """
 from pathlib import Path
-import platform, subprocess, os, base64, logging
+import platform, subprocess, os, logging
 from typing import Any
 import yaml
 from PySide6.QtWidgets import QScrollArea, QLabel, QMenu, QTextEdit  # pylint: disable=no-name-in-module
 from PySide6.QtCore import Qt, Slot, QPoint  # pylint: disable=no-name-in-module
-from PySide6.QtGui import QTextDocument  # pylint: disable=no-name-in-module
 from .style import TextButton, Image, Label, Action, showMessage, widgetAndLayout
 from .fixedStrings import defaultOntologyNode
 from .communicate import Communicate
 
 class Details(QScrollArea):
   """ widget that shows the details of the items """
   def __init__(self, comm:Communicate):
@@ -23,15 +22,17 @@
     # GUI elements
     self.mainW, self.mainL = widgetAndLayout('V', None)
     self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOn)
     self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
     self.setWidgetResizable(True)
     self.setWidget(self.mainW)
 
-    _, self.headerL = widgetAndLayout('H', self.mainL, top='s')
+    headerW, self.headerL = widgetAndLayout('H', self.mainL, top='s')
+    headerW.setContextMenuPolicy(Qt.CustomContextMenu)
+    headerW.customContextMenuRequested.connect(self.contextMenu)
     self.specialW, self.specialL = widgetAndLayout('V', self.mainL, top='s')
     self.specialW.setContextMenuPolicy(Qt.CustomContextMenu)
     self.specialW.customContextMenuRequested.connect(self.contextMenu)
     self.btnDetails = TextButton('Details', self.showArea, self.mainL, 'Details', 'Show / hide details', \
                                   checkable=True, style='margin-top: 3px')
     self.metaDetailsW, self.metaDetailsL  = widgetAndLayout('V', self.mainL)
     self.metaDetailsW.setMaximumWidth(self.width())
@@ -46,65 +47,75 @@
     self.btnDatabase = TextButton('Database details', self.showArea, self.mainL, 'Database', \
       'Show / hide database details', checkable= True, style="margin-top: 15px")
     self.metaDatabaseW, self.metaDatabaseL = widgetAndLayout('V', self.mainL)
     self.metaDatabaseW.setMaximumWidth(self.width())
     self.mainL.addStretch(1)
 
 
-  def contextMenu(self, pos:QPoint) -> None:
+  def contextMenu(self, pos:QPoint) -> None: #TODO_P3 move all context menu of this type to separate function
+    # sourcery skip: extract-method
     """
     Create a context menu
 
     Args:
       pos (position): Position to create context menu at
     """
+    context = QMenu(self)
+    # for extractors
     extractors = self.comm.backend.configuration['extractors']
     extension = Path(self.doc['-branch'][0]['path']).suffix[1:]
-    extractors = extractors[extension.lower()]
-    baseDocType= self.doc['-type'][0]
-    choices= {key:value for key,value in extractors.items() \
-                if key.startswith(baseDocType)}
-    context = QMenu(self)
-    for key,value in choices.items():
-      Action(value, self.changeExtractor, context, self, name=key)
-    context.addSeparator()
-    Action('Open folder in file browser', self.changeExtractor, context, self, name='_openInFileBrowser_')
-    Action('Save as image',               self.changeExtractor, context, self, name='_saveAsImage_')
+    if extension.lower() in extractors:
+      extractors = extractors[extension.lower()]
+      baseDocType= self.doc['-type'][0]
+      choices= {key:value for key,value in extractors.items() \
+                  if key.startswith(baseDocType)}
+      for key,value in choices.items():
+        Action(value, self.changeExtractor, context, self, name=key)
+      context.addSeparator()
+      Action('Save image',                       self.changeExtractor, context, self, name='_saveAsImage_')
+    #TODO_P2 not save now: when opening text files, system can crash
+    # Action('Open file with another application', self.changeExtractor, context, self, name='_openExternal_')
+    Action('Open folder in file browser',        self.changeExtractor, context, self, name='_openInFileBrowser_')
+    Action('Hide',                               self.changeExtractor, context, self, name='_hide_')
     context.exec(self.mapToGlobal(pos))
     return
 
-  def changeExtractor(self) -> None:
+
+  def changeExtractor(self) -> None:  #TODO_P3 move all changeExtractor of this type to separate function
     """
     What happens when user changes extractor
     """
+    menuName = self.sender().data()
     filePath = Path(self.doc['-branch'][0]['path'])
-    if self.sender().data()=='_openInFileBrowser_':
+    if menuName in ['_openInFileBrowser_','_openExternal_']:
       filePath = self.comm.backend.basePath/filePath
+      filePath = filePath if menuName=='_openExternal_' else filePath.parent
       if platform.system() == 'Darwin':       # macOS
-        subprocess.call(('open', filePath.parent))
+        subprocess.call(('open', filePath))
       elif platform.system() == 'Windows':    # Windows
-        os.startfile(filePath.parent) # type: ignore[attr-defined]
+        os.startfile(filePath) # type: ignore[attr-defined]
       else:                                   # linux variants
-        subprocess.call(('xdg-open', filePath.parent))
-    elif self.sender().data()=='_saveAsImage_':
+        subprocess.call(('xdg-open', filePath))
+    elif menuName =='_saveAsImage_':
       image = self.doc['image']
       if image.startswith('data:image/'):
         imageType = image[11:14] if image[14]==';' else image[11:15]
-        image = image[22:] if image[21]==',' else image[23:]
       else:
         imageType = 'svg'
-      saveFilePath = filePath.parent/(filePath.stem+'_PastaExport.'+imageType.lower())
-      if imageType == 'svg':
-        with open(self.comm.backend.basePath/saveFilePath,'w', encoding='utf-8') as fOut:
-          fOut.write(image)
-      else:
-        with open(self.comm.backend.basePath/saveFilePath, "wb") as fOut:
-          fOut.write(base64.decodebytes(image.encode('utf-8')))
+      saveFilePath = self.comm.backend.basePath/filePath.parent/f'{filePath.stem}_PastaExport.{imageType.lower()}'
+      path = self.doc['-branch'][0]['path']
+      if not path.startswith('http'):
+        path = (self.comm.backend.basePath/path).as_posix()
+      self.comm.backend.testExtractor(path, recipe='/'.join(self.doc['-type']), saveFig=str(saveFilePath))
+    elif menuName == '_hide_':
+      self.comm.backend.db.hideShow(self.docID)
+      self.comm.changeTable.emit('','')
+      self.comm.changeDetails.emit(self.doc['_id'])
     else:
-      self.doc['-type'] = self.sender().data().split('/')
+      self.doc['-type'] = menuName.split('/')
       self.comm.backend.useExtractors(filePath, self.doc['shasum'], self.doc)  #any path is good since the file is the same everywhere; data-changed by reference
       if len(self.doc['-type'])>1 and len(self.doc['image'])>1:
         self.doc = self.comm.backend.db.updateDoc({'image':self.doc['image'], '-type':self.doc['-type']}, self.doc['_id'])
         self.comm.changeTable.emit('','')
         self.comm.changeDetails.emit(self.doc['_id'])
     return
 
@@ -127,15 +138,15 @@
   def changeDetails(self, docID:str) -> None:
     """
     What happens when details should change
 
     Args:
       docID (str): document-id; '' string=draw nothing; 'redraw' implies redraw
     """
-    logging.debug('details:changeDetails |'+docID+'|')
+    logging.debug('details:changeDetails |%s|',docID)
     # Delete old widgets from layout
     for i in reversed(range(self.headerL.count())):
       self.headerL.itemAt(i).widget().setParent(None)       # type: ignore
     for i in reversed(range(self.metaDetailsL.count())):
       self.metaDetailsL.itemAt(i).widget().setParent(None)  # type: ignore
     if self.metaVendorL.itemAt(0) is not None:
       self.metaVendorL.itemAt(0).widget().setParent(None)   # type: ignore
@@ -146,15 +157,19 @@
     for i in reversed(range(self.specialL.count())):
       self.specialL.itemAt(i).widget().setParent(None) # type: ignore
     self.specialW.hide()
     self.metaDetailsW.hide()
     self.metaVendorW.hide()
     self.metaUserW.hide()
     self.metaDatabaseW.hide()
-    if docID=='':  #if given '' docID, return
+    self.btnDetails.setChecked(True)
+    self.btnVendor.setChecked(True)
+    self.btnUser.setChecked(True)
+    self.btnDatabase.setChecked(False)
+    if not docID:  #if given '' docID, return
       return
     # Create new
     if docID!='redraw':
       self.docID = docID
     if self.docID=='':
       return
     self.doc   = self.comm.backend.db.getDoc(self.docID)
@@ -169,35 +184,35 @@
     Label(label,'h1', self.headerL)
     if 'metaVendor' not in self.doc:
       self.btnVendor.hide()
     if 'metUser' not in self.doc:
       self.btnUser.hide()
     for key in self.doc:
       size = self.comm.backend.configuration['GUI']['imageSizeDetails'] \
-              if hasattr(self.comm.backend, 'configuration') else 300
+                        if hasattr(self.comm.backend, 'configuration') else 300
       if key=='image':
         Image(self.doc['image'], self.specialL, anyDimension=size)
         self.specialW.show()
       elif key=='content':
         text = QTextEdit()
         text.setMarkdown(self.doc['content'])
         text.setFixedHeight(int(size/3*2))
         text.setReadOnly(True)
         self.specialL.addWidget(text)
         self.specialW.show()
       elif key=='-tags':
-        tags = ['_curated_' if i=='_curated' else '#'+i for i in self.doc[key]]
+        tags = ['_curated_' if i=='_curated' else f'#{i}' for i in self.doc[key]]
         tags = ['\u2605'*int(i[2]) if i[:2]=='#_' else i for i in tags]
         label = QLabel('Tags: '+' '.join(tags))
         label.setTextInteractionFlags(Qt.TextSelectableByMouse)
         self.metaDetailsL.addWidget(label)
       elif key[0] in ['_','-'] or key in ['shasum']:
         if key in ['_attachments']:
           continue
-        label = QLabel(key+': '+str(self.doc[key]))
+        label = QLabel(f'{key}: {str(self.doc[key])}')
         label.setWordWrap(True)
         label.setTextInteractionFlags(Qt.TextSelectableByMouse)
         self.metaDatabaseL.addWidget(label)
         self.btnDatabase.setChecked(False)
       elif key=='metaVendor':
         self.btnVendor.show()
         label = QLabel()
@@ -213,43 +228,49 @@
         label.setText(yaml.dump(self.doc[key], indent=4))
         label.setTextInteractionFlags(Qt.TextSelectableByMouse)
         self.metaUserL.addWidget(label)
         self.metaUserW.show()
       else:
         link = False
         ontologyItem = [i for i in ontologyNode if i['name']==key]
-        if len(ontologyItem)==1 and 'list' in ontologyItem[0]:
-          if not isinstance(ontologyItem[0]['list'], list):                #choice among docType
-            table  = self.comm.backend.db.getView('viewDocType/'+ontologyItem[0]['list'])
-            choices= [i for i in table if i['id']==self.doc[key]]
-            if len(choices)==1:
-              value = '\u260D '+choices[0]['value'][0]
-              link = True
-        elif isinstance(self.doc[key], list):
-          value = ', '.join(self.doc[key])
-        elif '\n' in self.doc[key]:     #if returns in value
-          value = '\n    '+self.doc[key].replace('\n','\n    ')
+        if '\n' in self.doc[key]:     #if returns in value: format nicely
+          _, labelL = widgetAndLayout('H', self.metaDetailsL, top='s', bottom='s')
+          labelL.addWidget(QLabel(f'{key}: '), alignment=Qt.AlignTop) # type: ignore
+          text = QTextEdit()
+          text.setMarkdown(self.doc[key])
+          text.setReadOnly(True)
+          labelL.addWidget(text)
         else:
-          value = self.doc[key]
-        label = Label(key.capitalize()+': '+value, function=self.clickLink if link else None, docID=self.doc[key])
-        label.setTextInteractionFlags(Qt.TextSelectableByMouse)
-        self.metaDetailsL.addWidget(label)
+          if len(ontologyItem)==1 and 'list' in ontologyItem[0]:
+            if not isinstance(ontologyItem[0]['list'], list):                #choice among docType
+              table  = self.comm.backend.db.getView('viewDocType/'+ontologyItem[0]['list'])
+              choices= [i for i in table if i['id']==self.doc[key]]
+              if len(choices)==1:
+                value = '\u260D '+choices[0]['value'][0]
+                link = True
+          elif isinstance(self.doc[key], list):
+            value = ', '.join(self.doc[key])
+          else:
+            value = self.doc[key]
+          label = Label(f'{key.capitalize()}: {value}', function=self.clickLink if link else None, docID=self.doc[key])
+          label.setTextInteractionFlags(Qt.TextSelectableByMouse)
+          self.metaDetailsL.addWidget(label)
         self.metaDetailsW.show()
     return
 
 
   def showArea(self) -> None:
     """
     Hide / show the widget underneath the button
     """
     name = self.sender().accessibleName()
-    if getattr(self, 'btn'+name).isChecked(): #get button in question
-      getattr(self, 'meta'+name+'W').show()
+    if getattr(self, f'btn{name}').isChecked(): #get button in question
+      getattr(self, f'meta{name}W').show()
     else:
-      getattr(self, 'meta'+name+'W').hide()
+      getattr(self, f'meta{name}W').hide()
     return
 
 
   def callEdit(self) -> None:
     """
     Call edit dialoge
     """
@@ -266,10 +287,10 @@
     """
     Click link in details
 
     Args:
       label (str): label on link
       docID (str): docID to which to link
     """
-    logging.debug('used link on '+label+'|'+docID)
+    logging.debug('used link on %s|%s',label,docID)
     self.comm.changeDetails.emit(docID)
     return
```

## pasta_eln/widgetDocTypes.py

```diff
@@ -1,23 +1,20 @@
 """ widget that shows the table and the details of the items """
-import logging
-from random import randint
-from PySide6.QtCore import Slot                                                     # pylint: disable=no-name-in-module
-from PySide6.QtWidgets import QWidget, QSplitter, QVBoxLayout, QLabel, QScrollArea  # pylint: disable=no-name-in-module
+from PySide6.QtCore import Slot                                # pylint: disable=no-name-in-module
+from PySide6.QtWidgets import QWidget, QSplitter, QVBoxLayout  # pylint: disable=no-name-in-module
 from .widgetTable import Table
 from .widgetDetails import Details
 from .communicate import Communicate
 
 class DocTypes(QWidget):
   """ widget that shows the table and the details of the items """
   def __init__(self, comm:Communicate):
     super().__init__()
     comm.changeTable.connect(self.changeTable)
     comm.changeDetails.connect(self.changeDetails)
-
     # GUI elements
     table = Table(comm)
     self.details = Details(comm)
     splitter = QSplitter()
     splitter.setHandleWidth(10)
     splitter.addWidget(table)
     splitter.addWidget(self.details)
```

## pasta_eln/widgetProject.py

```diff
@@ -1,51 +1,50 @@
 """ Widget that shows the content of project in a electronic labnotebook """
 import logging
 from typing import Optional, Any
-from PySide6.QtWidgets import QLabel, QVBoxLayout, QWidget, QMenu, QMessageBox # pylint: disable=no-name-in-module
-from PySide6.QtGui import QStandardItemModel, QStandardItem    # pylint: disable=no-name-in-module
+from PySide6.QtWidgets import QLabel, QVBoxLayout, QWidget, QMenu, QMessageBox, QTextEdit # pylint: disable=no-name-in-module
+from PySide6.QtGui import QStandardItemModel, QStandardItem   # pylint: disable=no-name-in-module
 from PySide6.QtCore import Slot, Qt, QItemSelectionModel, QModelIndex # pylint: disable=no-name-in-module
 from anytree import PreOrderIter, Node
 from .widgetProjectTreeView import TreeView
-from .style import TextButton, Action, Label, showMessage, widgetAndLayout
+from .style import TextButton, IconButton, Action, Label, showMessage, widgetAndLayout, iconsDocTypes
 from .miscTools import createDirName
 from .communicate import Communicate
 
 class Project(QWidget):
   """ Widget that shows the content of project in a electronic labnotebook """
   def __init__(self, comm:Communicate):
     super().__init__()
     self.comm = comm
     comm.changeProject.connect(self.changeProject)
     self.mainL = QVBoxLayout()
     self.setLayout(self.mainL)
     self.tree:Optional[TreeView]             = None
     self.model:Optional[QStandardItemModel]  = None
-    self.bodyW:Optional[QWidget]             = None
+    self.infoW:Optional[QWidget]             = None
     self.projID = ''
     self.taskID = ''
     self.docProj:dict[str,Any]= {}
     self.showAll= False
     self.foldedAll = False
     self.btnAddSubfolder:Optional[TextButton] = None
-    self.btnHideShow:Optional[TextButton]     = None
     self.maxHeight = 300  #TODO_P4 configuration
     self.maxWidth  = 1024
 
 
   @Slot(str, str)
   def changeProject(self, projID:str, docID:str) -> None:
     """
     What happens when user clicks to change doc-type
 
     Args:
       projID (str): document id of project; if empty, just refresh
       docID (str): document id of focus item, if not given focus at project
     """
-    logging.debug('project:changeProject |'+projID+'|'+docID+'|')
+    logging.debug('project:changeProject |%s|%s|',projID,docID)
     #initialize
     for i in reversed(range(self.mainL.count())): #remove old
       self.mainL.itemAt(i).widget().setParent(None)  # type: ignore
     if projID!='':
       self.projID         = projID
       self.taskID         = docID
       self.comm.projectID = projID
@@ -62,115 +61,130 @@
       if node.is_root:         #Project header
         self.projHeader()
       else:
         rootItem.appendRow(self.iterateTree(node))
     # self.tree.expandAll()
     if selectedIndex is not None:
       self.tree.selectionModel().select(selectedIndex, QItemSelectionModel.Select)
-      #TODO_P3 projectView: selection does not scroll; one cannot select a row
+      #TODO_P4 projectTree: selection does not scroll; one cannot select a row
       self.tree.setCurrentIndex(selectedIndex)# Item(selectedItem)
     self.mainL.addWidget(self.tree)
     if len(nodeHier.children)>0 and self.btnAddSubfolder is not None:
       self.btnAddSubfolder.setVisible(False)
-    elif self.btnHideShow is not None:
-      self.btnHideShow.setVisible(False)
     return
 
 
   def modelChanged(self, item:QStandardItem) -> None:
     """
     After drag-drop, record changes to backend and database directly
 
     Args:
       item (QStandardItem): item changed, new location
     """
     #gather old information
     db       = self.comm.backend.db
     stackOld = item.text().split('/')[:-1]
     docID    = item.text().split('/')[-1]
+    maximized = True
     if docID.endswith(' -'):
       docID = docID[:-2]
+      maximized = False
     doc      = db.getDoc(docID)
     if '-branch' not in doc:
       return
     branchOldList= [i for i in doc['-branch'] if i['stack']==stackOld]
     if len(branchOldList)!=1:
       self.changeProject('','')
       return
     branchOld = branchOldList[0]
     childOld = branchOld['child']
     branchIdx= doc['-branch'].index(branchOld)
     siblingsOld = db.getView('viewHierarchy/viewHierarchy', startKey=' '.join(stackOld))
     siblingsOld = [i for i in siblingsOld if len(i['key'].split(' '))==len(stackOld)+1 and \
-                                            i['value'][0]>branchOld['child'] and i['value'][0]<9999]
+                                                  i['value'][0]>branchOld['child'] and i['value'][0]<9999]
     #gather new information
     stackNew = []  #create reversed
     currentItem = item
     while currentItem.parent() is not None:
       currentItem = currentItem.parent()
       docIDj = currentItem.text().split('/')[-1]
       stackNew.append(docIDj[:-2] if docIDj.endswith(' -') else docIDj)
     stackNew = [self.projID] + stackNew[::-1]  #add project id and reverse
     childNew = item.row()
-    dirNameNew= createDirName(doc['-name'],doc['-type'][0],childNew)
-    parentDir = db.getDoc(stackNew[-1])['-branch'][0]['path']
-    pathNew  = parentDir+'/'+dirNameNew
+    if not branchOld['path'].startswith('http'):
+      dirNameNew= createDirName(doc['-name'],doc['-type'][0],childNew)
+      parentDir = db.getDoc(stackNew[-1])['-branch'][0]['path']
+      pathNew = f'{parentDir}/{dirNameNew}'
+    else:
+      pathNew = branchOld['path']
     siblingsNew = db.getView('viewHierarchy/viewHierarchy', startKey=' '.join(stackNew))
     siblingsNew = [i for i in siblingsNew if len(i['key'].split(' '))==len(stackNew)+1 and \
-                                             i['value'][0]>=childNew and i['value'][0]<9999]
-    logging.debug('Change project: docID -old- -new- '+docID+' | '+str(stackOld)+'  '+str(branchIdx)+' | '+str(stackNew)+' '+str(childNew)+' '+pathNew)
+                                                   i['value'][0]>=childNew and i['value'][0]<9999]
+    logging.debug('Change project: docID -old- -new- %s|%s  %i|%s %i %s', docID, str(stackOld), branchIdx, str(stackNew), childNew, pathNew)
     if stackOld==stackNew and childOld==childNew:  #nothing changed, just redraw
       return
     # change item in question
     db.updateBranch(docID=docID, branch=branchIdx, stack=stackNew, path=pathNew, child=childNew)
-    item.setText('/'.join(stackNew+[docID]))     #update item.text() to new stack
+    item.setText('/'.join(stackNew+[docID]) if maximized else '/'.join(stackNew+[docID+' -']) )     #update item.text() to new stack
     # change siblings
     for line in siblingsOld:
       db.updateBranch(docID=line['id'], branch=line['value'][3], child=line['value'][0]-1)
     for line in siblingsNew:
       if line['id']!=docID:
         db.updateBranch(docID=line['id'], branch=line['value'][3], child=line['value'][0]+1)
     return
 
 
   def projHeader(self) -> None:
     """
     Create header of page
     """
     self.docProj = self.comm.backend.db.getDoc(self.projID)
-    _, headerL       = widgetAndLayout('H',self.mainL)
-    infoW, infoL         = widgetAndLayout('V', headerL)
-    infoW.setMaximumWidth(self.maxWidth)
-    infoW.setMaximumHeight(self.maxHeight)
-    buttonW, buttonL = widgetAndLayout('H', spacing='m')
-    headerL.addStretch(1)
-    headerL.addWidget(buttonW, alignment=Qt.AlignTop)  # type: ignore
+    _, topLineL       = widgetAndLayout('H',self.mainL)  #topLine includes name on left, buttons on right
+    hidden = '     \U0001F441' if [b for b in self.docProj['-branch'] if False in b['show']] else ''
+    topLineL.addWidget(Label(self.docProj['-name']+hidden, 'h2'))
+    topLineL.addStretch(1)
 
-    self.btnHideShow     = TextButton('Hide/Show',     self.executeAction, buttonL, name='hideShow')
+    buttonW, buttonL = widgetAndLayout('H', spacing='m')
+    topLineL.addWidget(buttonW, alignment=Qt.AlignTop)  # type: ignore
     self.btnAddSubfolder = TextButton('Add subfolder', self.executeAction, buttonL, name='addChild')
     TextButton('Edit project',      self.executeAction, buttonL, name='editProject')
+    visibility = TextButton('Visibility',None, buttonL)
+    visibilityMenu = QMenu(self)
+    Action('Hide/show project details', self.executeAction, visibilityMenu, self, name='projReduceWidth')
+    Action('Hide/show hidden subitems', self.executeAction, visibilityMenu, self, name='hideShow')
+    Action('Hide/show entire project',  self.executeAction, visibilityMenu, self, name='projHideShow')
+    Action('Minimize/Maximize subitems',self.executeAction, visibilityMenu, self, name='allFold')
+    visibility.setMenu(visibilityMenu)
     more = TextButton('More',None, buttonL)
     moreMenu = QMenu(self)
-    Action('Reduce/increase width', self.executeAction, moreMenu, self, name='projReduceWidth')
-    Action('Hide/show project',     self.executeAction, moreMenu, self, name='projHideShow')
-    Action('Minimize/Maximize all', self.executeAction, moreMenu, self, name='allFold')
     Action('Scan',                  self.executeAction, moreMenu, self, name='scanProject')
+    for doctype in self.comm.backend.db.dataLabels:
+      if doctype[0]!='x':
+        icon = iconsDocTypes[self.comm.backend.db.dataLabels[doctype]]
+        Action(f'table of {doctype}', self.executeAction, moreMenu, self, name=f'_doctype_{doctype}', icon=icon)
+    Action('table of unidentified', self.executeAction, moreMenu, self, name='_doctype_-', icon=iconsDocTypes['-'])
+    moreMenu.addSeparator()
     Action('Delete',                self.executeAction, moreMenu, self, name='deleteProject')
     more.setMenu(moreMenu)
 
-    self.bodyW, bodyL =  widgetAndLayout('V')
-    hidden = '     \U0001F441' if len([b for b in self.docProj['-branch'] if False in b['show']])>0 else ''
-    infoL.addWidget(Label(self.docProj['-name']+hidden, 'h2'))
-    tags = ', '.join(self.docProj['tags']) if 'tags' in self.docProj else ''
-    bodyL.addWidget(QLabel('Tags: '+tags))
+    self.infoW, infoL         = widgetAndLayout('V', self.mainL)
+    tags = ', '.join([f'#{i}' for i in self.docProj['-tags']]) if '-tags' in self.docProj else ''
+    infoL.addWidget(QLabel(f'Tags: {tags}'))
     for key,value in self.docProj.items():
-      if key[0] in ['_','-']:
+      if key[0] in ['_','-'] or (key=='comment' and '\n' in value):
         continue
-      bodyL.addWidget(QLabel(key+': '+str(value)))
-    infoL.addWidget(self.bodyW)
+      infoL.addWidget(QLabel(f'{key}: {str(value)}'))
+    if 'comment' in self.docProj and '\n' in self.docProj['comment']:     #format nicely
+      # comment = QTextEdit()  #TODO_P2 render comment nicely without screwing up the rest
+      # comment.setMarkdown(self.docProj['comment'])
+      # comment.setReadOnly(True)
+      # comment.setFixedHeight(200)
+      # infoL.addWidget(comment)
+      infoL.addWidget(QLabel(self.docProj['comment']))
     return
 
 
   #TODO_P4 projectTree: select multiple items to edit... What is use case
   #TODO_P4 projectTree: allow right click on measurement to change recipe
   def executeAction(self) -> None:
     """ Any action by the buttons at the top of the page """
@@ -184,15 +198,15 @@
       #collect information and then change
       oldPath = self.comm.backend.basePath/self.docProj['-branch'][0]['path']
       if oldPath.exists():
         newPath = self.comm.backend.basePath/createDirName(self.docProj['-name'],'x0',0)
         oldPath.rename(newPath)
     elif menuName=='deleteProject':
       ret = QMessageBox.critical(self, 'Warning', 'Are you sure you want to delete project?',\
-                                 QMessageBox.StandardButton.Yes, QMessageBox.StandardButton.No)
+                                   QMessageBox.StandardButton.Yes, QMessageBox.StandardButton.No)
       if ret==QMessageBox.StandardButton.Yes:
         #delete database and rename folder
         doc = self.comm.backend.db.remove(self.projID)
         if '-branch' in doc and len(doc['-branch'])>0 and 'path' in doc['-branch'][0]:
           oldPath = self.comm.backend.basePath/doc['-branch'][0]['path']
           newPath = self.comm.backend.basePath/('trash_'+doc['-branch'][0]['path'])
           oldPath.rename(newPath)
@@ -200,44 +214,46 @@
         self.comm.changeSidebar.emit('redraw')
         self.comm.changeTable.emit('x0','')
     elif menuName == 'scanProject':
       self.comm.backend.scanProject(self.comm.progressBar, self.projID, self.docProj['-branch'][0]['path'])
       self.comm.changeSidebar.emit('redraw')
       showMessage(self, 'Information','Scanning finished')
     elif menuName == 'projReduceWidth':
-      if self.bodyW is not None and self.bodyW.isHidden():
-        self.bodyW.show()
-      elif self.bodyW is not None:
-        self.bodyW.hide()
+      if self.infoW is not None and self.infoW.isHidden():
+        self.infoW.show()
+      elif self.infoW is not None:
+        self.infoW.hide()
     elif menuName == 'projHideShow':
       self.comm.backend.db.hideShow(self.projID)
       self.comm.changeProject.emit('','') #refresh project
     elif menuName == 'allFold' and self.tree is not None:
       self.foldedAll = not self.foldedAll
       def recursiveRowIteration(index:QModelIndex) -> None:
         if self.tree is not None:
           for subRow in range(self.tree.model().rowCount(index)):
             subIndex = self.tree.model().index(subRow,0, index)
             subItem  = self.tree.model().itemFromIndex(subIndex)
             if self.foldedAll:
-              subItem.setText(subItem.text()+' -')
+              subItem.setText(f'{subItem.text()} -')
             elif subItem.text().endswith(' -'):
               subItem.setText(subItem.text()[:-2])
             recursiveRowIteration(subIndex)
         return
       recursiveRowIteration(self.tree.model().index(-1,0))
     elif menuName == 'hideShow':
       self.showAll = not self.showAll
       self.changeProject('','')
     elif menuName == 'addChild':
       self.comm.backend.cwd = self.comm.backend.basePath/self.docProj['-branch'][0]['path']
       self.comm.backend.addData('x1', {'-name':'new folder'}, [self.projID])
       self.comm.changeProject.emit('','') #refresh project
+    elif menuName.startswith('_doctype_'):
+      self.comm.changeTable.emit(menuName[9:], self.projID)
     else:
-      print("undefined menu / action",menuName)
+      print(f"undefined menu / action |{menuName}|")
     return
 
 
   def iterateTree(self, nodeHier:Node) -> QStandardItem:
     """
     Recursive function to translate the hierarchical node into a tree-node
 
@@ -254,10 +270,10 @@
       nodeTree.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsDragEnabled | Qt.ItemIsDropEnabled) # type: ignore
     else:
       nodeTree.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsDragEnabled) # type: ignore
     children = []
     for childHier in nodeHier.children:
       childTree = self.iterateTree(childHier)
       children.append(childTree)
-    if len(children)>0:
+    if children:
       nodeTree.appendRows(children)
     return nodeTree
```

## pasta_eln/widgetProjectLeafRenderer.py

```diff
@@ -1,10 +1,10 @@
 """ renders each leaf of project tree using QPaint """
 import base64, logging, re
-from typing import Optional
+from typing import Optional, Any
 from PySide6.QtCore import Qt, QSize, QPoint, QMargins, QRectF, QModelIndex# pylint: disable=no-name-in-module
 from PySide6.QtGui import QStaticText, QPixmap, QTextDocument, QPainter, QColor, QPen # pylint: disable=no-name-in-module
 from PySide6.QtWidgets import QStyledItemDelegate, QStyleOptionViewItem # pylint: disable=no-name-in-module
 from PySide6.QtSvg import QSvgRenderer                        # pylint: disable=no-name-in-module
 from .communicate import Communicate
 from .style import getColor
 
@@ -16,94 +16,101 @@
     super().__init__()
     self.comm = comm
     self.debugMode = logging.root.level<logging.INFO
     self.widthImage = self.comm.backend.configuration['GUI']['imageWidthProject']
     self.widthContent = 600   #TODO_P4 from config file
     self.lineSep = 20
     self.frameSize = 6
-    self.maxHeight = 300
+    self.maxHeight = 250
+    self.docTypeOffset = 500
     self.penDefault:Optional[QPen] = None
     self.penHighlight              = QPen(QColor(getColor(self.comm.backend, 'primary')))
     self.penHighlight.setWidth(2)
     self.colorMargin1 = QColor(getColor(self.comm.backend, 'secondary')).darker(110)
     self.colorMargin2 = QColor(getColor(self.comm.backend, 'secondaryLight'))
 
 
-  #TODO_P3 projectTree design: If folders and other items have boxes of slightly different brightness
-  # (darker gray for the former and lighter for the latter), the project structure might be easier to understand.
   def paint(self, painter:QPainter, option:QStyleOptionViewItem, index:QModelIndex) -> None:
     """
     Paint this item
     - coordinates: left, top
     - COS top left
 
     Args:
       painter (QPainter): painter
       option (QStyleOptionViewItem): option incl. current coordinates
       index (QModelIndex): index
     """
-    if self.comm is None:
-      return
-    if self.penDefault is None:
-      self.penDefault = QPen(painter.pen())
-    x0, y0 = option.rect.topLeft().toTuple()
-    topLeft2nd     = option.rect.topRight()   - QPoint(self.widthImage+self.frameSize+1,-self.frameSize)
-    bottomRight2nd = option.rect.bottomRight()- QPoint(self.frameSize+1,self.frameSize)
-    painter.fillRect(option.rect.marginsRemoved(QMargins(2,6,4,0)),  self.colorMargin1)
-    painter.fillRect(option.rect.marginsRemoved(QMargins(-2,3,8,5)), self.colorMargin2)
     hierStack = index.data(Qt.DisplayRole) # type: ignore
-    if hierStack is None:
+    if hierStack is None or self.comm is None:
       return
     docID   = hierStack.split('/')[-1]
     if docID.endswith(' -'):
       docID = docID[:-2]
       folded = True
     else:
       folded = False
     doc     = self.comm.backend.db.getDoc(docID)
+    if len(doc)<2:
+      print(f'**ERROR cannot read docID: {docID}')
+      logging.error('LeafRenderer: Cannot read docID %s',docID)
+      return
+    # GUI
+    if self.penDefault is None:
+      self.penDefault = QPen(painter.pen())
+    x0, y0 = option.rect.topLeft().toTuple()
+    topLeft2nd     = option.rect.topRight()   - QPoint(self.widthImage+self.frameSize+1,-self.frameSize)
+    bottomRight2nd = option.rect.bottomRight()- QPoint(self.frameSize+1,self.frameSize)
+    painter.fillRect(option.rect.marginsRemoved(QMargins(2,6,4,0)),  self.colorMargin1)
+    if doc['-type'][0][0]=='x':
+      painter.fillRect(option.rect.marginsRemoved(QMargins(-2,3,8,5)), self.colorMargin2.darker(102))
+    else:
+      painter.fillRect(option.rect.marginsRemoved(QMargins(-2,3,8,5)), self.colorMargin2.lighter(210))
     # header
     y = self.lineSep/2
-    hiddenText = '     \U0001F441' if len([b for b in doc['-branch'] if False in b['show']])>0 else ''
+    hiddenText = ('     \U0001F441' if [b for b in doc['-branch'] if False in b['show']] else '')
     docTypeText= 'folder' if doc['-type'][0][0]=='x' else '/'.join(doc['-type'])
     nameText = doc['-name'] if len(doc['-name'])<55 else '...'+doc['-name'][-50:]
-    painter.drawStaticText(x0, y0+y, QStaticText(nameText+hiddenText))
-    painter.drawStaticText(x0+400, y0+y, QStaticText(docTypeText))
+    staticText = QStaticText(f'<strong>{nameText}{hiddenText}</strong>')
+    staticText.setTextWidth(self.docTypeOffset)
+    painter.drawStaticText(x0, y0+y, staticText)
+    painter.drawStaticText(x0+self.docTypeOffset, y0+y, QStaticText(docTypeText))
     if self.debugMode:
       painter.drawStaticText(x0+700, y0+y, QStaticText(index.data(Qt.DisplayRole)))  # type: ignore
     if folded:  #stop drawing after first line
       return
     # body
     width, height = -1, -1
     if '-tags' in doc and len(doc['-tags'])>0:
       y += self.lineSep
-      tags = ['_curated_' if i=='_curated' else '#'+i for i in doc['-tags']]
+      tags = ['_curated_' if i=='_curated' else f'#{i}' for i in doc['-tags']]
       tags = ['\u2605'*int(i[2]) if i[:2]=='#_' else i for i in tags]
       painter.drawStaticText(x0, y0+y, QStaticText('Tags: '+' '.join(tags)))
     for key in doc:
       if key in _DO_NOT_RENDER_ or key[0] in ['-','_']:
         continue
       y += self.lineSep
       if isinstance(doc[key], str):
         if re.match(r'^[a-z\-]-[a-z0-9]{32}$',doc[key]) is None:  #normal text
           value = doc[key]
-        elif self.comm is not None:                           #link
-          table  = self.comm.backend.db.getView('viewDocType/'+key+'All')
+        elif self.comm is not None:                     #link
+          table = self.comm.backend.db.getView(f'viewDocType/{key}All')
           choices= [i for i in table if i['id']==doc[key]]
           if len(choices)==1:
             value = '\u260D '+choices[0]['value'][0]
           else:
             value = 'ERROR WITH LINK'
-        painter.drawStaticText(x0, y0+y, QStaticText(key+': '+value))
-      elif isinstance(doc[key], list):                         #list of qrCodes
-        painter.drawStaticText(x0, y0+y, QStaticText(key+': '+', '.join(doc[key])))
+        painter.drawStaticText(x0, y0+y, QStaticText(f'{key}: {value}'))
+      elif isinstance(doc[key], list):                     #list of qrCodes
+        painter.drawStaticText(x0, y0+y, QStaticText(f'{key}: ' + ', '.join(doc[key])))
     for textType in ['comment', 'content']:
-      if textType in doc and (textType!='content' or not ('image' in doc and doc['image']!='')):
+      if textType in doc and (textType != 'content' or 'image' not in doc or doc['image'] == ''):
         textDoc = QTextDocument()
         text = doc[textType].replace('\n# ','\n### ').replace('\n## ','\n### ')
-        text = '##'+text if text.startswith('# ') else text
+        text = f'##{text}' if text.startswith('# ') else text
         textDoc.setMarkdown(text.strip())
         if textType == 'comment':
           textDoc.setTextWidth(bottomRight2nd.toTuple()[0]-x0-self.widthContent-2*self.frameSize)
           width, height = textDoc.size().toTuple() # type: ignore
           painter.translate(QPoint(x0-3, y0+y+15))
           yMax = int(self.maxHeight-2*self.frameSize-y-15)
         else:
@@ -121,66 +128,72 @@
         if textType == 'comment':
           painter.translate(-QPoint(x0-3, y0+y+15))
         else:
           topLeftContent = option.rect.topRight() - QPoint(width+self.frameSize-2,-self.frameSize)
           painter.translate(-topLeftContent)
     if 'image' in doc and doc['image']!='':
       if doc['image'].startswith('data:image/'):
-        pixmap = QPixmap()
-        pixmap.loadFromData(base64.b64decode(doc['image'][22:]))
-        pixmap = pixmap.scaledToWidth(self.widthImage)
+        pixmap = self.imageFromDoc(doc)
         painter.drawPixmap(topLeft2nd, pixmap)
       elif doc['image'].startswith('<?xml'):
         image = QSvgRenderer(bytearray(doc['image'], encoding='utf-8'))
         image.render(painter,    QRectF(topLeft2nd, bottomRight2nd))
     return
 
 
   def sizeHint(self, option:QStyleOptionViewItem, index:QModelIndex) -> QSize:
+    # sourcery skip: de-morgan, merge-assign-and-aug-assign
     """
     determine size of this leaf
     """
-    if index:
-      hierStack = index.data(Qt.DisplayRole)  # type: ignore
-      if hierStack is None or self.comm is None:
-        return QSize()
-      docID   = hierStack.split('/')[-1]
-      if docID.endswith(' -'):
-        return QSize(400, self.lineSep*2)
-      doc = self.comm.backend.db.getDoc(docID)
-      if len(doc)<2:
-        self.comm.changeProject.emit('','')  #TODO_P4 redraw/reread only part of the tree
-        return QSize()
-      docKeys = doc.keys()
-      height  = len([i for i in docKeys if not i in _DO_NOT_RENDER_ and i[0] not in ['-','_'] ])  #height in text lines
-      height += 1 if '-tags' in docKeys and len(doc['-tags'])>0 else 0
-      height  = (height+3) * self.lineSep
-      if 'content' in docKeys:
-        text = QTextDocument()
-        text.setMarkdown(doc['content'])
-        text.setTextWidth(self.widthContent)
-        height = max(height, text.size().toTuple()[1]) +2*self.frameSize # type: ignore
-      elif 'image' in docKeys:
-        if doc['image'].startswith('data:image/'):
-          pixmap = QPixmap()
-          pixmap.loadFromData(base64.b64decode(doc['image'][22:]))
-          pixmap = pixmap.scaledToWidth(self.widthImage)
-          height = max(height, pixmap.height())+2*self.frameSize
-        else:
-          height = max(height, int(self.widthImage*3/4))+2*self.frameSize
-      elif 'comment' in doc.keys() and len(doc['comment'])>0:
-        text = QTextDocument()
-        comment = doc['comment']
-        text.setMarkdown(comment.strip())
-        text.setTextWidth(self.widthContent)
-        height += text.size().toTuple()[1] # type: ignore
-        height -= 25
+    if not index:
+      return QSize()
+    hierStack = index.data(Qt.DisplayRole)  # type: ignore
+    if hierStack is None or self.comm is None:
+      return QSize()
+    docID   = hierStack.split('/')[-1]
+    if docID.endswith(' -'):
+      return QSize(400, self.lineSep*2)
+    doc = self.comm.backend.db.getDoc(docID)
+    if len(doc)<2:
+      self.comm.changeProject.emit('','')  #TODO_P4 redraw/reread only part of the tree
+      return QSize()
+    docKeys = doc.keys()
+    height  = len([i for i in docKeys if not i in _DO_NOT_RENDER_ and i[0] not in ['-','_'] ])  #height in text lines
+    height += 1 if '-tags' in docKeys and len(doc['-tags']) > 0 else 0
+    height  = (height+3) * self.lineSep
+    if 'content' in docKeys:
+      text = QTextDocument()
+      text.setMarkdown(doc['content'])
+      text.setTextWidth(self.widthContent)
+      height = max(height, text.size().toTuple()[1]) +2*self.frameSize # type: ignore
+    elif 'image' in docKeys:
+      if doc['image'].startswith('data:image/'):
+        pixmap = self.imageFromDoc(doc)
+        height = max(height, pixmap.height())+2*self.frameSize
       else:
-        height -= 25
-      return QSize(400, min(height, self.maxHeight))
-    return QSize()
-
-    #TODO_P3 design ProjectView: Currently, the comment is more highlighted than the title of an item due
-    # to a larger and bolder font. It would make more sense though if the titles were bolder, larger and
-    # thus more readable, while tags and comments are less highlighted.
-    # !! Comments are not rendered perfectly: the end sucks, and I cannot blue a consistent blue line at end
-    #  - rendering might not be the best option
+        height = max(height, int(self.widthImage*3/4))+2*self.frameSize
+    elif 'comment' in doc.keys() and len(doc['comment'])>0:
+      text = QTextDocument()
+      comment = doc['comment']
+      text.setMarkdown(comment.strip())
+      text.setTextWidth(self.widthContent)
+      height += text.size().toTuple()[1] # type: ignore
+      height -= 25
+    else:
+      height -= 25
+    return QSize(400, min(height, self.maxHeight))
+
+
+  def imageFromDoc(self, doc:dict[str,Any]) -> QPixmap:
+    """ Create image from image in doc
+
+    Args:
+      doc (dict): document
+
+    Returns:
+      QPixmap: image
+    """
+    result = QPixmap()
+    result.loadFromData(base64.b64decode(doc['image'][22:]))
+    result = result.scaledToWidth(self.widthImage)
+    return result
```

### encoding

```diff
@@ -1 +1 @@
-utf-8
+us-ascii
```

## pasta_eln/widgetProjectTreeView.py

```diff
@@ -12,91 +12,95 @@
   """ Custom tree view on data model """
   def __init__(self, parent:QWidget, comm:Communicate, model:QStandardItemModel):
     super().__init__(parent)
     self.comm = comm
     self.setModel(model)
     self.setHeaderHidden(True)
     self.setStyleSheet('QTreeView::branch {border-image: none;}')
-    self.setIndentation(50)
+    self.setIndentation(40)
     self.renderer = ProjectLeafRenderer(self.comm)
     self.setItemDelegate(self.renderer)
     self.setDragDropMode(QAbstractItemView.InternalMove)
     self.doubleClicked.connect(self.treeDoubleClicked)
 
 
   def contextMenuEvent(self, p:QPoint) -> None:
     """
     create context menu
 
     Args:
       p (QPoint): point of clicking
     """
+    folder = self.currentIndex().data().split('/')[-1][0]=='x'
     context = QMenu(self)
-    Action('Add child folder',   self.executeAction, context, self, name='addChild')
+    if folder:
+      Action('Add child folder',   self.executeAction, context, self, name='addChild')
     Action('Add sibling folder', self.executeAction, context, self, name='addSibling')
-    Action('Remove item',        self.executeAction, context, self, name='del')
+    Action('Delete item',        self.executeAction, context, self, name='del')
     context.addSeparator()
     Action('Minimize/Maximize',  self.executeAction, context, self, name='fold')
     Action('Hide',               self.executeAction, context, self, name='hide')
     context.addSeparator()
-    Action('Open with another application', self.executeAction, context, self, name='openExternal')
+    if not folder:
+      Action('Open file with another application', self.executeAction, context, self, name='openExternal')
+    Action('Open folder in file browser', self.executeAction, context, self, name='openFileBrowser')
     context.exec(p.globalPos())
     return
 
+
   #TODO_P4 projectTree: drag&drop of external files
   def executeAction(self) -> None:
+    # sourcery skip: extract-duplicate-method, extract-method
     """ after selecting a item from context menu """
     menuName = self.sender().data()
+    hierStack = self.currentIndex().data().split('/')
     if menuName=='addChild':
-      hierStack = self.currentIndex().data().split('/')
-      if hierStack[-1][0]=='x':
-        docType= 'x'+str(len(hierStack))
-        docID = hierStack[-1][:-2] if hierStack[-1].endswith(' -') else hierStack[-1]
-        self.comm.backend.cwd = Path(self.comm.backend.db.getDoc(docID)['-branch'][0]['path'])
-        docID = self.comm.backend.addData(docType, {'-name':'new folder'}, hierStack)
-        # append item to the GUI
-        item  = self.model().itemFromIndex(self.currentIndex())
-        child = QStandardItem('/'.join(hierStack+[docID]))
-        child.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsDragEnabled | Qt.ItemIsDropEnabled) # type: ignore
-        item.appendRow(child)
-        #appendRow is not 100% correct:
-        # - better: insertRow before the first non-folder, depending on the child number
-        #   -> get highest non 9999 childNumber
-        # turns out, one can easily move it to correct position with drag&drop
-        # TODO_P4 not sure this will be important
-      else:
-        showMessage(self, 'Error', 'You cannot create a child of a non-folder!')
+      docType= f'x{len(hierStack)}'
+      docID = hierStack[-1][:-2] if hierStack[-1].endswith(' -') else hierStack[-1]
+      self.comm.backend.cwd = Path(self.comm.backend.db.getDoc(docID)['-branch'][0]['path'])
+      docID = self.comm.backend.addData(docType, {'-name':'new folder'}, hierStack)
+      # append item to the GUI
+      item  = self.model().itemFromIndex(self.currentIndex())
+      child = QStandardItem('/'.join(hierStack+[docID]))
+      child.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsDragEnabled | Qt.ItemIsDropEnabled) # type: ignore
+      item.appendRow(child)
+      #appendRow is not 100% correct:
+      # - better: insertRow before the first non-folder, depending on the child number
+      #   -> get highest non 9999 childNumber
+      # turns out, one can easily move it to correct position with drag&drop
+      # TODO_P4 not sure this will be important
     elif menuName=='addSibling':
-      hierStack= self.currentIndex().data().split('/')[:-1]
-      docType= 'x'+str(len(hierStack))
+      hierStack= hierStack[:-1]
+      docType= f'x{len(hierStack)}'
       docID = hierStack[-1][:-2] if hierStack[-1].endswith(' -') else hierStack[-1]
       self.comm.backend.cwd = Path(self.comm.backend.db.getDoc(docID)['-branch'][0]['path'])
       docID = self.comm.backend.addData(docType, {'-name':'new folder'}, hierStack)
       # append item to the GUI
       item  = self.model().itemFromIndex(self.currentIndex())
       parent = item.parent() if item.parent() is not None else self.model().invisibleRootItem()
       child = QStandardItem('/'.join(hierStack+[docID]))
       child.setFlags(Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsDragEnabled | Qt.ItemIsDropEnabled) # type: ignore
       parent.appendRow(child)
       #++ TODO appendRow is not 100% correct: see above
     elif menuName=='del':
       ret = QMessageBox.critical(self, 'Warning', 'Are you sure you want to delete this data?',\
-                                QMessageBox.StandardButton.Yes, QMessageBox.StandardButton.No)
+                                 QMessageBox.StandardButton.Yes, QMessageBox.StandardButton.No)
       if ret==QMessageBox.StandardButton.Yes:
-        docID = self.currentIndex().data().split('/')[-1]
+        docID = hierStack[-1]
         doc = self.comm.backend.db.remove(docID)
         for branch in doc['-branch']:
           oldPath = Path(self.comm.backend.basePath)/branch['path']
           if oldPath.exists():
-            if (oldPath.parent/('trash_'+oldPath.name)).exists():  #ensure target does not exist
+            newFileName = f'trash_{oldPath.name}'
+            if (oldPath.parent/newFileName).exists():  #ensure target does not exist
               endText = ' was marked for deletion. Save it or its content now to some place on harddisk. It will be deleted now!!!'
-              showMessage(self, 'Warning', 'Warning! \nThe folder '+str(oldPath.parent/('trash_'+oldPath.name))+endText)
-              if (oldPath.parent/('trash_'+oldPath.name)).exists():
-                shutil.rmtree(oldPath.parent/('trash_'+oldPath.name))
-            oldPath.rename( oldPath.parent/('trash_'+oldPath.name) )
+              showMessage(self, 'Warning', f'Warning! \nThe folder {oldPath.parent/newFileName}{endText}')
+              if (oldPath.parent/newFileName).exists():
+                shutil.rmtree(oldPath.parent/newFileName)
+            oldPath.rename( oldPath.parent/newFileName)
         # go through children
         children = self.comm.backend.db.getView('viewHierarchy/viewHierarchy', startKey=' '.join(doc['-branch'][0]['stack']+[docID,'']))
         for line in children:
           self.comm.backend.db.remove(line['id'])
         # remove leaf from GUI
         item  = self.model().itemFromIndex(self.currentIndex())
         parent = item.parent()
@@ -104,22 +108,22 @@
           parent = self.model().invisibleRootItem()
         parent.removeRow(item.row())
     elif menuName=='fold':
       item = self.model().itemFromIndex(self.currentIndex())
       if item.text().endswith(' -'):
         item.setText(item.text()[:-2])
       else:
-        item.setText(item.text()+' -')
+        item.setText(f'{item.text()} -')
     elif menuName=='hide':
-      stack = self.currentIndex().data().split('/')
-      logging.debug('hide stack '+str(stack))
-      self.comm.backend.db.hideShow(stack)
+      logging.debug('hide stack %s',str(hierStack))
+      self.comm.backend.db.hideShow(hierStack)
       self.comm.changeProject.emit('','') #refresh project
-    elif menuName=='openExternal':
-      docID = self.currentIndex().data().split('/')[-1]
+    elif menuName in ['openExternal', 'openFileBrowser']:
+      # depending if non-folder / folder; address different item in hierstack
+      docID = hierStack[-2] if menuName=='openFileBrowser' and hierStack[-1][0]!='x' else hierStack[-1]
       doc   = self.comm.backend.db.getDoc(docID[:-2] if docID.endswith(' -') else docID)
       if doc['-branch'][0]['path'] is None:
         showMessage(self, 'ERROR', 'Cannot open file that is only in the database','Warning')
       else:
         path  = Path(self.comm.backend.basePath)/doc['-branch'][0]['path']
         if platform.system() == 'Darwin':       # macOS
           subprocess.call(('open', path))
```

## pasta_eln/widgetSidebar.py

```diff
@@ -1,13 +1,12 @@
 """ Sidebar widget that includes the navigation items """
 from PySide6.QtGui import QResizeEvent                                                                 # pylint: disable=no-name-in-module
 from PySide6.QtWidgets import QWidget, QVBoxLayout, QTreeWidget, QTreeWidgetItem, QFrame, QProgressBar # pylint: disable=no-name-in-module
 from PySide6.QtCore import Slot                                                                        # pylint: disable=no-name-in-module
 from anytree import PreOrderIter, Node
-
 from .dialogConfig import Configuration
 from .style import TextButton, IconButton, getColor, showMessage, widgetAndLayout, space, iconsDocTypes
 from .communicate import Communicate
 
 class Sidebar(QWidget):
   """ Sidebar widget that includes the navigation items """
   def __init__(self, comm:Communicate):
@@ -57,74 +56,76 @@
     for i in reversed(range(self.projectsListL.count())):
       self.projectsListL.itemAt(i).widget().setParent(None) # type: ignore
     if projectID != 'redraw':
       self.openProjectId = projectID
     self.widgetsAction = {}
     self.widgetsList = {}
     self.widgetsProject = {} #title bar and widget that contains all of project
+    backend = self.comm.backend
 
-    if hasattr(self.comm.backend, 'db'):
-      hierarchy = self.comm.backend.db.getView('viewDocType/x0')
+    if hasattr(backend, 'db'):
+      db = self.comm.backend.db
+      hierarchy = db.getView('viewDocType/x0')
       #TODO_P5 for now, sorted by last change of project itself. future create a view that does that automatically(if docType x0: emit changeDate)
-      lastChangeDate = [self.comm.backend.db.getDoc(project['id'])['-date'] for project in hierarchy]
+      lastChangeDate = [db.getDoc(project['id'])['-date'] for project in hierarchy]
       maxProjects = int((self.height()-120)/50)-1
-      for index, project in enumerate([x for _, x in sorted(zip(lastChangeDate, hierarchy))]):
+      for index, project in enumerate(x for _, x in sorted(zip(lastChangeDate, hierarchy), reverse=True)):
         if index>maxProjects:
           break
         projID = project['id']
         projName = project['value'][0]
         if self.openProjectId == '':
           self.openProjectId = projID
         #head: show project name as button
         projectW = QFrame()
         # projectW.setMinimumHeight(300) #convenience: allow scroll in sidebar
         projectL = QVBoxLayout(projectW)
         projectL.setContentsMargins(3,3,3,3)
         maxLabelCharacters = int((self.sideBarWidth-50)/7.1)
-        label = projName if len(projName)<maxLabelCharacters else projName[:maxLabelCharacters-3]+'...'
-        btnProj = TextButton(label, self.btnProject, projectL, projID+'/')
+        label = (projName if len(projName) < maxLabelCharacters else f'{projName[:maxLabelCharacters - 3]}...')
+        btnProj = TextButton(label, self.btnProject, projectL, f'{projID}/')
         btnProj.setStyleSheet("border-width:0")
         self.widgetsProject[projID] = [btnProj, projectW]
 
         # actions: scan, curate, ...
         actionW, actionL = widgetAndLayout('Grid', projectL)
         if self.openProjectId != projID: #depending which project is open
           actionW.hide()
-          projectW.setStyleSheet("background-color:"+ getColor(self.comm.backend, 'secondaryDark'))
+          projectW.setStyleSheet("background-color:"+ getColor(backend, 'secondaryDark'))
         else:
-          projectW.setStyleSheet("background-color:"+ getColor(self.comm.backend, 'secondaryLight'))
-        btnScan = IconButton('mdi.clipboard-search-outline', self.btnScan, None, projID, 'Scan', self.comm.backend, text='Scan')
+          projectW.setStyleSheet("background-color:"+ getColor(backend, 'secondaryLight'))
+        btnScan = IconButton('mdi.clipboard-search-outline', self.btnScan, None, projID, 'Scan', backend, text='Scan')
         actionL.addWidget(btnScan, 0,0)  # type: ignore
-        btnCurate = IconButton('mdi.filter-plus-outline', self.btnCurate, None, projID, 'Special', self.comm.backend, text='Special')
+        btnCurate = IconButton('mdi.filter-plus-outline', self.btnCurate, None, projID, 'Special', backend, text='Special')
         btnCurate.hide()
         actionL.addWidget(btnCurate, 0,1)         # type: ignore
         self.widgetsAction[projID] = actionW
         btnScan.setStyleSheet("border-width:0")
         btnCurate.setStyleSheet("border-width:0")
 
         # lists: view list of measurements, ... of this project
         listW, listL = widgetAndLayout('Grid', projectL)
         if self.openProjectId != projID:
           listW.hide()
-        for idx, doctype in enumerate(self.comm.backend.db.dataLabels):
+        for idx, doctype in enumerate(db.dataLabels):
           if doctype[0]!='x':
-            button = IconButton(iconsDocTypes[self.comm.backend.db.dataLabels[doctype]], self.btnDocType, None, \
-                     doctype+'/'+projID, self.comm.backend.db.dataLabels[doctype],self.comm.backend)
+            icon = iconsDocTypes[db.dataLabels[doctype]]
+            button = IconButton(icon, self.btnDocType, None, f'{doctype}/{projID}', db.dataLabels[doctype], backend)
             listL.addWidget(button, 0, idx)    # type: ignore
-        button = IconButton(iconsDocTypes['-'], self.btnDocType, None, '-/'+projID, 'Unidentified', self.comm.backend)
-        listL.addWidget(button, 0, len(self.comm.backend.db.dataLabels)+1)  # type: ignore
+        button = IconButton(iconsDocTypes['-'], self.btnDocType, None, f'-/{projID}', 'Unidentified', backend)
+        listL.addWidget(button, 0, len(db.dataLabels)+1)  # type: ignore
         self.widgetsList[projID] = listW
 
         # show folders as hierarchy
         treeW = QTreeWidget()
         treeW.hide()  #convenience: allow scroll in sidebar
         treeW.setHeaderHidden(True)
         treeW.setColumnCount(1)
         treeW.itemClicked.connect(self.btnTree)
-        hierarchy = self.comm.backend.db.getHierarchy(projID)
+        hierarchy = db.getHierarchy(projID)
         rootItem = treeW.invisibleRootItem()
         count = 0
         for node in PreOrderIter(hierarchy, maxlevel=2):
           if not node.is_root and node.id[0]=='x':
             rootItem.insertChild(count, self.iterateTree(node, projID))
             count += 1
         projectL.addWidget(treeW)
@@ -144,21 +145,21 @@
       nodeHier (Anytree.Node): anytree node
       projectID (str): project id of this tree
 
     Returns:
       QtTreeWidgetItem: tree node
     """
     #prefill with name, doctype, id
-    nodeTree = QTreeWidgetItem([nodeHier.name, projectID+'/'+nodeHier.id ])
+    nodeTree = QTreeWidgetItem([nodeHier.name, f'{projectID}/{nodeHier.id}'])
     children = []
     for childHier in nodeHier.children:
       if childHier.docType[0][0]=='x':
         childTree = self.iterateTree(childHier, projectID)
         children.append(childTree)
-    if len(children)>0:
+    if children:
       nodeTree.insertChildren(0,children)
     return nodeTree
 
 
   def btnDocType(self) -> None:
     """
     What happens when user clicks to change doc-type
```

## pasta_eln/widgetTable.py

```diff
@@ -1,8 +1,10 @@
 """ widget that shows the table of the items """
+
+import itertools
 import re, logging
 from pathlib import Path
 from typing import Any
 from PySide6.QtWidgets import QWidget, QVBoxLayout, QTableView, QMenu, QFileDialog, QMessageBox, QHeaderView, QLineEdit, QComboBox # pylint: disable=no-name-in-module
 from PySide6.QtCore import Qt, Slot, QSortFilterProxyModel, QModelIndex       # pylint: disable=no-name-in-module
 from PySide6.QtGui import QStandardItemModel, QStandardItem, QFont            # pylint: disable=no-name-in-module
 from .dialogTableHeader import TableHeader
@@ -73,15 +75,15 @@
     self.table.setAlternatingRowColors(True)
     header = self.table.horizontalHeader()
     header.setSectionsMovable(True)
     header.setSortIndicatorShown(True)
     header.setMaximumSectionSize(400) #TODO_P4 addToConfig
     header.resizeSections(QHeaderView.ResizeToContents)
     header.setStretchLastSection(True)
-    #TODO_P3 table: shift-select
+    #TODO_P2 table: shift-select
     # ---
     mainL.addWidget(self.table)
     self.setLayout(mainL)
 
 
   @Slot(str, str)
   def changeTable(self, docType:str, projID:str) -> None:
@@ -89,108 +91,108 @@
     What happens when the table changes its raw information
 
     Args:
       docType (str): document type; leave empty for redraw
       projID (str): id of project
     """
     if docType!=self.docType or projID!=self.projID:
-      logging.debug('table:changeTable |'+docType+'|'+projID+'|')
+      logging.debug('table:changeTable |%s|%s|',docType, projID)
     self.models = []
+    #if not docType:  #only remove old filters, when docType changes
+    #   make sure internal updates are accounted for: i.e. comment
     for i in reversed(range(self.filterL.count())):
       self.filterL.itemAt(i).widget().setParent(None)   # type: ignore
     if docType!='':
       self.docType = docType
       self.projID  = projID
     if self.docType=='_tags_':
       self.addBtn.hide()
-      #TODO_P3 projectView: if table-row click, move to view it project
+      #TODO_P4 projectTree can select sub-folders: if table-row click, move to view it project
       if self.showAll:
         self.data = self.comm.backend.db.getView('viewIdentify/viewTagsAll')
       else:
         self.data = self.comm.backend.db.getView('viewIdentify/viewTags')
       self.filterHeader = ['tag','name','type']
       self.headline.setText('TAGS')
       self.actionChangeColums.setVisible(False)
     else:
       self.addBtn.show()
-      if docType[:2]=='x0':
+      if docType.startswith('x0'):
         self.selectionBtn.hide()
       else:
         self.selectionBtn.show()
-      path = 'viewDocType/'+self.docType+'All' if self.showAll else 'viewDocType/'+self.docType
+      path = (f'viewDocType/{self.docType}All' if self.showAll else f'viewDocType/{self.docType}')
       if self.projID=='':
         self.data = self.comm.backend.db.getView(path)
       else:
         self.data = self.comm.backend.db.getView(path, preciseKey=self.projID)
+      # filter multiple lines of the same item: #https://stackoverflow.com/questions/11092511/list-of-unique-dictionaries
+      self.data = list({v['id']:v for v in self.data}.values())
       if self.docType=='-':
         self.headline.setText('Unidentified')
         self.actionChangeColums.setVisible(False)
       else:
         self.actionChangeColums.setVisible(True)
         if self.docType in self.comm.backend.db.dataLabels:
           self.headline.setText(self.comm.backend.db.dataLabels[self.docType])
       self.filterHeader = self.comm.backend.db.getColumnNames()[self.docType].split(',')
       self.filterHeader = [i[1:] if i[0]=='-'   else i for i in self.filterHeader]  #change -something to something
       self.filterHeader = [i[2:] if i[:2]=='#_' else i for i in self.filterHeader]  #change #_something to somehing
     self.headerW.show()
     nrows, ncols = len(self.data), len(self.filterHeader)
     model = QStandardItemModel(nrows, ncols)
     model.setHorizontalHeaderLabels(self.filterHeader)
-    for i in range(nrows):
-      for j in range(ncols):
-        if self.docType=='_tags_':  #tags list
-          if j==0:
-            if self.data[i]['key']=='_curated':
-              item = QStandardItem('_curated_')
-            elif re.match(r'_\d', self.data[i]['key']):
-              item = QStandardItem('\u2605'*int(self.data[i]['key'][1]))
-            else:
-              item = QStandardItem(self.data[i]['key'])
-          else:
-            item = QStandardItem(self.data[i]['value'][j-1])
-        else:                 #list for normal doctypes
-          # print(i,j, self.data[i]['value'][j], type(self.data[i]['value'][j]))
-          if self.data[i]['value'][j] is None or not self.data[i]['value'][j]:  #None, False
-            item = QStandardItem('-') # TODO_P4 add nice glyphs later, see also below \u00D7')
-            # item.setFont(QFont("Helvetica [Cronyx]", 16))
-          elif isinstance(self.data[i]['value'][j], bool) and self.data[i]['value'][j]: #True
-            item = QStandardItem('Y') # \u2713')
-            # item.setFont(QFont("Helvetica [Cronyx]", 16))
-          elif isinstance(self.data[i]['value'][j], list):                      #list, e.g. qrCodes
-            if isinstance( self.data[i]['value'][j][0], str):
-              item =  QStandardItem(', '.join(self.data[i]['value'][j]))
-            else:
-              item =  QStandardItem(', '.join(  [str(i) for i in self.data[i]['value'][j]]  ))
-          elif re.match(r'^[a-z\-]-[a-z0-9]{32}$',self.data[i]['value'][j]):      #Link
-            item = QStandardItem('oo') # \u260D')
-            # item.setFont(QFont("Helvetica [Cronyx]", 16))
-          else:
-            if self.filterHeader[j]=='tags':
-              tags = self.data[i]['value'][j].split(' ')
-              if '_curated' in tags:
-                tags[tags.index('_curated')] = '_curated_'
-              for iStar in range(1,6):
-                if '_'+str(iStar) in tags:
-                  tags[tags.index('_'+str(iStar))] = '*'*iStar # '\u2605'*iStar
-              text = ' '.join(tags)
-            else:
-              text = self.data[i]['value'][j]
-            item = QStandardItem(text)
+    for i, j in itertools.product(range(nrows), range(ncols)):
+      if self.docType=='_tags_':  #tags list
         if j==0:
-          doc = self.comm.backend.db.getDoc(self.data[i]['id'])
-          if len([b for b in doc['-branch'] if False in b['show']])>0:
-            item.setText( item.text()+'  \U0001F441' )
-          item.setAccessibleText(doc['_id'])
-          if docType!='x0':
-            item.setFlags(Qt.ItemFlag.ItemIsUserCheckable | Qt.ItemFlag.ItemIsEnabled)   # type: ignore[operator]
-            item.setCheckState(Qt.CheckState.Unchecked)
-            #TODO_P3 design: make the checkboxes larger!
+          if self.data[i]['key']=='_curated':
+            item = QStandardItem('_curated_')
+          elif re.match(r'_\d', self.data[i]['key']):
+            item = QStandardItem('\u2605'*int(self.data[i]['key'][1]))
+          else:
+            item = QStandardItem(self.data[i]['key'])
         else:
-          item.setFlags(Qt.ItemIsEnabled) # type: ignore[arg-type]
-        model.setItem(i, j, item)
+          item = QStandardItem(self.data[i]['value'][j-1])
+      elif self.data[i]['value'][j] is None or not self.data[i]['value'][j]:  #None, False
+        item = QStandardItem('-') # TODO_P4 add nice glyphs later, see also below \u00D7')
+        # item.setFont(QFont("Helvetica [Cronyx]", 16))
+      elif isinstance(self.data[i]['value'][j], bool): #True
+        item = QStandardItem('Y') # \u2713')
+        # item.setFont(QFont("Helvetica [Cronyx]", 16))
+      elif isinstance(self.data[i]['value'][j], list):                  #list, e.g. qrCodes
+        item = (QStandardItem(', '.join(self.data[i]['value'][j])) if isinstance(
+            self.data[i]['value'][j][0], str) else QStandardItem(', '.join(
+                [str(i) for i in self.data[i]['value'][j]])))
+      elif re.match(r'^[a-z\-]-[a-z0-9]{32}$',self.data[i]['value'][j]):      #Link
+        item = QStandardItem('oo') # \u260D')
+        # item.setFont(QFont("Helvetica [Cronyx]", 16))
+      else:
+        if self.filterHeader[j]=='tags':
+          tags = self.data[i]['value'][j].split(' ')
+          if '_curated' in tags:
+            tags[tags.index('_curated')] = '_curated_'
+          for iStar in range(1,6):
+            if f'_{str(iStar)}' in tags:
+              tags[tags.index(f'_{str(iStar)}')] = '*'*iStar
+          text = ' '.join(tags)
+        else:
+          text = self.data[i]['value'][j]
+        item = QStandardItem(text)
+      if j==0:
+        doc = self.comm.backend.db.getDoc(self.data[i]['id'])
+        if [b for b in doc['-branch'] if False in b['show']]:
+          item.setText( item.text()+'  \U0001F441' )
+        item.setAccessibleText(doc['_id'])
+        if docType!='x0':
+          item.setFlags(Qt.ItemFlag.ItemIsUserCheckable | Qt.ItemFlag.ItemIsEnabled)   # type: ignore[operator]
+          item.setCheckState(Qt.CheckState.Unchecked)
+          #TODO_P2 design: make the checkboxes larger!
+      else:
+        item.setFlags(Qt.ItemIsEnabled) # type: ignore[arg-type]
+      model.setItem(i, j, item)
     self.models.append(model)
     self.table.setModel(self.models[-1])
     self.table.show()
     return
 
 
   def cellClicked(self, item:QStandardItem) -> None:
@@ -233,15 +235,14 @@
     else:
       doc = self.comm.backend.db.getDoc(docID)
       self.comm.formDoc.emit(doc)
       self.comm.changeTable.emit('','')
       self.comm.changeDetails.emit('redraw')
     return
 
-
   def executeAction(self) -> None:
     """ Any action by the buttons and menu at the top of the page """
     if hasattr(self.sender(), 'data'):  #action
       menuName = self.sender().data()
     else:                               #button
       menuName = self.sender().accessibleName()
     if menuName == 'addItem':
@@ -253,15 +254,15 @@
       # gui
       _, rowL = widgetAndLayout('H', self.filterL, 'm', 'xl', '0', 'xl')
       text = QLineEdit('')
       rowL.addWidget(text)
       select = QComboBox()
       select.addItems(self.filterHeader)
       select.currentIndexChanged.connect(self.filterChoice)
-      # print('create filter row',str(len(self.models)) )
+      select.setMinimumWidth(max(len(i) for i in self.filterHeader)*14)
       select.setAccessibleName(str(len(self.models)))
       rowL.addWidget(select)
       IconButton('fa5s.minus-square', self.delFilter, rowL, str(len(self.models)), backend=self.comm.backend)
       # data
       #TODO_P4 can you sort for true false in tables too?
       filterModel = QSortFilterProxyModel()
       text.textChanged.connect(filterModel.setFilterRegularExpression)
@@ -281,19 +282,19 @@
           if intersection is None:
             intersection = thisKeys
           else:
             intersection = intersection.intersection(thisKeys)
       #remove keys that should not be group edited and build dict
       if intersection is not None:
         intersection = intersection.difference({'-branch', '-user', '-client', 'metaVendor', 'shasum', \
-          '_id', 'metaUser', '_rev', '-name', '-date', 'image', '_attachments','links'})
+            '_id', 'metaUser', '_rev', '-name', '-date', 'image', '_attachments','links'})
         intersectionDict:dict[str,Any] = {i:'' for i in intersection}
         intersectionDict['-tags'] = []
         intersectionDict['-type'] = [self.docType]
-        intersectionDict.update({'_ids':docIDs})
+        intersectionDict['_ids'] = docIDs
         self.comm.formDoc.emit(intersectionDict)
         self.comm.changeDetails.emit('redraw')
         self.comm.changeTable.emit(self.docType, '')
     elif menuName == 'sequentialEdit':
       self.stopSequentialEdit = False
       for row in range(self.models[-1].rowCount()):
         item, docID = self.itemFromRow(row)
@@ -302,39 +303,43 @@
         if self.stopSequentialEdit:
           break
       self.comm.changeTable.emit(self.docType, '')
     elif menuName == 'delete':
       for row in range(self.models[-1].rowCount()):
         item, docID = self.itemFromRow(row)
         if item.checkState() == Qt.CheckState.Checked:
-          ret = QMessageBox.critical(self, 'Warning', 'Are you sure you want to delete this data: '+item.text()+'?',\
-                                    QMessageBox.StandardButton.Yes, QMessageBox.StandardButton.No)
+          ret = QMessageBox.critical(
+              self,
+              'Warning',
+              f'Are you sure you want to delete this data: {item.text()}?',
+              QMessageBox.StandardButton.Yes,
+              QMessageBox.StandardButton.No,
+          )
           if ret==QMessageBox.StandardButton.Yes:
             doc = self.comm.backend.db.getDoc(docID)
             for branch in doc['-branch']:
               oldPath = self.comm.backend.basePath/branch['path']
               if oldPath.exists():
-                newPath    = oldPath.parent/('trash_'+oldPath.name)
+                newPath = oldPath.parent / f'trash_{oldPath.name}'
                 oldPath.rename(newPath)
             self.comm.backend.db.remove(docID)
       self.comm.changeTable.emit(self.docType, '')
     elif menuName == 'changeColumns':
       dialog = TableHeader(self.comm, self.docType)
       dialog.exec()
     elif menuName == 'export':
-      #TODO_P3 export: export via extractor in high resolution: change order: first save, then rescale
       fileName = QFileDialog.getSaveFileName(self,'Export to ..',str(Path.home()),'*.csv')[0]
       with open(fileName,'w', encoding='utf-8') as fOut:
-        header = ['"'+i+'"' for i in self.filterHeader]
+        header = [f'"{i}"' for i in self.filterHeader]
         fOut.write(','.join(header)+'\n')
         for row in range(self.models[-1].rowCount()):
           rowContent = []
           for col in range(self.models[-1].columnCount()):
             value = self.models[-1].index( row, col, QModelIndex() ).data( Qt.DisplayRole )  # type: ignore[arg-type]
-            rowContent.append('"'+value+'"')
+            rowContent.append(f'"{value}"')
           fOut.write(','.join(rowContent)+'\n')
     elif menuName == 'toggleHide':
       for row in range(self.models[-1].rowCount()):
         item, docID = self.itemFromRow(row)
         if item.checkState() == Qt.CheckState.Checked:
           self.comm.backend.db.hideShow(docID)
       if self.docType=='x0':
```

## Comparing `pasta_eln-2.4.5.dist-info/LICENSE` & `pasta_eln-2.4.6.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `pasta_eln-2.4.5.dist-info/METADATA` & `pasta_eln-2.4.6.dist-info/METADATA`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: pasta-eln
-Version: 2.4.5
+Version: 2.4.6
 Summary: The favorite ELN for experimental scientists
 Home-page: https://pasta-eln.github.io/
 Author: The PASTA-ELN Team and Steffen Brinckmann
 Author-email: sbrinckm@gmail.com
 License: MIT
 Platform: UNKNOWN
 Classifier: Programming Language :: Python
```

## Comparing `pasta_eln-2.4.5.dist-info/RECORD` & `pasta_eln-2.4.6.dist-info/RECORD`

 * *Files 11% similar despite different names*

```diff
@@ -1,50 +1,50 @@
-pasta_eln/__init__.py,sha256=_Ii-AcaA_uJ3d8nX8_lx_m0ygyeDQcBFIqrksmPQLTI,46
-pasta_eln/backend.py,sha256=zF1kHV72YJuTAMSZUI4LzBH-7enwm7AXGCOzadDHhZk,34856
-pasta_eln/cli.py,sha256=IKLdSOJEOSeQwMbF3ATawJQNwUKdhurcUYOXGEXSXnE,14028
+pasta_eln/__init__.py,sha256=X63slgbN3AoaEZWaT0bnDRRNQoCAgVdWGyYN1C_81-k,46
+pasta_eln/backend.py,sha256=8WUO901XOXzJ86kIgo8i6MdBzjbWbgxUZN6C3Q0V2nI,35035
+pasta_eln/cli.py,sha256=qmx4gb4w7ST7HeIQsPAn-124VA_6NvPNDhzlLr8HI6Y,14068
 pasta_eln/communicate.py,sha256=p43M3-26K1qa1PelLf7ThSWNPDt7pNVhI2PwZA0-6m0,1453
-pasta_eln/database.py,sha256=pwPhkSAwSY6VQyfYp9U7PkMca1JGdwfW9psqK-dx04Y,43182
+pasta_eln/database.py,sha256=oO8B3SmHplSrCGEn0D9WU5_PJi9AmBKjwQT7Xcj4roo,43523
 pasta_eln/dialogConfig.py,sha256=Wsm2X-CNrG29F4K_h4aqalE2vw_0t0rCEUcOZ_OjRBM,1660
-pasta_eln/dialogConfigAuthors.py,sha256=yiyGSoCka4IjRuOVSHKilLt7nhGBz9Mye0Grsr-quJQ,4036
+pasta_eln/dialogConfigAuthors.py,sha256=raXS0asayVl4fhfaBvtMxBxWt-8uNtGIR87lL4cy0e8,4066
 pasta_eln/dialogConfigGUI.py,sha256=-sW4d2v_--5G6MwIwIQItswUh3GnAI5eCp_1NiZP_3U,3520
 pasta_eln/dialogConfigSetupLinux.py,sha256=GbFR4p_po7I_xnq0hQc04KnVDwbeuyQx-p1zI-ETer8,5178
-pasta_eln/dialogConfigSetupWindows.py,sha256=6yp9lE0A3CBLX2eKj7cRVe2No4c31zw6pyg2prN8hSI,6323
-pasta_eln/dialogForm.py,sha256=qkYLEomgiFXPFJ_ip_lXvNM5ox2mBrT5v5Tcx--iv1U,20962
-pasta_eln/dialogOntology.py,sha256=OpcGx3O-abSSFwroxRMb5aXx3BOaf2y-QM8JIRvD52E,1291
-pasta_eln/dialogProjectGroup.py,sha256=7Ycp1r6MhTmPKSBhNeQaqz9v1h0Rm46gHrcLoe2ouMM,9004
-pasta_eln/dialogTableHeader.py,sha256=em38ObRxt50kUvK8b0Eaz4r2lfpkbAI5ket457Hlj_k,4715
+pasta_eln/dialogConfigSetupWindows.py,sha256=yYRvEJ6vmb6njs-GtaVcWY15trw37zJ7R6Uzns08q90,6511
+pasta_eln/dialogForm.py,sha256=uxJMbTZBPD3aBg_6HO_8I7sx2Brpg-cxpWufQe2ZvsU,24744
+pasta_eln/dialogOntology.py,sha256=gbgad_erUu5SYEK6esxvpweBziRMjZYFnO4nbWEJrpI,1291
+pasta_eln/dialogProjectGroup.py,sha256=Ob8dfHLxk3R4antMgmwRM0qzavnwv5hPOMRitnW3eqo,9014
+pasta_eln/dialogTableHeader.py,sha256=2xx4M1Nn2YSQzV4ztilbUm7mQpGQ6wwdLufFZzWLWAs,4738
 pasta_eln/fixedStrings.py,sha256=mxIekBnuUkuA7-O_jPlQFwH0wMNHAKrifwYbWhELXxU,5958
-pasta_eln/gui.py,sha256=TSsVEhd_HQzehBYuvzRduwPJNQKZVqpTXRNxAd118u8,10614
-pasta_eln/handleDictionaries.py,sha256=YmEN9SIccPsX4rFBXzgf_4n3T6oXKIXdDf1CktdjRH0,6268
-pasta_eln/inputOutput.py,sha256=xChHzzYp-YQ4rqJQU66ZytpmoXBVsJz1-kvxPNT4ITk,16995
-pasta_eln/installationTools.py,sha256=Q2MLXDT09EryaE3rx2W41qqYd8NRMOEHQ6xzhFmo4Hk,23330
-pasta_eln/miscTools.py,sha256=JsAeMxsl5gWdeMeVMlALh2UbpxqROZxB9MSk0vz5TPo,10521
-pasta_eln/mixin_cli.py,sha256=-lrh2GJfvNVqBkvf5p-y2eZUSDTsRhTJn1KBOoXRqTs,5714
-pasta_eln/printer.py,sha256=7-IY_Gd5EqfwlPIt-Eb7JMkGgn9faMKGHFk40cbeQco,3851
-pasta_eln/serverActions.py,sha256=iKJJwzT-ijlaJ_SL9p82vPlGUBT-L9R_woCcB-wt0yY,21356
-pasta_eln/style.py,sha256=9r3pDdthm9U-VUZWUPFZG2-mjhloS21xxLYZibK9ZAs,11331
-pasta_eln/tempStrings.py,sha256=L538EyQ1rcW7gUs0rfMR-tTzTp7anH18AXOHL4ZHYYs,2372
-pasta_eln/widgetBody.py,sha256=FZalRP55FbRZf32MMYkIyxNu5OlVBvJY9T-rBYET2V8,1519
-pasta_eln/widgetDetails.py,sha256=tR6JX2lBedimgqkem2SehUAlnnaKl8A33nC-UnyFIeI,11684
-pasta_eln/widgetDocTypes.py,sha256=cp-o3gfhkBse98DUEeeaFdccMehLao3wgmaUyJSfWHM,1666
-pasta_eln/widgetProject.py,sha256=g8b0WvxWBJkPgExS3k8bd3nOB9NW40koxLi7NOhagNU,11998
-pasta_eln/widgetProjectLeafRenderer.py,sha256=oWNcH8yS9AaPrpRyIsfpJF3ARYzSfQ_scD48Dr-CQ28,8977
-pasta_eln/widgetProjectTreeView.py,sha256=CYxV76p0sqYvsa17M2OGbbx8P2q7G2dgSHHV1rdwYs8,7349
-pasta_eln/widgetSidebar.py,sha256=vC5ZJ5XoX-bbbktEgmsrJZJXPo9IzDNhEeVEZcWVdWA,9539
-pasta_eln/widgetTable.py,sha256=4h2VpaQMJ4B_ziGquXQ2d7aDEEtJZtEP5vtC7KRu5Y8,18522
+pasta_eln/gui.py,sha256=Cne5F1kOnXiik5jtZ4FdXN_19TfAv39Ik1M0A9e04HE,11225
+pasta_eln/handleDictionaries.py,sha256=xdkVj8PD1tdGnQm890x6z_bxpAgVS1m23U9zflOPUts,6184
+pasta_eln/inputOutput.py,sha256=m6_CAswWg-HFlbqKKO0RMJnKUrIsAmspwq7IsWk5l94,16925
+pasta_eln/installationTools.py,sha256=2Oxegvq4DMpzyNUQrcpMz994fAr8osukyDkj3cmgxR0,23476
+pasta_eln/miscTools.py,sha256=_-CLKkKmH7noabd3lmA3j57fLff0HE-UxsTOrvUtris,10448
+pasta_eln/mixin_cli.py,sha256=v4bd-nSS5BkViC3py7DLV7hqz524lNId3LQMlbu-mq8,5547
+pasta_eln/printer.py,sha256=WXTjZhMLqPbQ_Q6sgoeS8o64JyOZFaNnHRCEjFX1pY0,3808
+pasta_eln/serverActions.py,sha256=lFTiY9Jj4n7ODzrBjsS4BvCm-kTGpA8DHcCShv520K8,23353
+pasta_eln/style.py,sha256=IA-aymc7pjvyQlSuZXOm0Ky_aB65LdfdtHE-nU2WIIA,11440
+pasta_eln/tempStrings.py,sha256=DIFX9Pjb5O6riPjJkVa2yXM4uwoO4uhIifT9LH5q1x8,2555
+pasta_eln/widgetBody.py,sha256=APGFBylA2Mv8ZwaiFNwW0vIMPc8U1BZ4SdsiM01K1zI,1504
+pasta_eln/widgetDetails.py,sha256=X5MrgKWmvkwLvgXta77MPMKTNBY5d8eHvuXkU1VzeaY,12894
+pasta_eln/widgetDocTypes.py,sha256=CgOmJ5Yt-4SySjB2MHowkk4FJ-Pf3QOpGK9SM41l-Ts,1581
+pasta_eln/widgetProject.py,sha256=EFdk715KOmW0UA-pjH9Muebrxt1v8CZWMQwxeVc7hF8,13115
+pasta_eln/widgetProjectLeafRenderer.py,sha256=3dHCnfShnWnUcIv5Eh_yyYcfVP3kskOfkMKfESEoHGo,8870
+pasta_eln/widgetProjectTreeView.py,sha256=oVHTHo2SMKsXX2yqR2ZJE16_SyfJB16qKwn0m0fR86c,7499
+pasta_eln/widgetSidebar.py,sha256=Rld8i5hPzuu7ScGoIZp4r5tAJpDVFSbPXlQgaXKh7Kg,9430
+pasta_eln/widgetTable.py,sha256=5U7VYSBSPNBe_6StPlXO_eY9SyITWaXsY7Em03gizRU,18500
 pasta_eln/Extractors/README.md,sha256=EookF0Yv-HrTrND6IEs4SuhKNDBOdMF2DjWXFj9ZBoU,356
 pasta_eln/Extractors/extractor_csv.py,sha256=lctirVGePM7izC9SPywf2a7NR7KyyJ5TUqFw7pShlhM,4895
 pasta_eln/Extractors/extractor_jpeg.py,sha256=nVQPPBpb6G1Eckwt-bblTlgEVLeCDC6E74LvN4Wm5qc,1275
 pasta_eln/Extractors/extractor_jpg.py,sha256=4EkWFDGL-GNJx-uJoAVGjwdfxm4Nei3Ihr0VWZPQrCk,1560
 pasta_eln/Extractors/extractor_json.py,sha256=V02ZW7Zo47xKe4zBfV6dg2RoSj66WQcyfJH5laCrDE8,953
 pasta_eln/Extractors/extractor_md.py,sha256=kxFG4PhWkCcH0DLi2dZQbuIF5nwNFzFxYuGVZj9CBVE,681
 pasta_eln/Extractors/extractor_png.py,sha256=CLJlQB3p8Icp_Mbchtl6ahvqqfylnFfa3BkD5rBmd9g,1875
 pasta_eln/Resources/ExampleMeasurements/simple.csv,sha256=jjFFDNmaATgB3p-E4tNkjsjXDdC21b4jx8yCeCqQunM,187
 pasta_eln/Resources/ExampleMeasurements/simple.png,sha256=6LniA-_zI3mmm7N4XlGl7c6Kp_xICcaW6ujd7nurghA,9450
 pasta_eln/Resources/Icons/favicon64.ico,sha256=vveTOeo95-Wmv3ES5gp1FYiE-y9WdxSMDIVPSTVEcqY,5694
 pasta_eln/Resources/Icons/favicon64.png,sha256=vbdaxqyXk5nKiMasATvOMv5sDlSarWrzIXn5qSX69ik,2161
-pasta_eln-2.4.5.dist-info/LICENSE,sha256=czf-VGQ2cp4m5_iQpsMhV5xBreZPJZa58Xi7hxMUMs0,1613
-pasta_eln-2.4.5.dist-info/METADATA,sha256=Goc2WUZ-8yAwGKLkHnaSCeLfs_6gQkbqIt7Fl-Plaik,3541
-pasta_eln-2.4.5.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-pasta_eln-2.4.5.dist-info/entry_points.txt,sha256=lg1LNjxltRABk9eiBjpMqGWGj60m0klbQ1Ly-sOBHcA,150
-pasta_eln-2.4.5.dist-info/top_level.txt,sha256=vRI0uEQNtWCKGRYA0FVyVsiosAcVlxIRApBZqa4vQVk,10
-pasta_eln-2.4.5.dist-info/RECORD,,
+pasta_eln-2.4.6.dist-info/LICENSE,sha256=czf-VGQ2cp4m5_iQpsMhV5xBreZPJZa58Xi7hxMUMs0,1613
+pasta_eln-2.4.6.dist-info/METADATA,sha256=3gfm0yijGuE3qXvnZou7VCI6-VRWfrCpxs0vOjouik8,3541
+pasta_eln-2.4.6.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
+pasta_eln-2.4.6.dist-info/entry_points.txt,sha256=lg1LNjxltRABk9eiBjpMqGWGj60m0klbQ1Ly-sOBHcA,150
+pasta_eln-2.4.6.dist-info/top_level.txt,sha256=vRI0uEQNtWCKGRYA0FVyVsiosAcVlxIRApBZqa4vQVk,10
+pasta_eln-2.4.6.dist-info/RECORD,,
```


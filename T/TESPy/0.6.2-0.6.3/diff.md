# Comparing `tmp/TESPy-0.6.2.tar.gz` & `tmp/TESPy-0.6.3.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "TESPy-0.6.2.tar", last modified: Fri Oct 14 16:19:43 2022, max compression
+gzip compressed data, was "TESPy-0.6.3.tar", last modified: Sun Jul 30 16:30:00 2023, max compression
```

## Comparing `TESPy-0.6.2.tar` & `TESPy-0.6.3.tar`

### file list

```diff
@@ -1,386 +1,390 @@
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.958278 TESPy-0.6.2/
--rw-rw-rw-   0        0        0      156 2021-10-04 06:28:48.000000 TESPy-0.6.2/.coveragerc
--rw-rw-rw-   0        0        0      265 2021-10-04 06:28:48.000000 TESPy-0.6.2/.editorconfig
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.550279 TESPy-0.6.2/.github/
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.598279 TESPy-0.6.2/.github/workflows/
--rw-rw-rw-   0        0        0      909 2022-10-14 16:16:43.000000 TESPy-0.6.2/.github/workflows/packaging.yml
--rw-rw-rw-   0        0        0     1307 2022-10-14 16:16:43.000000 TESPy-0.6.2/.github/workflows/tox_checks.yml
--rw-rw-rw-   0        0        0     1104 2022-10-14 16:16:43.000000 TESPy-0.6.2/.github/workflows/tox_pytest.yml
--rw-rw-rw-   0        0        0      712 2021-10-04 06:28:48.000000 TESPy-0.6.2/.gitignore
--rw-rw-rw-   0        0        0     1446 2021-10-04 06:28:48.000000 TESPy-0.6.2/.pep8speaks.yml
--rw-rw-rw-   0        0        0      241 2021-10-04 06:28:48.000000 TESPy-0.6.2/.readthedocs.yml
--rw-rw-rw-   0        0        0     3269 2021-10-04 06:28:48.000000 TESPy-0.6.2/CODE_OF_CONDUCT.md
--rw-rw-rw-   0        0        0      154 2022-01-28 07:48:36.000000 TESPy-0.6.2/CONTRIBUTING.md
--rw-rw-rw-   0        0        0     1105 2022-10-14 16:16:43.000000 TESPy-0.6.2/LICENSE
--rw-rw-rw-   0        0        0      403 2021-10-04 06:28:48.000000 TESPy-0.6.2/MANIFEST.in
--rw-rw-rw-   0        0        0     8074 2022-10-14 16:19:43.958278 TESPy-0.6.2/PKG-INFO
--rw-rw-rw-   0        0        0      765 2021-10-04 06:28:48.000000 TESPy-0.6.2/PULL_REQUEST_TEMPLATE.md
--rw-rw-rw-   0        0        0     9166 2022-10-14 16:16:43.000000 TESPy-0.6.2/README.rst
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.598279 TESPy-0.6.2/ci/
--rwxrwxrwx   0        0        0      786 2021-10-04 06:28:48.000000 TESPy-0.6.2/ci/appveyor-with-compiler.cmd
--rw-rw-rw-   0        0        0     3017 2021-10-04 06:28:48.000000 TESPy-0.6.2/ci/bootstrap.py
--rw-rw-rw-   0        0        0     2914 2021-10-04 06:28:48.000000 TESPy-0.6.2/ci/generate_tespy_data_module.py
--rw-rw-rw-   0        0        0       66 2021-10-04 06:28:48.000000 TESPy-0.6.2/ci/requirements.txt
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.606278 TESPy-0.6.2/ci/templates/
--rw-rw-rw-   0        0        0     1876 2021-10-04 06:28:48.000000 TESPy-0.6.2/ci/templates/.appveyor.yml
--rw-rw-rw-   0        0        0     1498 2021-10-04 06:28:48.000000 TESPy-0.6.2/ci/templates/.travis.yml
--rw-rw-rw-   0        0        0     2212 2021-10-04 06:28:48.000000 TESPy-0.6.2/ci/templates/tox.ini
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.614279 TESPy-0.6.2/docs/
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.550279 TESPy-0.6.2/docs/_static/
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.622278 TESPy-0.6.2/docs/_static/css/
--rw-rw-rw-   0        0        0      103 2022-10-14 16:16:49.000000 TESPy-0.6.2/docs/_static/css/custom.css
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.630280 TESPy-0.6.2/docs/_static/images/
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.550279 TESPy-0.6.2/docs/_static/images/advanced/
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.630280 TESPy-0.6.2/docs/_static/images/advanced/exergy/
--rw-rw-rw-   0        0        0   129643 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/advanced/exergy/flowsheet.svg
--rw-rw-rw-   0        0        0   136810 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/advanced/exergy/flowsheet_darkmode.svg
--rw-rw-rw-   0        0        0    32134 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/advanced/exergy/sankey.svg
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.654279 TESPy-0.6.2/docs/_static/images/basics/
--rw-rw-rw-   0        0        0    17276 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/district_heating.svg
--rw-rw-rw-   0        0        0    18111 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/district_heating_darkmode.svg
--rw-rw-rw-   0        0        0    69064 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/district_heating_partload.svg
--rw-rw-rw-   0        0        0    71199 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/district_heating_partload_darkmode.svg
--rw-rw-rw-   0        0        0    15810 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/gas_turbine.svg
--rw-rw-rw-   0        0        0    16340 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/gas_turbine_darkmode.svg
--rw-rw-rw-   0        0        0    32095 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/gas_turbine_fuel_composition.svg
--rw-rw-rw-   0        0        0    32756 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/gas_turbine_fuel_composition_darkmode.svg
--rw-rw-rw-   0        0        0    29612 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/gas_turbine_oxygen.svg
--rw-rw-rw-   0        0        0    30202 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/gas_turbine_oxygen_darkmode.svg
--rw-rw-rw-   0        0        0    57559 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/gas_turbine_parametric.svg
--rw-rw-rw-   0        0        0    59255 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/gas_turbine_parametric_darkmode.svg
--rw-rw-rw-   0        0        0    14362 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/heat_pump.svg
--rw-rw-rw-   0        0        0    14866 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/heat_pump_darkmode.svg
--rw-rw-rw-   0        0        0    53423 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/heat_pump_parametric.svg
--rw-rw-rw-   0        0        0    54994 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/heat_pump_parametric_darkmode.svg
--rw-rw-rw-   0        0        0    16030 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/modeling_concept.svg
--rw-rw-rw-   0        0        0    16137 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/rankine_cycle.svg
--rw-rw-rw-   0        0        0    16871 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/rankine_cycle_darkmode.svg
--rw-rw-rw-   0        0        0    59916 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/rankine_parametric.svg
--rw-rw-rw-   0        0        0    61115 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/rankine_parametric_darkmode.svg
--rw-rw-rw-   0        0        0    26962 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/rankine_partload.svg
--rw-rw-rw-   0        0        0    27517 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/basics/rankine_partload_darkmode.svg
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.662279 TESPy-0.6.2/docs/_static/images/examples/
--rw-rw-rw-   0        0        0    67070 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/examples/GRC_electrical_power_output.svg
--rw-rw-rw-   0        0        0    81637 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/examples/GRC_electrical_power_output_darkmode.svg
--rw-rw-rw-   0        0        0    39020 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/logo_tespy_big.svg
--rw-rw-rw-   0        0        0    39647 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/logo_tespy_big_darkmode.svg
--rw-rw-rw-   0        0        0    17145 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/logo_tespy_big_editable_font.svg
--rw-rw-rw-   0        0        0    23121 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/logo_tespy_mid.svg
--rw-rw-rw-   0        0        0    23260 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/logo_tespy_mid_darkmode.svg
--rw-rw-rw-   0        0        0    15239 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/logo_tespy_mid_editable_font.svg
--rw-rw-rw-   0        0        0    13302 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/logo_tespy_small.svg
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.678280 TESPy-0.6.2/docs/_static/images/modules/
--rw-rw-rw-   0        0        0   157002 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/modules/Ts_diagram_states.svg
--rw-rw-rw-   0        0        0     8644 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/modules/characteristics.svg
--rw-rw-rw-   0        0        0     8414 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/modules/characteristics_darkmode.svg
--rw-rw-rw-   0        0        0    11300 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/modules/connections.svg
--rw-rw-rw-   0        0        0    11315 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/modules/connections_darkmode.svg
--rw-rw-rw-   0        0        0   134345 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/modules/fluid_properties.svg
--rw-rw-rw-   0        0        0   125300 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/modules/fluid_properties_darkmode.svg
--rw-rw-rw-   0        0        0   168665 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/modules/logph_diagram_states.svg
--rw-rw-rw-   0        0        0    17587 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/modules/subsystem_waste_heat_generator.svg
--rw-rw-rw-   0        0        0    17663 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/modules/subsystem_waste_heat_generator_darkmode.svg
--rw-rw-rw-   0        0        0   121692 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/modules/ude.svg
--rw-rw-rw-   0        0        0   125035 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/modules/ude_darkmode.svg
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.558278 TESPy-0.6.2/docs/_static/images/tutorials/
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.678280 TESPy-0.6.2/docs/_static/images/tutorials/district_heating_system/
--rw-rw-rw-   0        0        0    33944 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/district_heating_system/dhs.svg
--rw-rw-rw-   0        0        0    20206 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/district_heating_system/dhs_closed.svg
--rw-rw-rw-   0        0        0    12074 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/district_heating_system/dhs_forks.svg
--rw-rw-rw-   0        0        0    21711 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/district_heating_system/dhs_open.svg
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.694280 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/
--rw-rw-rw-   0        0        0   168149 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/NH3_logph.svg
--rw-rw-rw-   0        0        0    23347 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/NH3_sankey.svg
--rw-rw-rw-   0        0        0    60290 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_E_D.svg
--rw-rw-rw-   0        0        0    61853 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_E_D_darkmode.svg
--rw-rw-rw-   0        0        0    61177 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Q.svg
--rw-rw-rw-   0        0        0    62156 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Q_darkmode.svg
--rw-rw-rw-   0        0        0    66033 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Ths.svg
--rw-rw-rw-   0        0        0    67428 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Ths_darkmode.svg
--rw-rw-rw-   0        0        0    52499 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_eps_Tamb_Tgeo.svg
--rw-rw-rw-   0        0        0    53372 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_eps_Tamb_Tgeo_darkmode.svg
--rw-rw-rw-   0        0        0    29826 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/flowsheet.svg
--rw-rw-rw-   0        0        0    29835 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/flowsheet_darkmode.svg
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.702279 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_starting_values/
--rw-rw-rw-   0        0        0    27850 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_starting_values/COP_by_wf.svg
--rw-rw-rw-   0        0        0    28404 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_starting_values/COP_by_wf_darkmode.svg
--rw-rw-rw-   0        0        0    30290 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_starting_values/flowsheet.svg
--rw-rw-rw-   0        0        0    30299 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_starting_values/flowsheet_darkmode.svg
--rw-rw-rw-   0        0        0   227184 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_starting_values/logph.svg
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.710279 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_stepwise/
--rw-rw-rw-   0        0        0    46257 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet.svg
--rw-rw-rw-   0        0        0    46240 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_darkmode.svg
--rw-rw-rw-   0        0        0    46286 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p1.svg
--rw-rw-rw-   0        0        0    46277 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p1_darkmode.svg
--rw-rw-rw-   0        0        0    46669 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p2.svg
--rw-rw-rw-   0        0        0    46657 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p2_darkmode.svg
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.718279 TESPy-0.6.2/docs/_static/images/tutorials/pygmo_optimization/
--rw-rw-rw-   0        0        0    33530 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/pygmo_optimization/flowsheet.svg
--rw-rw-rw-   0        0        0    34684 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/pygmo_optimization/flowsheet_darkmode.svg
--rw-rw-rw-   0        0        0   190475 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/pygmo_optimization/pygmo_optimization.svg
--rw-rw-rw-   0        0        0   192983 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_static/images/tutorials/pygmo_optimization/pygmo_optimization_darkmode.svg
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.718279 TESPy-0.6.2/docs/_templates/
--rw-rw-rw-   0        0        0        0 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/_templates/index.html
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.718279 TESPy-0.6.2/docs/advanced/
--rw-rw-rw-   0        0        0    20296 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/advanced/exergy.rst
--rw-rw-rw-   0        0        0       92 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/advanced/optimization.rst
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.726278 TESPy-0.6.2/docs/api/
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.782279 TESPy-0.6.2/docs/api/_images/
--rw-rw-rw-   0        0        0     9313 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/CombustionChamber.svg
--rw-rw-rw-   0        0        0     9682 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/CombustionChamber_darkmode.svg
--rw-rw-rw-   0        0        0    15877 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/CombustionEngine.svg
--rw-rw-rw-   0        0        0    16472 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/CombustionEngine_darkmode.svg
--rw-rw-rw-   0        0        0     7484 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Compressor.svg
--rw-rw-rw-   0        0        0     7661 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Compressor_darkmode.svg
--rw-rw-rw-   0        0        0     9565 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Condenser.svg
--rw-rw-rw-   0        0        0    10115 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Condenser_darkmode.svg
--rw-rw-rw-   0        0        0     8898 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/DropletSeparator.svg
--rw-rw-rw-   0        0        0     9039 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/DropletSeparator_darkmode.svg
--rw-rw-rw-   0        0        0    10414 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Drum.svg
--rw-rw-rw-   0        0        0    10583 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Drum_darkmode.svg
--rw-rw-rw-   0        0        0    15148 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/FuelCell.svg
--rw-rw-rw-   0        0        0    15153 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/FuelCell_darkmode.svg
--rw-rw-rw-   0        0        0    10283 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/HeatExchanger.svg
--rw-rw-rw-   0        0        0    10403 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/HeatExchanger_darkmode.svg
--rw-rw-rw-   0        0        0    12851 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Merge.svg
--rw-rw-rw-   0        0        0    13017 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Merge_darkmode.svg
--rw-rw-rw-   0        0        0     8013 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/ORCEvaporator.svg
--rw-rw-rw-   0        0        0     7643 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/ParabolicTrough.svg
--rw-rw-rw-   0        0        0     7823 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/ParabolicTrough_darkmode.svg
--rw-rw-rw-   0        0        0     6462 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Pipe.svg
--rw-rw-rw-   0        0        0     6640 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Pipe_darkmode.svg
--rw-rw-rw-   0        0        0     7414 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Pump.svg
--rw-rw-rw-   0        0        0     7478 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Pump_darkmode.svg
--rw-rw-rw-   0        0        0     6810 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/SolarCollector.svg
--rw-rw-rw-   0        0        0     6875 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/SolarCollector_darkmode.svg
--rw-rw-rw-   0        0        0    12813 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Splitter.svg
--rw-rw-rw-   0        0        0    12979 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Splitter_darkmode.svg
--rw-rw-rw-   0        0        0    12381 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/SubsystemInterface.svg
--rw-rw-rw-   0        0        0    12558 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/SubsystemInterface_darkmode.svg
--rw-rw-rw-   0        0        0     6668 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Turbine.svg
--rw-rw-rw-   0        0        0     6677 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Turbine_darkmode.svg
--rw-rw-rw-   0        0        0     6491 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Valve.svg
--rw-rw-rw-   0        0        0     6668 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/Valve_darkmode.svg
--rw-rw-rw-   0        0        0    13372 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/WaterElectrolyzer.svg
--rw-rw-rw-   0        0        0    15165 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/WaterElectrolyzer_darkmode.svg
--rw-rw-rw-   0        0        0    40711 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/combustion_engine_Q1_char_DEFAULT.svg
--rw-rw-rw-   0        0        0    40966 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/combustion_engine_Q2_char_DEFAULT.svg
--rw-rw-rw-   0        0        0    38781 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/combustion_engine_Qloss_char_DEFAULT.svg
--rw-rw-rw-   0        0        0    37655 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/combustion_engine_tiP_char_DEFAULT.svg
--rw-rw-rw-   0        0        0    49048 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/compressor_char_map_eta_s_DEFAULT.svg
--rw-rw-rw-   0        0        0    46950 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/compressor_char_map_pr_DEFAULT.svg
--rw-rw-rw-   0        0        0    39251 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/compressor_eta_s_char_DEFAULT.svg
--rw-rw-rw-   0        0        0    40197 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/condenser_kA_char1_DEFAULT.svg
--rw-rw-rw-   0        0        0    41171 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/condenser_kA_char2_DEFAULT.svg
--rw-rw-rw-   0        0        0    42372 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/desuperheater_kA_char1_DEFAULT.svg
--rw-rw-rw-   0        0        0    41171 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/desuperheater_kA_char2_DEFAULT.svg
--rw-rw-rw-   0        0        0    46235 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/_images/flowsheet.svg
--rw-rw-rw-   0        0        0    43523 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/heat_exchanger_kA_char1_CONDENSING_FLUID.svg
--rw-rw-rw-   0        0        0    42372 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/heat_exchanger_kA_char1_DEFAULT.svg
--rw-rw-rw-   0        0        0    41171 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/heat_exchanger_kA_char2_DEFAULT.svg
--rw-rw-rw-   0        0        0    45010 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/heat_exchanger_kA_char2_EVAPORATING_FLUID.svg
--rw-rw-rw-   0        0        0    42314 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/heat_exchanger_simple_kA_char_DEFAULT.svg
--rw-rw-rw-   0        0        0    42314 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/pipe_kA_char_DEFAULT.svg
--rw-rw-rw-   0        0        0    40653 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/pump_eta_s_char_DEFAULT.svg
--rw-rw-rw-   0        0        0    39798 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/turbine_eta_s_char_DEFAULT.svg
--rw-rw-rw-   0        0        0    40222 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/turbine_eta_s_char_TRAUPEL.svg
--rw-rw-rw-   0        0        0    36210 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/api/_images/water_electrolyzer_eta_char_DEFAULT.svg
--rw-rw-rw-   0        0        0     6356 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/components.rst
--rw-rw-rw-   0        0        0      496 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/connections.rst
--rw-rw-rw-   0        0        0     4204 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/data.rst
--rw-rw-rw-   0        0        0      493 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/networks.rst
--rw-rw-rw-   0        0        0     1501 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api/tools.rst
--rw-rw-rw-   0        0        0      532 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/api.rst
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.790279 TESPy-0.6.2/docs/basics/
--rw-rw-rw-   0        0        0     5200 2022-10-14 16:16:49.000000 TESPy-0.6.2/docs/basics/district_heating.rst
--rw-rw-rw-   0        0        0    10867 2022-10-14 16:16:49.000000 TESPy-0.6.2/docs/basics/gas_turbine.rst
--rw-rw-rw-   0        0        0     6690 2022-10-14 16:16:49.000000 TESPy-0.6.2/docs/basics/heat_pump.rst
--rw-rw-rw-   0        0        0     7430 2022-10-14 16:16:49.000000 TESPy-0.6.2/docs/basics/intro.rst
--rw-rw-rw-   0        0        0    10658 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/basics/rankine_cycle.rst
--rw-rw-rw-   0        0        0     2463 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/basics.rst
--rw-rw-rw-   0        0        0     2753 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/benchmarks.rst
--rw-rw-rw-   0        0        0     8465 2022-10-14 16:16:49.000000 TESPy-0.6.2/docs/conf.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.790279 TESPy-0.6.2/docs/development/
--rw-rw-rw-   0        0        0     7313 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/development/how.rst
--rw-rw-rw-   0        0        0     2831 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/development/what.rst
--rw-rw-rw-   0        0        0     1740 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/examples.rst
--rw-rw-rw-   0        0        0      661 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/index.rst
--rw-rw-rw-   0        0        0     2470 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/installation.rst
--rw-rw-rw-   0        0        0     3846 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/introduction.rst
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.798280 TESPy-0.6.2/docs/modules/
--rw-rw-rw-   0        0        0     5088 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/modules/characteristics.rst
--rw-rw-rw-   0        0        0    34783 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/modules/components.rst
--rw-rw-rw-   0        0        0    13033 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/modules/connections.rst
--rw-rw-rw-   0        0        0     6195 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/modules/fluid_properties.rst
--rw-rw-rw-   0        0        0    33164 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/modules/networks.rst
--rw-rw-rw-   0        0        0    11362 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/modules/ude.rst
--rw-rw-rw-   0        0        0     2398 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/modules.rst
--rw-rw-rw-   0        0        0     9167 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/references.bib
--rw-rw-rw-   0        0        0     1040 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/regular_meeting.rst
--rw-rw-rw-   0        0        0       75 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/requirements.txt
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.798280 TESPy-0.6.2/docs/tutorials/
--rw-rw-rw-   0        0        0     2363 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/tutorials/district_heating.rst
--rw-rw-rw-   0        0        0    32219 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/tutorials/heat_pump_exergy.rst
--rw-rw-rw-   0        0        0    21507 2022-10-14 16:16:49.000000 TESPy-0.6.2/docs/tutorials/heat_pump_steps.rst
--rw-rw-rw-   0        0        0     7918 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/tutorials/pygmo_optimization.rst
--rw-rw-rw-   0        0        0     8542 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/tutorials/starting_values.rst
--rw-rw-rw-   0        0        0     3157 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/tutorials.rst
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.830276 TESPy-0.6.2/docs/whats_new/
--rw-rw-rw-   0        0        0      240 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/whats_new/v0-0-1.rst
--rw-rw-rw-   0        0        0     1528 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/whats_new/v0-0-2.rst
--rw-rw-rw-   0        0        0     4807 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/whats_new/v0-0-3.rst
--rw-rw-rw-   0        0        0     1994 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/whats_new/v0-0-4.rst
--rw-rw-rw-   0        0        0     3233 2022-08-14 09:14:04.000000 TESPy-0.6.2/docs/whats_new/v0-0-5.rst
--rw-rw-rw-   0        0        0     3987 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/whats_new/v0-1-0.rst
--rw-rw-rw-   0        0        0     4347 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/whats_new/v0-1-1.rst
--rw-rw-rw-   0        0        0     3842 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/whats_new/v0-1-2.rst
--rw-rw-rw-   0        0        0     2675 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/whats_new/v0-1-3.rst
--rw-rw-rw-   0        0        0      616 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/whats_new/v0-1-4.rst
--rw-rw-rw-   0        0        0     8338 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/whats_new/v0-2-0.rst
--rw-rw-rw-   0        0        0     1982 2022-05-26 10:30:52.000000 TESPy-0.6.2/docs/whats_new/v0-2-1.rst
--rw-rw-rw-   0        0        0     3064 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/whats_new/v0-2-2.rst
--rw-rw-rw-   0        0        0    11252 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/whats_new/v0-3-0.rst
--rw-rw-rw-   0        0        0      314 2022-05-26 10:30:52.000000 TESPy-0.6.2/docs/whats_new/v0-3-1.rst
--rw-rw-rw-   0        0        0     2015 2022-08-14 09:14:04.000000 TESPy-0.6.2/docs/whats_new/v0-3-2.rst
--rw-rw-rw-   0        0        0     1345 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/whats_new/v0-3-3.rst
--rw-rw-rw-   0        0        0     1471 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/whats_new/v0-3-4.rst
--rw-rw-rw-   0        0        0    11174 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/whats_new/v0-4-0.rst
--rw-rw-rw-   0        0        0     1126 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/whats_new/v0-4-1.rst
--rw-rw-rw-   0        0        0     1589 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/whats_new/v0-4-2.rst
--rw-rw-rw-   0        0        0      563 2021-10-04 06:28:48.000000 TESPy-0.6.2/docs/whats_new/v0-4-3-001.rst
--rw-rw-rw-   0        0        0      656 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/whats_new/v0-4-3-003.rst
--rw-rw-rw-   0        0        0     3355 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/whats_new/v0-4-3.rst
--rw-rw-rw-   0        0        0     1183 2022-01-28 07:48:36.000000 TESPy-0.6.2/docs/whats_new/v0-4-4.rst
--rw-rw-rw-   0        0        0      801 2022-01-28 07:48:36.000000 TESPy-0.6.2/docs/whats_new/v0-5-0.rst
--rw-rw-rw-   0        0        0      930 2022-05-26 10:30:52.000000 TESPy-0.6.2/docs/whats_new/v0-5-1.rst
--rw-rw-rw-   0        0        0     2644 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/whats_new/v0-6-0.rst
--rw-rw-rw-   0        0        0     2064 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/whats_new/v0-6-1.rst
--rw-rw-rw-   0        0        0      385 2022-10-14 16:16:49.000000 TESPy-0.6.2/docs/whats_new/v0-6-2.rst
--rw-rw-rw-   0        0        0     1181 2022-10-14 16:16:49.000000 TESPy-0.6.2/docs/whats_new.rst
--rw-rw-rw-   0        0        0       90 2022-10-14 16:16:43.000000 TESPy-0.6.2/docs/zliterature.rst
--rw-rw-rw-   0        0        0     6585 2021-10-04 06:28:48.000000 TESPy-0.6.2/paper.bib
--rw-rw-rw-   0        0        0    11023 2021-10-04 06:28:48.000000 TESPy-0.6.2/paper.md
--rw-rw-rw-   0        0        0      104 2021-10-04 06:28:48.000000 TESPy-0.6.2/pyproject.toml
--rw-rw-rw-   0        0        0      842 2022-10-14 16:19:43.958278 TESPy-0.6.2/setup.cfg
--rw-rw-rw-   0        0        0     2548 2022-10-14 16:16:49.000000 TESPy-0.6.2/setup.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.566280 TESPy-0.6.2/src/
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.838275 TESPy-0.6.2/src/TESPy.egg-info/
--rw-rw-rw-   0        0        0     8074 2022-10-14 16:19:43.000000 TESPy-0.6.2/src/TESPy.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0    13099 2022-10-14 16:19:43.000000 TESPy-0.6.2/src/TESPy.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2022-10-14 16:19:43.000000 TESPy-0.6.2/src/TESPy.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0        2 2021-10-04 07:07:30.000000 TESPy-0.6.2/src/TESPy.egg-info/not-zip-safe
--rw-rw-rw-   0        0        0      191 2022-10-14 16:19:43.000000 TESPy-0.6.2/src/TESPy.egg-info/requires.txt
--rw-rw-rw-   0        0        0        6 2022-10-14 16:19:43.000000 TESPy-0.6.2/src/TESPy.egg-info/top_level.txt
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.838275 TESPy-0.6.2/src/tespy/
--rw-rw-rw-   0        0        0     1178 2022-10-14 16:16:49.000000 TESPy-0.6.2/src/tespy/__init__.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.838275 TESPy-0.6.2/src/tespy/components/
--rw-rw-rw-   0        0        0     1649 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/__init__.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.846276 TESPy-0.6.2/src/tespy/components/basics/
--rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.2/src/tespy/components/basics/__init__.py
--rw-rw-rw-   0        0        0     5398 2022-01-28 07:48:36.000000 TESPy-0.6.2/src/tespy/components/basics/cycle_closer.py
--rw-rw-rw-   0        0        0     2772 2022-01-28 07:48:36.000000 TESPy-0.6.2/src/tespy/components/basics/sink.py
--rw-rw-rw-   0        0        0     2810 2022-01-28 07:48:36.000000 TESPy-0.6.2/src/tespy/components/basics/source.py
--rw-rw-rw-   0        0        0     5779 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/basics/subsystem_interface.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.846276 TESPy-0.6.2/src/tespy/components/combustion/
--rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.2/src/tespy/components/combustion/__init__.py
--rw-rw-rw-   0        0        0    47510 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/combustion/base.py
--rw-rw-rw-   0        0        0    12775 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/combustion/diabatic.py
--rw-rw-rw-   0        0        0    62141 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/combustion/engine.py
--rw-rw-rw-   0        0        0    47983 2022-07-26 11:40:44.000000 TESPy-0.6.2/src/tespy/components/component.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.854279 TESPy-0.6.2/src/tespy/components/customs/
--rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.2/src/tespy/components/customs/__init__.py
--rw-rw-rw-   0        0        0    27345 2022-10-14 16:16:49.000000 TESPy-0.6.2/src/tespy/components/customs/orc_evaporator.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.862279 TESPy-0.6.2/src/tespy/components/heat_exchangers/
--rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.2/src/tespy/components/heat_exchangers/__init__.py
--rw-rw-rw-   0        0        0    38416 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/heat_exchangers/base.py
--rw-rw-rw-   0        0        0    19997 2022-10-14 16:16:49.000000 TESPy-0.6.2/src/tespy/components/heat_exchangers/condenser.py
--rw-rw-rw-   0        0        0     9133 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/heat_exchangers/desuperheater.py
--rw-rw-rw-   0        0        0    13841 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/heat_exchangers/parabolic_trough.py
--rw-rw-rw-   0        0        0    40646 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/heat_exchangers/simple.py
--rw-rw-rw-   0        0        0    12066 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/heat_exchangers/solar_collector.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.878293 TESPy-0.6.2/src/tespy/components/nodes/
--rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.2/src/tespy/components/nodes/__init__.py
--rw-rw-rw-   0        0        0     5568 2022-06-29 12:23:34.000000 TESPy-0.6.2/src/tespy/components/nodes/base.py
--rw-rw-rw-   0        0        0    16582 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/nodes/droplet_separator.py
--rw-rw-rw-   0        0        0    11529 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/nodes/drum.py
--rw-rw-rw-   0        0        0    18148 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/nodes/merge.py
--rw-rw-rw-   0        0        0    11442 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/nodes/separator.py
--rw-rw-rw-   0        0        0    10177 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/nodes/splitter.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.878293 TESPy-0.6.2/src/tespy/components/piping/
--rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.2/src/tespy/components/piping/__init__.py
--rw-rw-rw-   0        0        0     5205 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/piping/pipe.py
--rw-rw-rw-   0        0        0    13827 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/piping/valve.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.886280 TESPy-0.6.2/src/tespy/components/reactors/
--rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.2/src/tespy/components/reactors/__init__.py
--rw-rw-rw-   0        0        0    32883 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/reactors/fuel_cell.py
--rw-rw-rw-   0        0        0    44273 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/reactors/water_electrolyzer.py
--rw-rw-rw-   0        0        0     2249 2021-12-29 09:05:28.000000 TESPy-0.6.2/src/tespy/components/subsystem.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.894282 TESPy-0.6.2/src/tespy/components/turbomachinery/
--rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.2/src/tespy/components/turbomachinery/__init__.py
--rw-rw-rw-   0        0        0     7525 2022-05-26 10:30:52.000000 TESPy-0.6.2/src/tespy/components/turbomachinery/base.py
--rw-rw-rw-   0        0        0    24767 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/turbomachinery/compressor.py
--rw-rw-rw-   0        0        0    18528 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/turbomachinery/pump.py
--rw-rw-rw-   0        0        0    18067 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/components/turbomachinery/turbine.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.902279 TESPy-0.6.2/src/tespy/connections/
--rw-rw-rw-   0        0        0      147 2022-01-28 07:48:36.000000 TESPy-0.6.2/src/tespy/connections/__init__.py
--rw-rw-rw-   0        0        0    16149 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/connections/bus.py
--rw-rw-rw-   0        0        0    23731 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/connections/connection.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.902279 TESPy-0.6.2/src/tespy/data/
--rw-rw-rw-   0        0        0     8047 2021-10-04 06:28:48.000000 TESPy-0.6.2/src/tespy/data/char_lines.json
--rw-rw-rw-   0        0        0     3726 2021-10-04 06:28:48.000000 TESPy-0.6.2/src/tespy/data/char_maps.json
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.910300 TESPy-0.6.2/src/tespy/networks/
--rw-rw-rw-   0        0        0      118 2022-01-28 07:48:36.000000 TESPy-0.6.2/src/tespy/networks/__init__.py
--rw-rw-rw-   0        0        0   121226 2022-10-14 16:19:00.000000 TESPy-0.6.2/src/tespy/networks/network.py
--rw-rw-rw-   0        0        0    22128 2022-05-26 10:30:52.000000 TESPy-0.6.2/src/tespy/networks/network_reader.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.926281 TESPy-0.6.2/src/tespy/tools/
--rw-rw-rw-   0        0        0      884 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/tools/__init__.py
--rw-rw-rw-   0        0        0    33851 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/tools/analyses.py
--rw-rw-rw-   0        0        0    17057 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/tools/characteristics.py
--rw-rw-rw-   0        0        0    14208 2022-01-28 07:48:36.000000 TESPy-0.6.2/src/tespy/tools/data_containers.py
--rw-rw-rw-   0        0        0    37268 2022-08-18 06:28:08.000000 TESPy-0.6.2/src/tespy/tools/document_models.py
--rw-rw-rw-   0        0        0    45952 2022-08-14 09:18:38.000000 TESPy-0.6.2/src/tespy/tools/fluid_properties.py
--rw-rw-rw-   0        0        0     3263 2022-05-26 10:30:52.000000 TESPy-0.6.2/src/tespy/tools/global_vars.py
--rw-rw-rw-   0        0        0    28203 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/tools/helpers.py
--rw-rw-rw-   0        0        0     6211 2021-12-29 09:05:28.000000 TESPy-0.6.2/src/tespy/tools/logger.py
--rw-rw-rw-   0        0        0    10707 2022-10-14 16:16:43.000000 TESPy-0.6.2/src/tespy/tools/optimization.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.926281 TESPy-0.6.2/tests/
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.926281 TESPy-0.6.2/tests/test_analyses/
--rw-rw-rw-   0        0        0     4431 2021-12-29 09:05:28.000000 TESPy-0.6.2/tests/test_analyses/test_entropy_analysis.py
--rw-rw-rw-   0        0        0    23460 2022-08-14 09:14:04.000000 TESPy-0.6.2/tests/test_analyses/test_exergy_analysis.py
--rw-rw-rw-   0        0        0    10064 2022-08-21 10:23:40.000000 TESPy-0.6.2/tests/test_busses.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.934278 TESPy-0.6.2/tests/test_components/
--rw-rw-rw-   0        0        0     9436 2021-12-29 09:05:28.000000 TESPy-0.6.2/tests/test_components/test_combustion.py
--rw-rw-rw-   0        0        0     6000 2021-12-29 09:05:28.000000 TESPy-0.6.2/tests/test_components/test_customs.py
--rw-rw-rw-   0        0        0    21957 2022-06-29 12:23:34.000000 TESPy-0.6.2/tests/test_components/test_heat_exchangers.py
--rw-rw-rw-   0        0        0     3255 2021-12-29 09:05:28.000000 TESPy-0.6.2/tests/test_components/test_piping.py
--rw-rw-rw-   0        0        0     7220 2022-06-29 12:23:34.000000 TESPy-0.6.2/tests/test_components/test_reactors.py
--rw-rw-rw-   0        0        0    16918 2022-07-11 13:40:22.000000 TESPy-0.6.2/tests/test_components/test_turbomachinery.py
--rw-rw-rw-   0        0        0     2005 2022-10-14 16:16:43.000000 TESPy-0.6.2/tests/test_connections.py
--rw-rw-rw-   0        0        0    22329 2022-10-14 16:16:43.000000 TESPy-0.6.2/tests/test_errors.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.942279 TESPy-0.6.2/tests/test_models/
--rw-rw-rw-   0        0        0      424 2022-08-14 09:18:38.000000 TESPy-0.6.2/tests/test_models/test_CGAM_model.py
--rw-rw-rw-   0        0        0    12562 2022-10-14 16:16:43.000000 TESPy-0.6.2/tests/test_models/test_heat_pump_model.py
--rw-rw-rw-   0        0        0    18281 2022-01-28 07:48:36.000000 TESPy-0.6.2/tests/test_models/test_solar_energy_generating_system.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.942279 TESPy-0.6.2/tests/test_networks/
--rw-rw-rw-   0        0        0    20390 2022-10-14 16:16:49.000000 TESPy-0.6.2/tests/test_networks/test_network.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.942279 TESPy-0.6.2/tests/test_tools/
--rw-rw-rw-   0        0        0     7887 2022-10-14 16:16:43.000000 TESPy-0.6.2/tests/test_tools/test_characteristics.py
--rw-rw-rw-   0        0        0    13618 2022-06-29 12:23:34.000000 TESPy-0.6.2/tests/test_tools/test_fluid_properties.py
--rw-rw-rw-   0        0        0     2004 2021-12-29 09:05:28.000000 TESPy-0.6.2/tests/test_tools/test_helpers.py
--rw-rw-rw-   0        0        0     2511 2022-10-14 16:16:43.000000 TESPy-0.6.2/tox.ini
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.574276 TESPy-0.6.2/tutorial/
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.950279 TESPy-0.6.2/tutorial/advanced/
--rw-rw-rw-   0        0        0     9782 2022-10-14 16:16:43.000000 TESPy-0.6.2/tutorial/advanced/optimization_example.py
--rw-rw-rw-   0        0        0     9658 2022-10-14 16:16:43.000000 TESPy-0.6.2/tutorial/advanced/starting_values.py
--rw-rw-rw-   0        0        0     6276 2022-10-14 16:16:43.000000 TESPy-0.6.2/tutorial/advanced/stepwise.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.950279 TESPy-0.6.2/tutorial/basics/
--rw-rw-rw-   0        0        0     4297 2022-10-14 16:16:43.000000 TESPy-0.6.2/tutorial/basics/district_heating.py
--rw-rw-rw-   0        0        0     5201 2022-10-14 16:16:49.000000 TESPy-0.6.2/tutorial/basics/gas_turbine.py
--rw-rw-rw-   0        0        0     3257 2022-10-14 16:16:43.000000 TESPy-0.6.2/tutorial/basics/heat_pump.py
--rw-rw-rw-   0        0        0     4702 2022-10-14 16:16:43.000000 TESPy-0.6.2/tutorial/basics/rankine.py
-drwxrwxrwx   0        0        0        0 2022-10-14 16:19:43.958278 TESPy-0.6.2/tutorial/heat_pump_exergy/
--rw-rw-rw-   0        0        0     4322 2022-10-14 16:16:43.000000 TESPy-0.6.2/tutorial/heat_pump_exergy/NH3.py
--rw-rw-rw-   0        0        0    10999 2022-10-14 16:16:43.000000 TESPy-0.6.2/tutorial/heat_pump_exergy/NH3_calculations.py
--rw-rw-rw-   0        0        0     4330 2022-10-14 16:16:43.000000 TESPy-0.6.2/tutorial/heat_pump_exergy/R410A.py
--rw-rw-rw-   0        0        0    11028 2022-10-14 16:16:43.000000 TESPy-0.6.2/tutorial/heat_pump_exergy/R410A_calculations.py
--rw-rw-rw-   0        0        0     8280 2022-10-14 16:16:43.000000 TESPy-0.6.2/tutorial/heat_pump_exergy/plots.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.498695 TESPy-0.6.3/
+-rw-rw-rw-   0        0        0      156 2021-10-04 06:28:48.000000 TESPy-0.6.3/.coveragerc
+-rw-rw-rw-   0        0        0      265 2021-10-04 06:28:48.000000 TESPy-0.6.3/.editorconfig
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.026681 TESPy-0.6.3/.github/
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.082698 TESPy-0.6.3/.github/workflows/
+-rw-rw-rw-   0        0        0      909 2023-07-20 10:11:41.000000 TESPy-0.6.3/.github/workflows/packaging.yml
+-rw-rw-rw-   0        0        0     1307 2023-07-20 10:11:41.000000 TESPy-0.6.3/.github/workflows/tox_checks.yml
+-rw-rw-rw-   0        0        0     1035 2023-07-20 10:11:41.000000 TESPy-0.6.3/.github/workflows/tox_pytest.yml
+-rw-rw-rw-   0        0        0      559 2023-07-30 13:38:28.000000 TESPy-0.6.3/.gitignore
+-rw-rw-rw-   0        0        0     1446 2021-10-04 06:28:48.000000 TESPy-0.6.3/.pep8speaks.yml
+-rw-rw-rw-   0        0        0      341 2023-07-30 13:38:28.000000 TESPy-0.6.3/.readthedocs.yml
+-rw-rw-rw-   0        0        0     3269 2021-10-04 06:28:48.000000 TESPy-0.6.3/CODE_OF_CONDUCT.md
+-rw-rw-rw-   0        0        0      154 2022-01-28 07:48:36.000000 TESPy-0.6.3/CONTRIBUTING.md
+-rw-rw-rw-   0        0        0     1105 2023-07-20 10:11:41.000000 TESPy-0.6.3/LICENSE
+-rw-rw-rw-   0        0        0      281 2023-07-20 10:11:41.000000 TESPy-0.6.3/MANIFEST.in
+-rw-rw-rw-   0        0        0     8066 2023-07-30 16:30:00.498695 TESPy-0.6.3/PKG-INFO
+-rw-rw-rw-   0        0        0      765 2021-10-04 06:28:48.000000 TESPy-0.6.3/PULL_REQUEST_TEMPLATE.md
+-rw-rw-rw-   0        0        0     9166 2023-07-20 10:11:41.000000 TESPy-0.6.3/README.rst
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.106700 TESPy-0.6.3/docs/
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.034705 TESPy-0.6.3/docs/_static/
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.106700 TESPy-0.6.3/docs/_static/css/
+-rw-rw-rw-   0        0        0      180 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/css/custom.css
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.114699 TESPy-0.6.3/docs/_static/images/
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.034705 TESPy-0.6.3/docs/_static/images/advanced/
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.122700 TESPy-0.6.3/docs/_static/images/advanced/exergy/
+-rw-rw-rw-   0        0        0   129643 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/advanced/exergy/flowsheet.svg
+-rw-rw-rw-   0        0        0   136810 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/advanced/exergy/flowsheet_darkmode.svg
+-rw-rw-rw-   0        0        0    32134 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/advanced/exergy/sankey.svg
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.154701 TESPy-0.6.3/docs/_static/images/basics/
+-rw-rw-rw-   0        0        0    17276 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/district_heating.svg
+-rw-rw-rw-   0        0        0    18111 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/district_heating_darkmode.svg
+-rw-rw-rw-   0        0        0    69064 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/district_heating_partload.svg
+-rw-rw-rw-   0        0        0    71199 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/district_heating_partload_darkmode.svg
+-rw-rw-rw-   0        0        0    15810 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/gas_turbine.svg
+-rw-rw-rw-   0        0        0    16340 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/gas_turbine_darkmode.svg
+-rw-rw-rw-   0        0        0    32095 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/gas_turbine_fuel_composition.svg
+-rw-rw-rw-   0        0        0    32756 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/gas_turbine_fuel_composition_darkmode.svg
+-rw-rw-rw-   0        0        0    29612 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/gas_turbine_oxygen.svg
+-rw-rw-rw-   0        0        0    30202 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/gas_turbine_oxygen_darkmode.svg
+-rw-rw-rw-   0        0        0    57559 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/gas_turbine_parametric.svg
+-rw-rw-rw-   0        0        0    59255 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/gas_turbine_parametric_darkmode.svg
+-rw-rw-rw-   0        0        0    14362 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/heat_pump.svg
+-rw-rw-rw-   0        0        0    14866 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/heat_pump_darkmode.svg
+-rw-rw-rw-   0        0        0    53423 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/heat_pump_parametric.svg
+-rw-rw-rw-   0        0        0    54994 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/heat_pump_parametric_darkmode.svg
+-rw-rw-rw-   0        0        0    16030 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/modeling_concept.svg
+-rw-rw-rw-   0        0        0    16137 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/rankine_cycle.svg
+-rw-rw-rw-   0        0        0    16871 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/rankine_cycle_darkmode.svg
+-rw-rw-rw-   0        0        0    59916 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/rankine_parametric.svg
+-rw-rw-rw-   0        0        0    61115 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/rankine_parametric_darkmode.svg
+-rw-rw-rw-   0        0        0    26962 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/rankine_partload.svg
+-rw-rw-rw-   0        0        0    27517 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/basics/rankine_partload_darkmode.svg
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.162699 TESPy-0.6.3/docs/_static/images/examples/
+-rw-rw-rw-   0        0        0   139795 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/examples/GRC_flowsheet.svg
+-rw-rw-rw-   0        0        0   157545 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/examples/GRC_flowsheet_darkmode.svg
+-rw-rw-rw-   0        0        0    88269 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/examples/ORC_parametric_flowsheet.svg
+-rw-rw-rw-   0        0        0    88176 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/examples/ORC_parametric_flowsheet_darkmode.svg
+-rw-rw-rw-   0        0        0   409001 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/examples/PM_CAES_graphical-abstract.svg
+-rw-rw-rw-   0        0        0   417664 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/examples/PM_CAES_graphical-abstract_darkmode.svg
+-rw-rw-rw-   0        0        0    39020 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/logo_tespy_big.svg
+-rw-rw-rw-   0        0        0    39647 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/logo_tespy_big_darkmode.svg
+-rw-rw-rw-   0        0        0    17145 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/logo_tespy_big_editable_font.svg
+-rw-rw-rw-   0        0        0    23121 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/logo_tespy_mid.svg
+-rw-rw-rw-   0        0        0    23260 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/logo_tespy_mid_darkmode.svg
+-rw-rw-rw-   0        0        0    15239 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/logo_tespy_mid_editable_font.svg
+-rw-rw-rw-   0        0        0    13302 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/logo_tespy_small.svg
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.178697 TESPy-0.6.3/docs/_static/images/modules/
+-rw-rw-rw-   0        0        0   157002 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/modules/Ts_diagram_states.svg
+-rw-rw-rw-   0        0        0     8644 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/modules/characteristics.svg
+-rw-rw-rw-   0        0        0     8414 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/modules/characteristics_darkmode.svg
+-rw-rw-rw-   0        0        0    11300 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/modules/connections.svg
+-rw-rw-rw-   0        0        0    11315 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/modules/connections_darkmode.svg
+-rw-rw-rw-   0        0        0   134345 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/modules/fluid_properties.svg
+-rw-rw-rw-   0        0        0   125300 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/modules/fluid_properties_darkmode.svg
+-rw-rw-rw-   0        0        0   168665 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/modules/logph_diagram_states.svg
+-rw-rw-rw-   0        0        0    17587 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/modules/subsystem_waste_heat_generator.svg
+-rw-rw-rw-   0        0        0    17663 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/modules/subsystem_waste_heat_generator_darkmode.svg
+-rw-rw-rw-   0        0        0   121692 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/modules/ude.svg
+-rw-rw-rw-   0        0        0   125035 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/modules/ude_darkmode.svg
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.186700 TESPy-0.6.3/docs/_static/images/tutorials/
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.194698 TESPy-0.6.3/docs/_static/images/tutorials/district_heating_system/
+-rw-rw-rw-   0        0        0    33944 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/district_heating_system/dhs.svg
+-rw-rw-rw-   0        0        0    20206 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/district_heating_system/dhs_closed.svg
+-rw-rw-rw-   0        0        0    12074 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/district_heating_system/dhs_forks.svg
+-rw-rw-rw-   0        0        0    21711 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/district_heating_system/dhs_open.svg
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.210698 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/
+-rw-rw-rw-   0        0        0   168149 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/NH3_logph.svg
+-rw-rw-rw-   0        0        0    23347 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/NH3_sankey.svg
+-rw-rw-rw-   0        0        0    60290 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_E_D.svg
+-rw-rw-rw-   0        0        0    61853 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_E_D_darkmode.svg
+-rw-rw-rw-   0        0        0    61177 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Q.svg
+-rw-rw-rw-   0        0        0    62156 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Q_darkmode.svg
+-rw-rw-rw-   0        0        0    66033 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Ths.svg
+-rw-rw-rw-   0        0        0    67428 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Ths_darkmode.svg
+-rw-rw-rw-   0        0        0    52499 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_eps_Tamb_Tgeo.svg
+-rw-rw-rw-   0        0        0    53372 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_eps_Tamb_Tgeo_darkmode.svg
+-rw-rw-rw-   0        0        0    29826 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/flowsheet.svg
+-rw-rw-rw-   0        0        0    29835 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/flowsheet_darkmode.svg
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.218701 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_starting_values/
+-rw-rw-rw-   0        0        0    27850 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_starting_values/COP_by_wf.svg
+-rw-rw-rw-   0        0        0    28404 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_starting_values/COP_by_wf_darkmode.svg
+-rw-rw-rw-   0        0        0    30290 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_starting_values/flowsheet.svg
+-rw-rw-rw-   0        0        0    30299 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_starting_values/flowsheet_darkmode.svg
+-rw-rw-rw-   0        0        0   227184 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_starting_values/logph.svg
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.226699 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_stepwise/
+-rw-rw-rw-   0        0        0    46257 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet.svg
+-rw-rw-rw-   0        0        0    46240 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_darkmode.svg
+-rw-rw-rw-   0        0        0    46286 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p1.svg
+-rw-rw-rw-   0        0        0    46277 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p1_darkmode.svg
+-rw-rw-rw-   0        0        0    46669 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p2.svg
+-rw-rw-rw-   0        0        0    46657 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p2_darkmode.svg
+-rw-rw-rw-   0        0        0    52832 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/osmses-2023.svg
+-rw-rw-rw-   0        0        0    53182 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/osmses-2023_darkmode.svg
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.234699 TESPy-0.6.3/docs/_static/images/tutorials/pygmo_optimization/
+-rw-rw-rw-   0        0        0    33530 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/pygmo_optimization/flowsheet.svg
+-rw-rw-rw-   0        0        0    34684 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/pygmo_optimization/flowsheet_darkmode.svg
+-rw-rw-rw-   0        0        0   190475 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/pygmo_optimization/pygmo_optimization.svg
+-rw-rw-rw-   0        0        0   192983 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_static/images/tutorials/pygmo_optimization/pygmo_optimization_darkmode.svg
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.234699 TESPy-0.6.3/docs/_templates/
+-rw-rw-rw-   0        0        0        0 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/_templates/index.html
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.234699 TESPy-0.6.3/docs/advanced/
+-rw-rw-rw-   0        0        0    20688 2023-07-30 13:38:28.000000 TESPy-0.6.3/docs/advanced/exergy.rst
+-rw-rw-rw-   0        0        0       92 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/advanced/optimization.rst
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.242700 TESPy-0.6.3/docs/api/
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.322698 TESPy-0.6.3/docs/api/_images/
+-rw-rw-rw-   0        0        0     9313 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/CombustionChamber.svg
+-rw-rw-rw-   0        0        0     9682 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/CombustionChamber_darkmode.svg
+-rw-rw-rw-   0        0        0    15877 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/CombustionEngine.svg
+-rw-rw-rw-   0        0        0    16472 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/CombustionEngine_darkmode.svg
+-rw-rw-rw-   0        0        0     7484 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Compressor.svg
+-rw-rw-rw-   0        0        0     7661 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Compressor_darkmode.svg
+-rw-rw-rw-   0        0        0     9565 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Condenser.svg
+-rw-rw-rw-   0        0        0    10115 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Condenser_darkmode.svg
+-rw-rw-rw-   0        0        0     8898 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/DropletSeparator.svg
+-rw-rw-rw-   0        0        0     9039 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/DropletSeparator_darkmode.svg
+-rw-rw-rw-   0        0        0    10414 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Drum.svg
+-rw-rw-rw-   0        0        0    10583 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Drum_darkmode.svg
+-rw-rw-rw-   0        0        0    15148 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/FuelCell.svg
+-rw-rw-rw-   0        0        0    15153 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/FuelCell_darkmode.svg
+-rw-rw-rw-   0        0        0    10283 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/HeatExchanger.svg
+-rw-rw-rw-   0        0        0    10403 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/HeatExchanger_darkmode.svg
+-rw-rw-rw-   0        0        0    12851 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Merge.svg
+-rw-rw-rw-   0        0        0    13017 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Merge_darkmode.svg
+-rw-rw-rw-   0        0        0     8013 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/ORCEvaporator.svg
+-rw-rw-rw-   0        0        0     7643 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/ParabolicTrough.svg
+-rw-rw-rw-   0        0        0     7823 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/ParabolicTrough_darkmode.svg
+-rw-rw-rw-   0        0        0     6462 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Pipe.svg
+-rw-rw-rw-   0        0        0     6640 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Pipe_darkmode.svg
+-rw-rw-rw-   0        0        0     7414 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Pump.svg
+-rw-rw-rw-   0        0        0     7478 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Pump_darkmode.svg
+-rw-rw-rw-   0        0        0     6810 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/SolarCollector.svg
+-rw-rw-rw-   0        0        0     6875 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/SolarCollector_darkmode.svg
+-rw-rw-rw-   0        0        0    12813 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Splitter.svg
+-rw-rw-rw-   0        0        0    12979 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Splitter_darkmode.svg
+-rw-rw-rw-   0        0        0    12381 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/SubsystemInterface.svg
+-rw-rw-rw-   0        0        0    12558 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/SubsystemInterface_darkmode.svg
+-rw-rw-rw-   0        0        0     6668 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Turbine.svg
+-rw-rw-rw-   0        0        0     6677 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Turbine_darkmode.svg
+-rw-rw-rw-   0        0        0     6491 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Valve.svg
+-rw-rw-rw-   0        0        0     6668 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/Valve_darkmode.svg
+-rw-rw-rw-   0        0        0    13372 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/WaterElectrolyzer.svg
+-rw-rw-rw-   0        0        0    15165 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/_images/WaterElectrolyzer_darkmode.svg
+-rw-rw-rw-   0        0        0    40711 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/combustion_engine_Q1_char_DEFAULT.svg
+-rw-rw-rw-   0        0        0    40966 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/combustion_engine_Q2_char_DEFAULT.svg
+-rw-rw-rw-   0        0        0    38781 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/combustion_engine_Qloss_char_DEFAULT.svg
+-rw-rw-rw-   0        0        0    37655 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/combustion_engine_tiP_char_DEFAULT.svg
+-rw-rw-rw-   0        0        0    49048 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/compressor_char_map_eta_s_DEFAULT.svg
+-rw-rw-rw-   0        0        0    46950 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/compressor_char_map_pr_DEFAULT.svg
+-rw-rw-rw-   0        0        0    39251 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/compressor_eta_s_char_DEFAULT.svg
+-rw-rw-rw-   0        0        0    40197 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/condenser_kA_char1_DEFAULT.svg
+-rw-rw-rw-   0        0        0    41171 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/condenser_kA_char2_DEFAULT.svg
+-rw-rw-rw-   0        0        0    42372 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/desuperheater_kA_char1_DEFAULT.svg
+-rw-rw-rw-   0        0        0    41171 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/desuperheater_kA_char2_DEFAULT.svg
+-rw-rw-rw-   0        0        0    43523 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/heat_exchanger_kA_char1_CONDENSING_FLUID.svg
+-rw-rw-rw-   0        0        0    42372 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/heat_exchanger_kA_char1_DEFAULT.svg
+-rw-rw-rw-   0        0        0    41171 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/heat_exchanger_kA_char2_DEFAULT.svg
+-rw-rw-rw-   0        0        0    45010 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/heat_exchanger_kA_char2_EVAPORATING_FLUID.svg
+-rw-rw-rw-   0        0        0    42314 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/heat_exchanger_simple_kA_char_DEFAULT.svg
+-rw-rw-rw-   0        0        0    42314 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/pipe_kA_char_DEFAULT.svg
+-rw-rw-rw-   0        0        0    40653 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/pump_eta_s_char_DEFAULT.svg
+-rw-rw-rw-   0        0        0    39798 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/turbine_eta_s_char_DEFAULT.svg
+-rw-rw-rw-   0        0        0    40222 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/turbine_eta_s_char_TRAUPEL.svg
+-rw-rw-rw-   0        0        0    36210 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/api/_images/water_electrolyzer_eta_char_DEFAULT.svg
+-rw-rw-rw-   0        0        0     6356 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/components.rst
+-rw-rw-rw-   0        0        0      496 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/connections.rst
+-rw-rw-rw-   0        0        0     4204 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/data.rst
+-rw-rw-rw-   0        0        0      493 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/networks.rst
+-rw-rw-rw-   0        0        0     1501 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api/tools.rst
+-rw-rw-rw-   0        0        0      532 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/api.rst
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.330697 TESPy-0.6.3/docs/basics/
+-rw-rw-rw-   0        0        0     5530 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/basics/district_heating.rst
+-rw-rw-rw-   0        0        0    10867 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/basics/gas_turbine.rst
+-rw-rw-rw-   0        0        0     6690 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/basics/heat_pump.rst
+-rw-rw-rw-   0        0        0     7430 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/basics/intro.rst
+-rw-rw-rw-   0        0        0    10658 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/basics/rankine_cycle.rst
+-rw-rw-rw-   0        0        0     2463 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/basics.rst
+-rw-rw-rw-   0        0        0     2743 2023-07-30 13:38:28.000000 TESPy-0.6.3/docs/benchmarks.rst
+-rw-rw-rw-   0        0        0     4377 2023-07-30 13:38:28.000000 TESPy-0.6.3/docs/conf.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.330697 TESPy-0.6.3/docs/development/
+-rw-rw-rw-   0        0        0     7313 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/development/how.rst
+-rw-rw-rw-   0        0        0     2831 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/development/what.rst
+-rw-rw-rw-   0        0        0     4318 2023-07-30 13:38:28.000000 TESPy-0.6.3/docs/examples.rst
+-rw-rw-rw-   0        0        0      661 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/index.rst
+-rw-rw-rw-   0        0        0     2890 2023-07-30 13:38:28.000000 TESPy-0.6.3/docs/installation.rst
+-rw-rw-rw-   0        0        0     3847 2023-07-30 13:38:28.000000 TESPy-0.6.3/docs/introduction.rst
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.338697 TESPy-0.6.3/docs/modules/
+-rw-rw-rw-   0        0        0     5088 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/modules/characteristics.rst
+-rw-rw-rw-   0        0        0    34783 2023-07-30 13:47:46.000000 TESPy-0.6.3/docs/modules/components.rst
+-rw-rw-rw-   0        0        0    13033 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/modules/connections.rst
+-rw-rw-rw-   0        0        0     6383 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/modules/fluid_properties.rst
+-rw-rw-rw-   0        0        0    33480 2023-07-30 13:38:28.000000 TESPy-0.6.3/docs/modules/networks.rst
+-rw-rw-rw-   0        0        0    11362 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/modules/ude.rst
+-rw-rw-rw-   0        0        0     2398 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/modules.rst
+-rw-rw-rw-   0        0        0    11798 2023-07-30 13:38:28.000000 TESPy-0.6.3/docs/references.bib
+-rw-rw-rw-   0        0        0      886 2023-07-30 13:38:28.000000 TESPy-0.6.3/docs/regular_meeting.rst
+-rw-rw-rw-   0        0        0       75 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/requirements.txt
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.338697 TESPy-0.6.3/docs/scripts/
+-rw-rw-rw-   0        0        0     2914 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/scripts/generate_tespy_data_module.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.346696 TESPy-0.6.3/docs/tutorials/
+-rw-rw-rw-   0        0        0     2363 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/tutorials/district_heating.rst
+-rw-rw-rw-   0        0        0    32219 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/tutorials/heat_pump_exergy.rst
+-rw-rw-rw-   0        0        0    21507 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/tutorials/heat_pump_steps.rst
+-rw-rw-rw-   0        0        0     7918 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/tutorials/pygmo_optimization.rst
+-rw-rw-rw-   0        0        0     8542 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/tutorials/starting_values.rst
+-rw-rw-rw-   0        0        0     3594 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/tutorials.rst
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.378736 TESPy-0.6.3/docs/whats_new/
+-rw-rw-rw-   0        0        0      240 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/whats_new/v0-0-1.rst
+-rw-rw-rw-   0        0        0     1548 2023-07-30 13:38:28.000000 TESPy-0.6.3/docs/whats_new/v0-0-2.rst
+-rw-rw-rw-   0        0        0     4807 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-0-3.rst
+-rw-rw-rw-   0        0        0     1994 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/whats_new/v0-0-4.rst
+-rw-rw-rw-   0        0        0     3293 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-0-5.rst
+-rw-rw-rw-   0        0        0     3987 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/whats_new/v0-1-0.rst
+-rw-rw-rw-   0        0        0     4347 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-1-1.rst
+-rw-rw-rw-   0        0        0     3842 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-1-2.rst
+-rw-rw-rw-   0        0        0     2675 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-1-3.rst
+-rw-rw-rw-   0        0        0      616 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/whats_new/v0-1-4.rst
+-rw-rw-rw-   0        0        0     8338 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-2-0.rst
+-rw-rw-rw-   0        0        0     1982 2022-05-26 10:30:52.000000 TESPy-0.6.3/docs/whats_new/v0-2-1.rst
+-rw-rw-rw-   0        0        0     3064 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-2-2.rst
+-rw-rw-rw-   0        0        0    11252 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-3-0.rst
+-rw-rw-rw-   0        0        0      314 2022-05-26 10:30:52.000000 TESPy-0.6.3/docs/whats_new/v0-3-1.rst
+-rw-rw-rw-   0        0        0     2062 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-3-2.rst
+-rw-rw-rw-   0        0        0     1345 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/whats_new/v0-3-3.rst
+-rw-rw-rw-   0        0        0     1471 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-3-4.rst
+-rw-rw-rw-   0        0        0    11174 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-4-0.rst
+-rw-rw-rw-   0        0        0     1126 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-4-1.rst
+-rw-rw-rw-   0        0        0     1589 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/whats_new/v0-4-2.rst
+-rw-rw-rw-   0        0        0      563 2021-10-04 06:28:48.000000 TESPy-0.6.3/docs/whats_new/v0-4-3-001.rst
+-rw-rw-rw-   0        0        0      656 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-4-3-003.rst
+-rw-rw-rw-   0        0        0     3355 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-4-3.rst
+-rw-rw-rw-   0        0        0     1183 2022-01-28 07:48:36.000000 TESPy-0.6.3/docs/whats_new/v0-4-4.rst
+-rw-rw-rw-   0        0        0      801 2022-01-28 07:48:36.000000 TESPy-0.6.3/docs/whats_new/v0-5-0.rst
+-rw-rw-rw-   0        0        0      930 2022-05-26 10:30:52.000000 TESPy-0.6.3/docs/whats_new/v0-5-1.rst
+-rw-rw-rw-   0        0        0     2644 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-6-0.rst
+-rw-rw-rw-   0        0        0     2064 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-6-1.rst
+-rw-rw-rw-   0        0        0      385 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new/v0-6-2.rst
+-rw-rw-rw-   0        0        0     2841 2023-07-30 13:39:12.000000 TESPy-0.6.3/docs/whats_new/v0-6-3.rst
+-rw-rw-rw-   0        0        0     1217 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/whats_new.rst
+-rw-rw-rw-   0        0        0       90 2023-07-20 10:11:41.000000 TESPy-0.6.3/docs/zliterature.rst
+-rw-rw-rw-   0        0        0     6582 2023-07-20 10:11:41.000000 TESPy-0.6.3/paper.bib
+-rw-rw-rw-   0        0        0    11023 2021-10-04 06:28:48.000000 TESPy-0.6.3/paper.md
+-rw-rw-rw-   0        0        0      104 2021-10-04 06:28:48.000000 TESPy-0.6.3/pyproject.toml
+-rw-rw-rw-   0        0        0      825 2023-07-30 16:30:00.498695 TESPy-0.6.3/setup.cfg
+-rw-rw-rw-   0        0        0     2560 2023-07-30 14:33:20.000000 TESPy-0.6.3/setup.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.042697 TESPy-0.6.3/src/
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.386740 TESPy-0.6.3/src/TESPy.egg-info/
+-rw-rw-rw-   0        0        0     8066 2023-07-30 16:29:59.000000 TESPy-0.6.3/src/TESPy.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0    13449 2023-07-30 16:29:59.000000 TESPy-0.6.3/src/TESPy.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2023-07-30 16:29:59.000000 TESPy-0.6.3/src/TESPy.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0        2 2021-10-04 07:07:30.000000 TESPy-0.6.3/src/TESPy.egg-info/not-zip-safe
+-rw-rw-rw-   0        0        0      191 2023-07-30 16:29:59.000000 TESPy-0.6.3/src/TESPy.egg-info/requires.txt
+-rw-rw-rw-   0        0        0        6 2023-07-30 16:29:59.000000 TESPy-0.6.3/src/TESPy.egg-info/top_level.txt
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.386740 TESPy-0.6.3/src/tespy/
+-rw-rw-rw-   0        0        0     1178 2023-07-30 13:39:42.000000 TESPy-0.6.3/src/tespy/__init__.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.386740 TESPy-0.6.3/src/tespy/components/
+-rw-rw-rw-   0        0        0     1720 2023-07-30 13:48:26.000000 TESPy-0.6.3/src/tespy/components/__init__.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.394735 TESPy-0.6.3/src/tespy/components/basics/
+-rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.3/src/tespy/components/basics/__init__.py
+-rw-rw-rw-   0        0        0     6791 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/components/basics/cycle_closer.py
+-rw-rw-rw-   0        0        0     3017 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/components/basics/sink.py
+-rw-rw-rw-   0        0        0     3056 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/components/basics/source.py
+-rw-rw-rw-   0        0        0     5779 2023-07-30 14:36:03.000000 TESPy-0.6.3/src/tespy/components/basics/subsystem_interface.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.402710 TESPy-0.6.3/src/tespy/components/combustion/
+-rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.3/src/tespy/components/combustion/__init__.py
+-rw-rw-rw-   0        0        0    47745 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/components/combustion/base.py
+-rw-rw-rw-   0        0        0    13880 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/components/combustion/diabatic.py
+-rw-rw-rw-   0        0        0    62834 2023-07-30 13:50:23.000000 TESPy-0.6.3/src/tespy/components/combustion/engine.py
+-rw-rw-rw-   0        0        0    49708 2023-07-30 14:47:45.000000 TESPy-0.6.3/src/tespy/components/component.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.402710 TESPy-0.6.3/src/tespy/components/customs/
+-rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.3/src/tespy/components/customs/__init__.py
+-rw-rw-rw-   0        0        0    27584 2023-07-30 15:01:20.000000 TESPy-0.6.3/src/tespy/components/customs/orc_evaporator.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.410796 TESPy-0.6.3/src/tespy/components/heat_exchangers/
+-rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.3/src/tespy/components/heat_exchangers/__init__.py
+-rw-rw-rw-   0        0        0    38121 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/components/heat_exchangers/base.py
+-rw-rw-rw-   0        0        0    18275 2023-07-30 14:47:45.000000 TESPy-0.6.3/src/tespy/components/heat_exchangers/condenser.py
+-rw-rw-rw-   0        0        0     9133 2023-07-20 10:11:41.000000 TESPy-0.6.3/src/tespy/components/heat_exchangers/desuperheater.py
+-rw-rw-rw-   0        0        0    13841 2023-07-30 14:47:45.000000 TESPy-0.6.3/src/tespy/components/heat_exchangers/parabolic_trough.py
+-rw-rw-rw-   0        0        0    42514 2023-07-30 14:47:45.000000 TESPy-0.6.3/src/tespy/components/heat_exchangers/simple.py
+-rw-rw-rw-   0        0        0    12066 2023-07-30 14:47:45.000000 TESPy-0.6.3/src/tespy/components/heat_exchangers/solar_collector.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.418743 TESPy-0.6.3/src/tespy/components/nodes/
+-rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.3/src/tespy/components/nodes/__init__.py
+-rw-rw-rw-   0        0        0     5773 2023-07-30 13:32:17.000000 TESPy-0.6.3/src/tespy/components/nodes/base.py
+-rw-rw-rw-   0        0        0    16759 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/components/nodes/droplet_separator.py
+-rw-rw-rw-   0        0        0    11986 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/components/nodes/drum.py
+-rw-rw-rw-   0        0        0    18294 2023-07-30 13:50:23.000000 TESPy-0.6.3/src/tespy/components/nodes/merge.py
+-rw-rw-rw-   0        0        0    11480 2023-07-30 13:50:23.000000 TESPy-0.6.3/src/tespy/components/nodes/separator.py
+-rw-rw-rw-   0        0        0    10584 2023-07-30 13:50:23.000000 TESPy-0.6.3/src/tespy/components/nodes/splitter.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.426733 TESPy-0.6.3/src/tespy/components/piping/
+-rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.3/src/tespy/components/piping/__init__.py
+-rw-rw-rw-   0        0        0     5205 2023-07-30 13:47:46.000000 TESPy-0.6.3/src/tespy/components/piping/pipe.py
+-rw-rw-rw-   0        0        0    13916 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/components/piping/valve.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.426733 TESPy-0.6.3/src/tespy/components/reactors/
+-rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.3/src/tespy/components/reactors/__init__.py
+-rw-rw-rw-   0        0        0    33397 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/components/reactors/fuel_cell.py
+-rw-rw-rw-   0        0        0    44842 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/components/reactors/water_electrolyzer.py
+-rw-rw-rw-   0        0        0     2351 2023-07-20 10:11:41.000000 TESPy-0.6.3/src/tespy/components/subsystem.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.434741 TESPy-0.6.3/src/tespy/components/turbomachinery/
+-rw-rw-rw-   0        0        0       21 2021-10-04 06:28:48.000000 TESPy-0.6.3/src/tespy/components/turbomachinery/__init__.py
+-rw-rw-rw-   0        0        0     7787 2023-07-30 13:32:17.000000 TESPy-0.6.3/src/tespy/components/turbomachinery/base.py
+-rw-rw-rw-   0        0        0    24782 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/components/turbomachinery/compressor.py
+-rw-rw-rw-   0        0        0    18599 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/components/turbomachinery/pump.py
+-rw-rw-rw-   0        0        0    18116 2023-07-30 13:50:23.000000 TESPy-0.6.3/src/tespy/components/turbomachinery/turbine.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.442747 TESPy-0.6.3/src/tespy/connections/
+-rw-rw-rw-   0        0        0      147 2022-01-28 07:48:36.000000 TESPy-0.6.3/src/tespy/connections/__init__.py
+-rw-rw-rw-   0        0        0    16074 2023-07-30 14:35:02.000000 TESPy-0.6.3/src/tespy/connections/bus.py
+-rw-rw-rw-   0        0        0    24390 2023-07-30 14:47:45.000000 TESPy-0.6.3/src/tespy/connections/connection.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.442747 TESPy-0.6.3/src/tespy/data/
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.442747 TESPy-0.6.3/src/tespy/data/ChemEx/
+-rw-rw-rw-   0        0        0     9270 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/data/ChemEx/Ahrendts.json
+-rw-rw-rw-   0        0        0     8407 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/data/ChemEx/Szargut1988.json
+-rw-rw-rw-   0        0        0     8578 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/data/ChemEx/Szargut2007.json
+-rw-rw-rw-   0        0        0     8047 2021-10-04 06:28:48.000000 TESPy-0.6.3/src/tespy/data/char_lines.json
+-rw-rw-rw-   0        0        0     3726 2021-10-04 06:28:48.000000 TESPy-0.6.3/src/tespy/data/char_maps.json
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.450722 TESPy-0.6.3/src/tespy/networks/
+-rw-rw-rw-   0        0        0      118 2022-01-28 07:48:36.000000 TESPy-0.6.3/src/tespy/networks/__init__.py
+-rw-rw-rw-   0        0        0   123718 2023-07-30 14:47:45.000000 TESPy-0.6.3/src/tespy/networks/network.py
+-rw-rw-rw-   0        0        0    22823 2023-07-30 14:47:45.000000 TESPy-0.6.3/src/tespy/networks/network_reader.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.458702 TESPy-0.6.3/src/tespy/tools/
+-rw-rw-rw-   0        0        0      884 2023-07-30 14:47:45.000000 TESPy-0.6.3/src/tespy/tools/__init__.py
+-rw-rw-rw-   0        0        0    38320 2023-07-30 13:47:46.000000 TESPy-0.6.3/src/tespy/tools/analyses.py
+-rw-rw-rw-   0        0        0    17059 2023-07-20 10:11:41.000000 TESPy-0.6.3/src/tespy/tools/characteristics.py
+-rw-rw-rw-   0        0        0    14693 2023-07-30 13:50:25.000000 TESPy-0.6.3/src/tespy/tools/data_containers.py
+-rw-rw-rw-   0        0        0    37268 2022-08-18 06:28:08.000000 TESPy-0.6.3/src/tespy/tools/document_models.py
+-rw-rw-rw-   0        0        0    49691 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/tools/fluid_properties.py
+-rw-rw-rw-   0        0        0     3454 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/tools/global_vars.py
+-rw-rw-rw-   0        0        0    28675 2023-07-30 13:38:28.000000 TESPy-0.6.3/src/tespy/tools/helpers.py
+-rw-rw-rw-   0        0        0    14506 2023-07-20 10:11:41.000000 TESPy-0.6.3/src/tespy/tools/logger.py
+-rw-rw-rw-   0        0        0    10738 2023-07-20 10:11:41.000000 TESPy-0.6.3/src/tespy/tools/optimization.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.458702 TESPy-0.6.3/tests/
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.466733 TESPy-0.6.3/tests/test_analyses/
+-rw-rw-rw-   0        0        0     4378 2023-07-30 14:47:51.000000 TESPy-0.6.3/tests/test_analyses/test_entropy_analysis.py
+-rw-rw-rw-   0        0        0    24516 2023-07-30 14:47:51.000000 TESPy-0.6.3/tests/test_analyses/test_exergy_analysis.py
+-rw-rw-rw-   0        0        0    10330 2023-07-30 14:44:28.000000 TESPy-0.6.3/tests/test_busses.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.474789 TESPy-0.6.3/tests/test_components/
+-rw-rw-rw-   0        0        0    11305 2023-07-30 13:38:28.000000 TESPy-0.6.3/tests/test_components/test_combustion.py
+-rw-rw-rw-   0        0        0     5965 2023-07-30 13:38:28.000000 TESPy-0.6.3/tests/test_components/test_customs.py
+-rw-rw-rw-   0        0        0    23850 2023-07-30 14:47:51.000000 TESPy-0.6.3/tests/test_components/test_heat_exchangers.py
+-rw-rw-rw-   0        0        0     3161 2023-07-30 13:38:28.000000 TESPy-0.6.3/tests/test_components/test_piping.py
+-rw-rw-rw-   0        0        0     7187 2023-07-30 13:38:28.000000 TESPy-0.6.3/tests/test_components/test_reactors.py
+-rw-rw-rw-   0        0        0    17000 2023-07-30 13:38:28.000000 TESPy-0.6.3/tests/test_components/test_turbomachinery.py
+-rw-rw-rw-   0        0        0     2012 2023-07-30 13:38:28.000000 TESPy-0.6.3/tests/test_connections.py
+-rw-rw-rw-   0        0        0    22343 2023-07-30 13:38:28.000000 TESPy-0.6.3/tests/test_errors.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.474789 TESPy-0.6.3/tests/test_models/
+-rw-rw-rw-   0        0        0      996 2023-07-30 13:38:28.000000 TESPy-0.6.3/tests/test_models/cgam-ebsilon-results.csv
+-rw-rw-rw-   0        0        0     7544 2023-07-30 13:38:28.000000 TESPy-0.6.3/tests/test_models/test_CGAM_model.py
+-rw-rw-rw-   0        0        0    12569 2023-07-30 13:38:28.000000 TESPy-0.6.3/tests/test_models/test_heat_pump_model.py
+-rw-rw-rw-   0        0        0    18727 2023-07-30 13:38:28.000000 TESPy-0.6.3/tests/test_models/test_solar_energy_generating_system.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.474789 TESPy-0.6.3/tests/test_networks/
+-rw-rw-rw-   0        0        0    20162 2023-07-30 13:38:28.000000 TESPy-0.6.3/tests/test_networks/test_network.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.482696 TESPy-0.6.3/tests/test_tools/
+-rw-rw-rw-   0        0        0     7887 2023-07-20 10:11:41.000000 TESPy-0.6.3/tests/test_tools/test_characteristics.py
+-rw-rw-rw-   0        0        0    13783 2023-07-30 14:47:51.000000 TESPy-0.6.3/tests/test_tools/test_fluid_properties.py
+-rw-rw-rw-   0        0        0     2004 2021-12-29 09:05:28.000000 TESPy-0.6.3/tests/test_tools/test_helpers.py
+-rw-rw-rw-   0        0        0     2485 2023-07-20 10:11:41.000000 TESPy-0.6.3/tox.ini
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.058699 TESPy-0.6.3/tutorial/
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.490741 TESPy-0.6.3/tutorial/advanced/
+-rw-rw-rw-   0        0        0     9761 2023-07-30 13:47:46.000000 TESPy-0.6.3/tutorial/advanced/optimization_example.py
+-rw-rw-rw-   0        0        0     9658 2023-07-20 10:11:41.000000 TESPy-0.6.3/tutorial/advanced/starting_values.py
+-rw-rw-rw-   0        0        0     6276 2023-07-20 10:11:41.000000 TESPy-0.6.3/tutorial/advanced/stepwise.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.490741 TESPy-0.6.3/tutorial/basics/
+-rw-rw-rw-   0        0        0     4305 2023-07-30 13:47:46.000000 TESPy-0.6.3/tutorial/basics/district_heating.py
+-rw-rw-rw-   0        0        0     5201 2023-07-20 10:11:41.000000 TESPy-0.6.3/tutorial/basics/gas_turbine.py
+-rw-rw-rw-   0        0        0     3257 2023-07-30 13:47:46.000000 TESPy-0.6.3/tutorial/basics/heat_pump.py
+-rw-rw-rw-   0        0        0     4702 2023-07-20 10:11:41.000000 TESPy-0.6.3/tutorial/basics/rankine.py
+drwxrwxrwx   0        0        0        0 2023-07-30 16:30:00.498695 TESPy-0.6.3/tutorial/heat_pump_exergy/
+-rw-rw-rw-   0        0        0     4322 2023-07-20 10:11:41.000000 TESPy-0.6.3/tutorial/heat_pump_exergy/NH3.py
+-rw-rw-rw-   0        0        0    10999 2023-07-20 10:11:41.000000 TESPy-0.6.3/tutorial/heat_pump_exergy/NH3_calculations.py
+-rw-rw-rw-   0        0        0     4330 2023-07-20 10:11:41.000000 TESPy-0.6.3/tutorial/heat_pump_exergy/R410A.py
+-rw-rw-rw-   0        0        0    11028 2023-07-20 10:11:41.000000 TESPy-0.6.3/tutorial/heat_pump_exergy/R410A_calculations.py
+-rw-rw-rw-   0        0        0     8280 2023-07-20 10:11:41.000000 TESPy-0.6.3/tutorial/heat_pump_exergy/plots.py
```

### Comparing `TESPy-0.6.2/.github/workflows/packaging.yml` & `TESPy-0.6.3/.github/workflows/packaging.yml`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/.github/workflows/tox_checks.yml` & `TESPy-0.6.3/.github/workflows/tox_checks.yml`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/.github/workflows/tox_pytest.yml` & `TESPy-0.6.3/.github/workflows/tox_pytest.yml`

 * *Files 3% similar despite different names*

```diff
@@ -18,16 +18,14 @@
     runs-on: ubuntu-latest
     strategy:
       matrix:
         python-version: ["3.7", "3.8", "3.9", "3.10"]
 
     steps:
     - uses: actions/checkout@v1
-    - name: Install xmllint
-      run: sudo apt install coinor-cbc
     - name: Set up Python ${{ matrix.python-version }}
       uses: actions/setup-python@v2
       with:
         python-version: ${{ matrix.python-version }}
     - name: Install dependencies
       run: |
         python -m pip install --upgrade pip
```

### Comparing `TESPy-0.6.2/.gitignore` & `TESPy-0.6.3/.gitignore`

 * *Files 18% similar despite different names*

```diff
@@ -35,25 +35,16 @@
 nosetests.xml
 coverage.xml
 htmlcov
 
 # Translations
 *.mo
 
-# Mr Developer
-.mr.developer.cfg
-.project
-.pydevproject
-.idea
-*.iml
-*.komodoproject
-
-# Complexity
-output/*.html
-output/*/index.html
+# VS code
+.vscode
 
 # Sphinx
 docs/_build
 
 .DS_Store
 *~
 .*.sw[po]
@@ -62,10 +53,7 @@
 .env
 .cache
 .pytest
 .benchmarks
 .bootstrap
 .appveyor.token
 *.bak
-
-# Mypy Cache
-.mypy_cache/
```

### Comparing `TESPy-0.6.2/.pep8speaks.yml` & `TESPy-0.6.3/.pep8speaks.yml`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/CODE_OF_CONDUCT.md` & `TESPy-0.6.3/CODE_OF_CONDUCT.md`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/LICENSE` & `TESPy-0.6.3/LICENSE`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/PKG-INFO` & `TESPy-0.6.3/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 Metadata-Version: 2.1
 Name: TESPy
-Version: 0.6.2
+Version: 0.6.3
 Summary: Thermal Engineering Systems in Python (TESPy)
 Home-page: https://github.com/oemof/tespy
 Author: Francesco Witte
-Author-email: francesco.witte@dlr.de
+Author-email: tespy@witte.sh
 License: MIT
 Project-URL: Documentation, https://tespy.readthedocs.io/
 Project-URL: Changelog, https://tespy.readthedocs.io/en/main/whats_new.html
 Project-URL: Issue Tracker, https://github.com/oemof/tespy/issues
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Education
 Classifier: Intended Audience :: Science/Research
```

### Comparing `TESPy-0.6.2/PULL_REQUEST_TEMPLATE.md` & `TESPy-0.6.3/PULL_REQUEST_TEMPLATE.md`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/README.rst` & `TESPy-0.6.3/README.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/ci/generate_tespy_data_module.py` & `TESPy-0.6.3/docs/scripts/generate_tespy_data_module.py`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/ci/templates/tox.ini` & `TESPy-0.6.3/tox.ini`

 * *Files 20% similar despite different names*

```diff
@@ -1,139 +1,156 @@
 00000000: 5b74 6f78 5d0d 0a65 6e76 6c69 7374 203d  [tox]..envlist =
 00000010: 0d0a 2020 2020 636c 6561 6e2c 0d0a 2020  ..    clean,..  
 00000020: 2020 6368 6563 6b2c 0d0a 2020 2020 646f    check,..    do
-00000030: 6373 2c0d 0a7b 2520 666f 7220 656e 7620  cs,..{% for env 
-00000040: 696e 2074 6f78 5f65 6e76 6972 6f6e 6d65  in tox_environme
-00000050: 6e74 737c 736f 7274 2025 7d0d 0a20 2020  nts|sort %}..   
-00000060: 207b 7b20 656e 7620 7d7d 2c0d 0a7b 2520   {{ env }},..{% 
-00000070: 656e 6466 6f72 2025 7d0d 0a20 2020 2072  endfor %}..    r
-00000080: 6570 6f72 740d 0a0d 0a5b 7465 7374 656e  eport....[testen
-00000090: 765d 0d0a 6261 7365 7079 7468 6f6e 203d  v]..basepython =
-000000a0: 0d0a 2020 2020 646f 6373 3a20 7b65 6e76  ..    docs: {env
-000000b0: 3a54 4f58 5059 5448 4f4e 3a70 7974 686f  :TOXPYTHON:pytho
-000000c0: 6e33 2e38 7d0d 0a20 2020 207b 626f 6f74  n3.8}..    {boot
-000000d0: 7374 7261 702c 636c 6561 6e2c 6368 6563  strap,clean,chec
-000000e0: 6b2c 7265 706f 7274 2c63 6f64 6563 6f76  k,report,codecov
-000000f0: 2c63 6f76 6572 616c 6c73 7d3a 207b 656e  ,coveralls}: {en
-00000100: 763a 544f 5850 5954 484f 4e3a 7079 7468  v:TOXPYTHON:pyth
-00000110: 6f6e 337d 0d0a 7365 7465 6e76 203d 0d0a  on3}..setenv =..
-00000120: 2020 2020 5059 5448 4f4e 5041 5448 3d7b      PYTHONPATH={
-00000130: 746f 7869 6e69 6469 727d 2f74 6573 7473  toxinidir}/tests
-00000140: 0d0a 2020 2020 5059 5448 4f4e 554e 4255  ..    PYTHONUNBU
-00000150: 4646 4552 4544 3d79 6573 0d0a 7061 7373  FFERED=yes..pass
-00000160: 656e 7620 3d0d 0a20 2020 202a 0d0a 6465  env =..    *..de
-00000170: 7073 203d 0d0a 2020 2020 7079 7465 7374  ps =..    pytest
-00000180: 0d0a 2020 2020 7079 7465 7374 2d74 7261  ..    pytest-tra
-00000190: 7669 732d 666f 6c64 0d0a 2020 2020 7079  vis-fold..    py
-000001a0: 7465 7374 2d63 6f76 0d0a 636f 6d6d 616e  test-cov..comman
-000001b0: 6473 203d 0d0a 2020 2020 7b70 6f73 6172  ds =..    {posar
-000001c0: 6773 3a70 7974 6573 7420 2d2d 636f 7620  gs:pytest --cov 
-000001d0: 2d2d 636f 762d 7265 706f 7274 3d74 6572  --cov-report=ter
-000001e0: 6d2d 6d69 7373 696e 6720 2d76 7620 2d2d  m-missing -vv --
-000001f0: 6967 6e6f 7265 3d73 7263 7d0d 0a0d 0a5b  ignore=src}....[
-00000200: 7465 7374 656e 763a 626f 6f74 7374 7261  testenv:bootstra
-00000210: 705d 0d0a 6465 7073 203d 0d0a 2020 2020  p]..deps =..    
-00000220: 6a69 6e6a 6132 0d0a 2020 2020 6d61 7472  jinja2..    matr
-00000230: 6978 0d0a 736b 6970 5f69 6e73 7461 6c6c  ix..skip_install
-00000240: 203d 2074 7275 650d 0a63 6f6d 6d61 6e64   = true..command
-00000250: 7320 3d0d 0a20 2020 2070 7974 686f 6e20  s =..    python 
-00000260: 6369 2f62 6f6f 7473 7472 6170 2e70 7920  ci/bootstrap.py 
-00000270: 2d2d 6e6f 2d65 6e76 0d0a 0d0a 5b74 6573  --no-env....[tes
-00000280: 7465 6e76 3a63 6865 636b 5d0d 0a64 6570  tenv:check]..dep
-00000290: 7320 3d0d 0a20 2020 2064 6f63 7574 696c  s =..    docutil
-000002a0: 730d 0a20 2020 2063 6865 636b 2d6d 616e  s..    check-man
-000002b0: 6966 6573 740d 0a20 2020 2066 6c61 6b65  ifest..    flake
-000002c0: 380d 0a20 2020 2072 6561 646d 652d 7265  8..    readme-re
-000002d0: 6e64 6572 6572 0d0a 2020 2020 7079 676d  nderer..    pygm
-000002e0: 656e 7473 0d0a 2020 2020 6973 6f72 740d  ents..    isort.
-000002f0: 0a73 6b69 705f 696e 7374 616c 6c20 3d20  .skip_install = 
-00000300: 7472 7565 0d0a 636f 6d6d 616e 6473 203d  true..commands =
-00000310: 0d0a 2020 2020 7079 7468 6f6e 2073 6574  ..    python set
-00000320: 7570 2e70 7920 6368 6563 6b20 2d2d 7374  up.py check --st
-00000330: 7269 6374 202d 2d6d 6574 6164 6174 6120  rict --metadata 
-00000340: 2d2d 7265 7374 7275 6374 7572 6564 7465  --restructuredte
-00000350: 7874 0d0a 2020 2020 6368 6563 6b2d 6d61  xt..    check-ma
-00000360: 6e69 6665 7374 207b 746f 7869 6e69 6469  nifest {toxinidi
-00000370: 727d 0d0a 2020 2020 666c 616b 6538 0d0a  r}..    flake8..
-00000380: 2020 2020 6973 6f72 7420 2d2d 7665 7262      isort --verb
-00000390: 6f73 6520 2d2d 6368 6563 6b2d 6f6e 6c79  ose --check-only
-000003a0: 202d 2d64 6966 6620 2d2d 7265 6375 7273   --diff --recurs
-000003b0: 6976 650d 0a0d 0a0d 0a5b 7465 7374 656e  ive......[testen
-000003c0: 763a 646f 6373 5d0d 0a75 7365 6465 7665  v:docs]..usedeve
-000003d0: 6c6f 7020 3d20 7472 7565 0d0a 6465 7073  lop = true..deps
-000003e0: 203d 0d0a 2020 2020 2d72 7b74 6f78 696e   =..    -r{toxin
-000003f0: 6964 6972 7d2f 646f 6373 2f72 6571 7569  idir}/docs/requi
-00000400: 7265 6d65 6e74 732e 7478 740d 0a63 6f6d  rements.txt..com
-00000410: 6d61 6e64 7320 3d0d 0a20 2020 2073 7068  mands =..    sph
-00000420: 696e 782d 6275 696c 6420 7b70 6f73 6172  inx-build {posar
-00000430: 6773 3a2d 457d 202d 6220 6874 6d6c 2064  gs:-E} -b html d
-00000440: 6f63 7320 6469 7374 2f64 6f63 730d 0a20  ocs dist/docs.. 
-00000450: 2020 2073 7068 696e 782d 6275 696c 6420     sphinx-build 
-00000460: 2d62 206c 696e 6b63 6865 636b 2064 6f63  -b linkcheck doc
-00000470: 7320 6469 7374 2f64 6f63 730d 0a0d 0a5b  s dist/docs....[
-00000480: 7465 7374 656e 763a 636f 7665 7261 6c6c  testenv:coverall
-00000490: 735d 0d0a 6465 7073 203d 0d0a 2020 2020  s]..deps =..    
-000004a0: 636f 7665 7261 6c6c 730d 0a73 6b69 705f  coveralls..skip_
-000004b0: 696e 7374 616c 6c20 3d20 7472 7565 0d0a  install = true..
-000004c0: 636f 6d6d 616e 6473 203d 0d0a 2020 2020  commands =..    
-000004d0: 636f 7665 7261 6c6c 7320 5b5d 0d0a 0d0a  coveralls []....
-000004e0: 0d0a 0d0a 5b74 6573 7465 6e76 3a63 6f64  ....[testenv:cod
-000004f0: 6563 6f76 5d0d 0a64 6570 7320 3d0d 0a20  ecov]..deps =.. 
-00000500: 2020 2063 6f64 6563 6f76 0d0a 736b 6970     codecov..skip
-00000510: 5f69 6e73 7461 6c6c 203d 2074 7275 650d  _install = true.
-00000520: 0a63 6f6d 6d61 6e64 7320 3d0d 0a20 2020  .commands =..   
-00000530: 2063 6f64 6563 6f76 205b 5d0d 0a0d 0a5b   codecov []....[
-00000540: 7465 7374 656e 763a 7265 706f 7274 5d0d  testenv:report].
-00000550: 0a64 6570 7320 3d20 636f 7665 7261 6765  .deps = coverage
-00000560: 0d0a 736b 6970 5f69 6e73 7461 6c6c 203d  ..skip_install =
-00000570: 2074 7275 650d 0a63 6f6d 6d61 6e64 7320   true..commands 
-00000580: 3d0d 0a20 2020 2063 6f76 6572 6167 6520  =..    coverage 
-00000590: 7265 706f 7274 0d0a 2020 2020 636f 7665  report..    cove
-000005a0: 7261 6765 2068 746d 6c0d 0a0d 0a5b 7465  rage html....[te
-000005b0: 7374 656e 763a 636c 6561 6e5d 0d0a 636f  stenv:clean]..co
-000005c0: 6d6d 616e 6473 203d 2063 6f76 6572 6167  mmands = coverag
-000005d0: 6520 6572 6173 650d 0a73 6b69 705f 696e  e erase..skip_in
-000005e0: 7374 616c 6c20 3d20 7472 7565 0d0a 6465  stall = true..de
-000005f0: 7073 203d 2063 6f76 6572 6167 650d 0a7b  ps = coverage..{
-00000600: 2520 666f 7220 656e 762c 2063 6f6e 6669  % for env, confi
-00000610: 6720 696e 2074 6f78 5f65 6e76 6972 6f6e  g in tox_environ
-00000620: 6d65 6e74 737c 6469 6374 736f 7274 2025  ments|dictsort %
-00000630: 7d0d 0a0d 0a5b 7465 7374 656e 763a 7b7b  }....[testenv:{{
-00000640: 2065 6e76 207d 7d5d 0d0a 6261 7365 7079   env }}]..basepy
-00000650: 7468 6f6e 203d 207b 656e 763a 544f 5850  thon = {env:TOXP
-00000660: 5954 484f 4e3a 7b7b 2065 6e76 2e73 706c  YTHON:{{ env.spl
-00000670: 6974 2822 2d22 295b 305d 2069 6620 656e  it("-")[0] if en
-00000680: 762e 7374 6172 7473 7769 7468 2822 7079  v.startswith("py
-00000690: 7079 2229 2065 6c73 6520 2270 7974 686f  py") else "pytho
-000006a0: 6e7b 305b 325d 7d2e 7b30 5b33 5d7d 222e  n{0[2]}.{0[3]}".
-000006b0: 666f 726d 6174 2865 6e76 2920 7d7d 7d0d  format(env) }}}.
-000006c0: 0a7b 2520 6966 2063 6f6e 6669 672e 636f  .{% if config.co
-000006d0: 7665 7220 6f72 2063 6f6e 6669 672e 656e  ver or config.en
-000006e0: 765f 7661 7273 2025 7d0d 0a73 6574 656e  v_vars %}..seten
-000006f0: 7620 3d0d 0a20 2020 207b 5b74 6573 7465  v =..    {[teste
-00000700: 6e76 5d73 6574 656e 767d 0d0a 7b25 2065  nv]setenv}..{% e
-00000710: 6e64 6966 2025 7d0d 0a7b 2520 666f 7220  ndif %}..{% for 
-00000720: 7661 7220 696e 2063 6f6e 6669 672e 656e  var in config.en
-00000730: 765f 7661 7273 2025 7d0d 0a20 2020 207b  v_vars %}..    {
-00000740: 7b20 7661 7220 7d7d 0d0a 7b25 2065 6e64  { var }}..{% end
-00000750: 666f 7220 257d 0d0a 7b25 2069 6620 636f  for %}..{% if co
-00000760: 6e66 6967 2e63 6f76 6572 2025 7d0d 0a75  nfig.cover %}..u
-00000770: 7365 6465 7665 6c6f 7020 3d20 7472 7565  sedevelop = true
-00000780: 0d0a 636f 6d6d 616e 6473 203d 0d0a 2020  ..commands =..  
-00000790: 2020 7b70 6f73 6172 6773 3a70 7974 6573    {posargs:pytes
-000007a0: 7420 2d2d 636f 7620 2d2d 636f 762d 7265  t --cov --cov-re
-000007b0: 706f 7274 3d74 6572 6d2d 6d69 7373 696e  port=term-missin
-000007c0: 6720 2d76 767d 0d0a 7b25 2065 6e64 6966  g -vv}..{% endif
-000007d0: 2025 7d0d 0a7b 2520 6966 2063 6f6e 6669   %}..{% if confi
-000007e0: 672e 636f 7665 7220 6f72 2063 6f6e 6669  g.cover or confi
-000007f0: 672e 6465 7073 2025 7d0d 0a64 6570 7320  g.deps %}..deps 
-00000800: 3d0d 0a20 2020 207b 5b74 6573 7465 6e76  =..    {[testenv
-00000810: 5d64 6570 737d 0d0a 7b25 2065 6e64 6966  ]deps}..{% endif
-00000820: 2025 7d0d 0a7b 2520 6966 2063 6f6e 6669   %}..{% if confi
-00000830: 672e 636f 7665 7220 257d 0d0a 2020 2020  g.cover %}..    
-00000840: 7079 7465 7374 2d63 6f76 0d0a 7b25 2065  pytest-cov..{% e
-00000850: 6e64 6966 2025 7d0d 0a7b 2520 666f 7220  ndif %}..{% for 
-00000860: 6465 7020 696e 2063 6f6e 6669 672e 6465  dep in config.de
-00000870: 7073 2025 7d0d 0a20 2020 207b 7b20 6465  ps %}..    {{ de
-00000880: 7020 7d7d 0d0a 7b25 2065 6e64 666f 7220  p }}..{% endfor 
-00000890: 2d25 7d0d 0a7b 2520 656e 6466 6f72 202d  -%}..{% endfor -
-000008a0: 257d 0d0a                                %}..
+00000030: 6373 2c0d 0a20 2020 2070 7933 372c 0d0a  cs,..    py37,..
+00000040: 2020 2020 7079 3338 2c0d 0a20 2020 2070      py38,..    p
+00000050: 7933 392c 0d0a 2020 2020 7079 3331 302c  y39,..    py310,
+00000060: 0d0a 2020 2020 7265 706f 7274 0d0a 0d0a  ..    report....
+00000070: 5b67 682d 6163 7469 6f6e 735d 0d0a 7079  [gh-actions]..py
+00000080: 7468 6f6e 203d 0d0a 2020 2020 332e 373a  thon =..    3.7:
+00000090: 2070 7933 370d 0a20 2020 2033 2e38 3a20   py37..    3.8: 
+000000a0: 7079 3338 0d0a 2020 2020 332e 393a 2070  py38..    3.9: p
+000000b0: 7933 390d 0a20 2020 2033 2e31 303a 2070  y39..    3.10: p
+000000c0: 7933 3130 0d0a 0d0a 5b74 6573 7465 6e76  y310....[testenv
+000000d0: 5d0d 0a62 6173 6570 7974 686f 6e20 3d0d  ]..basepython =.
+000000e0: 0a20 2020 2064 6f63 733a 207b 656e 763a  .    docs: {env:
+000000f0: 544f 5850 5954 484f 4e3a 7079 7468 6f6e  TOXPYTHON:python
+00000100: 332e 3130 7d0d 0a20 2020 207b 626f 6f74  3.10}..    {boot
+00000110: 7374 7261 702c 636c 6561 6e2c 6368 6563  strap,clean,chec
+00000120: 6b2c 7265 706f 7274 2c63 6f64 6563 6f76  k,report,codecov
+00000130: 2c63 6f76 6572 616c 6c73 7d3a 207b 656e  ,coveralls}: {en
+00000140: 763a 544f 5850 5954 484f 4e3a 7079 7468  v:TOXPYTHON:pyth
+00000150: 6f6e 337d 0d0a 7365 7465 6e76 203d 0d0a  on3}..setenv =..
+00000160: 2020 2020 5059 5448 4f4e 5041 5448 3d7b      PYTHONPATH={
+00000170: 746f 7869 6e69 6469 727d 2f74 6573 7473  toxinidir}/tests
+00000180: 0d0a 2020 2020 5059 5448 4f4e 554e 4255  ..    PYTHONUNBU
+00000190: 4646 4552 4544 3d79 6573 0d0a 7061 7373  FFERED=yes..pass
+000001a0: 656e 7620 3d0d 0a20 2020 202a 0d0a 6465  env =..    *..de
+000001b0: 7073 203d 0d0a 2020 2020 7079 7465 7374  ps =..    pytest
+000001c0: 0d0a 636f 6d6d 616e 6473 203d 0d0a 2020  ..commands =..  
+000001d0: 2020 7b70 6f73 6172 6773 3a70 7974 6573    {posargs:pytes
+000001e0: 7420 2d76 7620 2d2d 6967 6e6f 7265 3d73  t -vv --ignore=s
+000001f0: 7263 7d0d 0a0d 0a5b 7465 7374 656e 763a  rc}....[testenv:
+00000200: 626f 6f74 7374 7261 705d 0d0a 6465 7073  bootstrap]..deps
+00000210: 203d 0d0a 2020 2020 6a69 6e6a 6132 0d0a   =..    jinja2..
+00000220: 2020 2020 6d61 7472 6978 0d0a 736b 6970      matrix..skip
+00000230: 5f69 6e73 7461 6c6c 203d 2074 7275 650d  _install = true.
+00000240: 0a63 6f6d 6d61 6e64 7320 3d0d 0a20 2020  .commands =..   
+00000250: 2070 7974 686f 6e20 6369 2f62 6f6f 7473   python ci/boots
+00000260: 7472 6170 2e70 7920 2d2d 6e6f 2d65 6e76  trap.py --no-env
+00000270: 0d0a 0d0a 5b74 6573 7465 6e76 3a63 6865  ....[testenv:che
+00000280: 636b 5d0d 0a64 6570 7320 3d0d 0a20 2020  ck]..deps =..   
+00000290: 2064 6f63 7574 696c 730d 0a20 2020 2063   docutils..    c
+000002a0: 6865 636b 2d6d 616e 6966 6573 740d 0a20  heck-manifest.. 
+000002b0: 2020 2066 6c61 6b65 380d 0a20 2020 2072     flake8..    r
+000002c0: 6561 646d 652d 7265 6e64 6572 6572 0d0a  eadme-renderer..
+000002d0: 2020 2020 7079 676d 656e 7473 0d0a 2020      pygments..  
+000002e0: 2020 6973 6f72 740d 0a73 6b69 705f 696e    isort..skip_in
+000002f0: 7374 616c 6c20 3d20 7472 7565 0d0a 636f  stall = true..co
+00000300: 6d6d 616e 6473 203d 0d0a 2020 2020 7079  mmands =..    py
+00000310: 7468 6f6e 2073 6574 7570 2e70 7920 6368  thon setup.py ch
+00000320: 6563 6b20 2d2d 7374 7269 6374 202d 2d6d  eck --strict --m
+00000330: 6574 6164 6174 6120 2d2d 7265 7374 7275  etadata --restru
+00000340: 6374 7572 6564 7465 7874 0d0a 2020 2020  cturedtext..    
+00000350: 6368 6563 6b2d 6d61 6e69 6665 7374 207b  check-manifest {
+00000360: 746f 7869 6e69 6469 727d 202d 2d69 676e  toxinidir} --ign
+00000370: 6f72 653d 646f 6373 2f5f 6275 696c 642f  ore=docs/_build/
+00000380: 2a2a 0d0a 2020 2020 666c 616b 6538 2073  **..    flake8 s
+00000390: 7263 2074 6573 7473 2073 6574 7570 2e70  rc tests setup.p
+000003a0: 790d 0a20 2020 2069 736f 7274 202d 2d76  y..    isort --v
+000003b0: 6572 626f 7365 202d 2d63 6865 636b 2d6f  erbose --check-o
+000003c0: 6e6c 7920 2d2d 6469 6666 202d 2d72 6563  nly --diff --rec
+000003d0: 7572 7369 7665 2073 7263 2074 6573 7473  ursive src tests
+000003e0: 2073 6574 7570 2e70 790d 0a0d 0a5b 7465   setup.py....[te
+000003f0: 7374 656e 763a 646f 6373 5d0d 0a75 7365  stenv:docs]..use
+00000400: 6465 7665 6c6f 7020 3d20 7472 7565 0d0a  develop = true..
+00000410: 6465 7073 203d 0d0a 2020 2020 2d72 7b74  deps =..    -r{t
+00000420: 6f78 696e 6964 6972 7d2f 646f 6373 2f72  oxinidir}/docs/r
+00000430: 6571 7569 7265 6d65 6e74 732e 7478 740d  equirements.txt.
+00000440: 0a63 6f6d 6d61 6e64 7320 3d0d 0a20 2020  .commands =..   
+00000450: 2073 7068 696e 782d 6275 696c 6420 7b70   sphinx-build {p
+00000460: 6f73 6172 6773 3a2d 457d 202d 6220 6874  osargs:-E} -b ht
+00000470: 6d6c 2064 6f63 7320 6469 7374 2f64 6f63  ml docs dist/doc
+00000480: 730d 0a20 2020 2073 7068 696e 782d 6275  s..    sphinx-bu
+00000490: 696c 6420 2d62 206c 696e 6b63 6865 636b  ild -b linkcheck
+000004a0: 2064 6f63 7320 6469 7374 2f64 6f63 730d   docs dist/docs.
+000004b0: 0a0d 0a5b 7465 7374 656e 763a 636f 7665  ...[testenv:cove
+000004c0: 7261 6c6c 735d 0d0a 6465 7073 203d 0d0a  ralls]..deps =..
+000004d0: 2020 2020 636f 7665 7261 6c6c 730d 0a73      coveralls..s
+000004e0: 6b69 705f 696e 7374 616c 6c20 3d20 7472  kip_install = tr
+000004f0: 7565 0d0a 636f 6d6d 616e 6473 203d 0d0a  ue..commands =..
+00000500: 2020 2020 636f 7665 7261 6c6c 7320 5b5d      coveralls []
+00000510: 0d0a 0d0a 5b74 6573 7465 6e76 3a63 6f64  ....[testenv:cod
+00000520: 6563 6f76 5d0d 0a64 6570 7320 3d0d 0a20  ecov]..deps =.. 
+00000530: 2020 2063 6f64 6563 6f76 0d0a 736b 6970     codecov..skip
+00000540: 5f69 6e73 7461 6c6c 203d 2074 7275 650d  _install = true.
+00000550: 0a63 6f6d 6d61 6e64 7320 3d0d 0a20 2020  .commands =..   
+00000560: 2063 6f64 6563 6f76 205b 5d0d 0a0d 0a5b   codecov []....[
+00000570: 7465 7374 656e 763a 7265 706f 7274 5d0d  testenv:report].
+00000580: 0a64 6570 7320 3d20 636f 7665 7261 6765  .deps = coverage
+00000590: 0d0a 736b 6970 5f69 6e73 7461 6c6c 203d  ..skip_install =
+000005a0: 2074 7275 650d 0a63 6f6d 6d61 6e64 7320   true..commands 
+000005b0: 3d0d 0a20 2020 2063 6f76 6572 6167 6520  =..    coverage 
+000005c0: 7265 706f 7274 0d0a 2020 2020 636f 7665  report..    cove
+000005d0: 7261 6765 2068 746d 6c0d 0a0d 0a5b 7465  rage html....[te
+000005e0: 7374 656e 763a 636c 6561 6e5d 0d0a 636f  stenv:clean]..co
+000005f0: 6d6d 616e 6473 203d 2063 6f76 6572 6167  mmands = coverag
+00000600: 6520 6572 6173 650d 0a73 6b69 705f 696e  e erase..skip_in
+00000610: 7374 616c 6c20 3d20 7472 7565 0d0a 6465  stall = true..de
+00000620: 7073 203d 2063 6f76 6572 6167 650d 0a0d  ps = coverage...
+00000630: 0a5b 7465 7374 656e 763a 7079 3337 5d0d  .[testenv:py37].
+00000640: 0a62 6173 6570 7974 686f 6e20 3d20 7b65  .basepython = {e
+00000650: 6e76 3a54 4f58 5059 5448 4f4e 3a70 7974  nv:TOXPYTHON:pyt
+00000660: 686f 6e33 2e37 7d0d 0a73 6574 656e 7620  hon3.7}..setenv 
+00000670: 3d0d 0a20 2020 207b 5b74 6573 7465 6e76  =..    {[testenv
+00000680: 5d73 6574 656e 767d 0d0a 7573 6564 6576  ]setenv}..usedev
+00000690: 656c 6f70 203d 2074 7275 650d 0a63 6f6d  elop = true..com
+000006a0: 6d61 6e64 7320 3d0d 0a20 2020 207b 706f  mands =..    {po
+000006b0: 7361 7267 733a 7079 7465 7374 202d 2d63  sargs:pytest --c
+000006c0: 6f76 202d 2d63 6f76 2d72 6570 6f72 743d  ov --cov-report=
+000006d0: 7465 726d 2d6d 6973 7369 6e67 202d 7676  term-missing -vv
+000006e0: 7d0d 0a64 6570 7320 3d0d 0a20 2020 207b  }..deps =..    {
+000006f0: 5b74 6573 7465 6e76 5d64 6570 737d 0d0a  [testenv]deps}..
+00000700: 2020 2020 7079 7465 7374 2d63 6f76 0d0a      pytest-cov..
+00000710: 0d0a 5b74 6573 7465 6e76 3a70 7933 385d  ..[testenv:py38]
+00000720: 0d0a 6261 7365 7079 7468 6f6e 203d 207b  ..basepython = {
+00000730: 656e 763a 544f 5850 5954 484f 4e3a 7079  env:TOXPYTHON:py
+00000740: 7468 6f6e 332e 387d 0d0a 7365 7465 6e76  thon3.8}..setenv
+00000750: 203d 0d0a 2020 2020 7b5b 7465 7374 656e   =..    {[testen
+00000760: 765d 7365 7465 6e76 7d0d 0a75 7365 6465  v]setenv}..usede
+00000770: 7665 6c6f 7020 3d20 7472 7565 0d0a 636f  velop = true..co
+00000780: 6d6d 616e 6473 203d 0d0a 2020 2020 7b70  mmands =..    {p
+00000790: 6f73 6172 6773 3a70 7974 6573 7420 2d2d  osargs:pytest --
+000007a0: 636f 7620 2d2d 636f 762d 7265 706f 7274  cov --cov-report
+000007b0: 3d74 6572 6d2d 6d69 7373 696e 6720 2d76  =term-missing -v
+000007c0: 767d 0d0a 6465 7073 203d 0d0a 2020 2020  v}..deps =..    
+000007d0: 7b5b 7465 7374 656e 765d 6465 7073 7d0d  {[testenv]deps}.
+000007e0: 0a20 2020 2070 7974 6573 742d 636f 760d  .    pytest-cov.
+000007f0: 0a0d 0a5b 7465 7374 656e 763a 7079 3339  ...[testenv:py39
+00000800: 5d0d 0a62 6173 6570 7974 686f 6e20 3d20  ]..basepython = 
+00000810: 7b65 6e76 3a54 4f58 5059 5448 4f4e 3a70  {env:TOXPYTHON:p
+00000820: 7974 686f 6e33 2e39 7d0d 0a73 6574 656e  ython3.9}..seten
+00000830: 7620 3d0d 0a20 2020 207b 5b74 6573 7465  v =..    {[teste
+00000840: 6e76 5d73 6574 656e 767d 0d0a 7573 6564  nv]setenv}..used
+00000850: 6576 656c 6f70 203d 2074 7275 650d 0a63  evelop = true..c
+00000860: 6f6d 6d61 6e64 7320 3d0d 0a20 2020 207b  ommands =..    {
+00000870: 706f 7361 7267 733a 7079 7465 7374 202d  posargs:pytest -
+00000880: 2d63 6f76 202d 2d63 6f76 2d72 6570 6f72  -cov --cov-repor
+00000890: 743d 7465 726d 2d6d 6973 7369 6e67 202d  t=term-missing -
+000008a0: 7676 7d0d 0a64 6570 7320 3d0d 0a20 2020  vv}..deps =..   
+000008b0: 207b 5b74 6573 7465 6e76 5d64 6570 737d   {[testenv]deps}
+000008c0: 0d0a 2020 2020 7079 7465 7374 2d63 6f76  ..    pytest-cov
+000008d0: 0d0a 0d0a 5b74 6573 7465 6e76 3a70 7933  ....[testenv:py3
+000008e0: 3130 5d0d 0a62 6173 6570 7974 686f 6e20  10]..basepython 
+000008f0: 3d20 7b65 6e76 3a54 4f58 5059 5448 4f4e  = {env:TOXPYTHON
+00000900: 3a70 7974 686f 6e33 2e31 307d 0d0a 7365  :python3.10}..se
+00000910: 7465 6e76 203d 0d0a 2020 2020 7b5b 7465  tenv =..    {[te
+00000920: 7374 656e 765d 7365 7465 6e76 7d0d 0a75  stenv]setenv}..u
+00000930: 7365 6465 7665 6c6f 7020 3d20 7472 7565  sedevelop = true
+00000940: 0d0a 636f 6d6d 616e 6473 203d 0d0a 2020  ..commands =..  
+00000950: 2020 7b70 6f73 6172 6773 3a70 7974 6573    {posargs:pytes
+00000960: 7420 2d2d 636f 7620 2d2d 636f 762d 7265  t --cov --cov-re
+00000970: 706f 7274 3d74 6572 6d2d 6d69 7373 696e  port=term-missin
+00000980: 6720 2d76 767d 0d0a 6465 7073 203d 0d0a  g -vv}..deps =..
+00000990: 2020 2020 7b5b 7465 7374 656e 765d 6465      {[testenv]de
+000009a0: 7073 7d0d 0a20 2020 2070 7974 6573 742d  ps}..    pytest-
+000009b0: 636f 760d 0a                             cov..
```

### Comparing `TESPy-0.6.2/docs/_static/images/advanced/exergy/flowsheet.svg` & `TESPy-0.6.3/docs/_static/images/advanced/exergy/flowsheet.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/advanced/exergy/flowsheet_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/advanced/exergy/flowsheet_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/advanced/exergy/sankey.svg` & `TESPy-0.6.3/docs/_static/images/advanced/exergy/sankey.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/district_heating.svg` & `TESPy-0.6.3/docs/_static/images/basics/district_heating.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/district_heating_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/basics/district_heating_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/district_heating_partload.svg` & `TESPy-0.6.3/docs/_static/images/basics/district_heating_partload.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/district_heating_partload_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/basics/district_heating_partload_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/gas_turbine.svg` & `TESPy-0.6.3/docs/_static/images/basics/gas_turbine.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/gas_turbine_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/basics/gas_turbine_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/gas_turbine_fuel_composition.svg` & `TESPy-0.6.3/docs/_static/images/basics/gas_turbine_fuel_composition.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/gas_turbine_fuel_composition_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/basics/gas_turbine_fuel_composition_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/gas_turbine_oxygen.svg` & `TESPy-0.6.3/docs/_static/images/basics/gas_turbine_oxygen.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/gas_turbine_oxygen_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/basics/gas_turbine_oxygen_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/gas_turbine_parametric.svg` & `TESPy-0.6.3/docs/_static/images/basics/gas_turbine_parametric.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/gas_turbine_parametric_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/basics/gas_turbine_parametric_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/heat_pump.svg` & `TESPy-0.6.3/docs/_static/images/basics/heat_pump.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/heat_pump_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/basics/heat_pump_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/heat_pump_parametric.svg` & `TESPy-0.6.3/docs/_static/images/basics/heat_pump_parametric.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/heat_pump_parametric_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/basics/heat_pump_parametric_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/modeling_concept.svg` & `TESPy-0.6.3/docs/_static/images/basics/modeling_concept.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/rankine_cycle.svg` & `TESPy-0.6.3/docs/_static/images/basics/rankine_cycle.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/rankine_cycle_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/basics/rankine_cycle_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/rankine_parametric.svg` & `TESPy-0.6.3/docs/_static/images/basics/rankine_parametric.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/rankine_parametric_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/basics/rankine_parametric_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/rankine_partload.svg` & `TESPy-0.6.3/docs/_static/images/basics/rankine_partload.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/basics/rankine_partload_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/basics/rankine_partload_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/logo_tespy_big.svg` & `TESPy-0.6.3/docs/_static/images/logo_tespy_big.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/logo_tespy_big_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/logo_tespy_big_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/logo_tespy_big_editable_font.svg` & `TESPy-0.6.3/docs/_static/images/logo_tespy_big_editable_font.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/logo_tespy_mid.svg` & `TESPy-0.6.3/docs/_static/images/logo_tespy_mid.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/logo_tespy_mid_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/logo_tespy_mid_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/logo_tespy_mid_editable_font.svg` & `TESPy-0.6.3/docs/_static/images/logo_tespy_mid_editable_font.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/logo_tespy_small.svg` & `TESPy-0.6.3/docs/_static/images/logo_tespy_small.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/modules/Ts_diagram_states.svg` & `TESPy-0.6.3/docs/_static/images/modules/Ts_diagram_states.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/modules/characteristics.svg` & `TESPy-0.6.3/docs/_static/images/modules/characteristics.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/modules/characteristics_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/modules/characteristics_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/modules/connections.svg` & `TESPy-0.6.3/docs/_static/images/modules/connections.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/modules/connections_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/modules/connections_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/modules/fluid_properties.svg` & `TESPy-0.6.3/docs/_static/images/modules/fluid_properties.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/modules/fluid_properties_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/modules/fluid_properties_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/modules/logph_diagram_states.svg` & `TESPy-0.6.3/docs/_static/images/modules/logph_diagram_states.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/modules/subsystem_waste_heat_generator.svg` & `TESPy-0.6.3/docs/_static/images/modules/subsystem_waste_heat_generator.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/modules/subsystem_waste_heat_generator_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/modules/subsystem_waste_heat_generator_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/modules/ude.svg` & `TESPy-0.6.3/docs/_static/images/modules/ude.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/modules/ude_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/modules/ude_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/district_heating_system/dhs.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/district_heating_system/dhs.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/district_heating_system/dhs_closed.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/district_heating_system/dhs_closed.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/district_heating_system/dhs_forks.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/district_heating_system/dhs_forks.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/district_heating_system/dhs_open.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/district_heating_system/dhs_open.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/NH3_logph.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/NH3_logph.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/NH3_sankey.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/NH3_sankey.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_E_D.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_E_D.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_E_D_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_E_D_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Q.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Q.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Q_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Q_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Ths.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Ths.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Ths_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_cop_eps_Tgeo_Ths_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_eps_Tamb_Tgeo.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_eps_Tamb_Tgeo.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/diagram_eps_Tamb_Tgeo_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/diagram_eps_Tamb_Tgeo_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/flowsheet.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/flowsheet.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_exergy/flowsheet_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_exergy/flowsheet_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_starting_values/COP_by_wf.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_starting_values/COP_by_wf.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_starting_values/COP_by_wf_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_starting_values/COP_by_wf_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_starting_values/flowsheet.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_starting_values/flowsheet.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_starting_values/flowsheet_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_starting_values/flowsheet_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_starting_values/logph.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_starting_values/logph.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p1.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p1.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p1_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p1_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p2.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p2.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p2_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/heat_pump_stepwise/flowsheet_p2_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/pygmo_optimization/flowsheet.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/pygmo_optimization/flowsheet.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/pygmo_optimization/flowsheet_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/pygmo_optimization/flowsheet_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/pygmo_optimization/pygmo_optimization.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/pygmo_optimization/pygmo_optimization.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/_static/images/tutorials/pygmo_optimization/pygmo_optimization_darkmode.svg` & `TESPy-0.6.3/docs/_static/images/tutorials/pygmo_optimization/pygmo_optimization_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/advanced/exergy.rst` & `TESPy-0.6.3/docs/advanced/exergy.rst`

 * *Files 6% similar despite different names*

```diff
@@ -66,14 +66,22 @@
       - (specific) thermal exergy
       - :math:`e^\mathrm{T}`, :math:`E^\mathrm{T}`
       - associated with the system temperature
     * - :code:`ex_mech`, :code:`Ex_mech`
       - (specific) mechanical exergy
       - :math:`e^\mathrm{M}`, :math:`E^\mathrm{M}`
       - associated with the system pressure
+    * - :code:`ex_chemical`, :code:`Ex_chemical`
+      - (specific) chemical exergy
+      - :math:`e^\mathrm{CH}`, :math:`E^\mathrm{CH}`
+      - based on standard chemical exergy in ambient model, the `tespy.data`
+        module provides three different datasets for standard exergy based on
+        various sources, i.e. `Ahrendts`
+        :cite:`Ahrendts1980,Ahrendts1977,Ahrendts1974`, `Szargut1988`
+        :cite:`Szargut1988` and `Szargut2007` :cite:`Szargut2007,Bakshi2011`.
     * - :code:`E_P`
       - product exergy
       - :math:`\dot{E}_\mathrm{P}`
       - represents the desired result(expressed in terms of exergy) generated
         by the system being considered represents the resources (expressed in
         terms of exergy)
     * - :code:`E_F`
@@ -104,39 +112,40 @@
       - exergy destruction ratio
       - :math:`y^*_\mathrm{D}`
       - rate of exergy destruction in a component compared to the total exergy
         destruction rate within the system
 
 .. note::
 
-    The generic exergy analysis balance equations have been implemented into
-    TESPy for all components, that do not implement chemical reactions. The
-    equations for exergy balances at temperature values below the ambient
-    temperature are implemented as well, but are not yet fully tested.
+    The generic exergy analysis balance equations have not yet been fully
+    implemented and tested for the components `FuelCell`, `WaterElectrolzer`
+    and `CombustionEngine`.
 
 Tutorial
 ========
 In this short tutorial, an exergy analysis is carried out for the so called
 "Solar Energy Generating System" (SEGS). The full python script is available on
 GitHub in an individual repository: https://github.com/fwitte/SEGS_exergy.
 
-Two other full code examples are to be found at:
+.. tip::
 
-- Supercritical CO\ :sub:`2` power cycle: https://github.com/fwitte/sCO2_exergy
-- Refrigeration machine: https://github.com/fwitte/refrigeration_cycle_exergy
+  Two other full code examples are to be found at:
+
+  - Supercritical CO\ :sub:`2` power cycle: https://github.com/fwitte/sCO2_exergy
+  - Refrigeration machine: https://github.com/fwitte/refrigeration_cycle_exergy
 
 SEGS consists of three main systems, the solar field, the steam cycle and the
-cooling water system. In the solar field Therminol VP1 (TVP1) is used as heat transfer
-fluid. In the steam generator and reheater the TVP1 is cooled down to evaporate
-and overheat/reheat the water of the steam cycle. The turbine is divided in a
-high pressure turbine and a low pressure turbine, which are further subdivided
-in 2 parts (high pressure turbine) and 5 parts. In between the stages steam is
-exctracted for preheating. Finally, the main condenser of the steam cycle is
-connected to an air cooling tower. The figure below shows the topology of the
-model.
+cooling water system. In the solar field Therminol VP1 (TVP1) is used as heat
+transfer fluid. In the steam generator and reheater the TVP1 is cooled down to
+evaporate and overheat/reheat the water of the steam cycle. The turbine is
+divided in a high pressure turbine and a low pressure turbine, which are
+further subdivided in 2 parts (high pressure turbine) and 5 parts. In between
+the stages steam is extracted for preheating. Finally, the main condenser of
+the steam cycle is connected to an air cooling tower. The figure below shows
+the topology of the model.
 
 .. figure:: /_static/images/advanced/exergy/flowsheet.svg
     :align: center
     :alt: Topology of the Solar Energy Generating System (SEGS)
     :figclass: only-light
 
 .. figure:: /_static/images/advanced/exergy/flowsheet_darkmode.svg
@@ -416,15 +425,16 @@
     ean.generate_plotly_sankey_input(
         node_order=[
             'E_F', 'heat input', 'SF', 'SG', 'LPT', 'RH', 'HPT',
             'total output power', 'CW', 'LPP', 'FWP', 'HPP', 'exergy loss',
             'E_L', 'E_P', 'E_D'
         ],
         colors={'E_F': 'rgba(100, 100, 100, 0.5)'},
-        display_thresold=1)
+        display_thresold=1
+    )
 
 The coloring of the links is defined by the type of the exergy stream (bound
 to a specific fluid, fuel exergy, product exergy, exergy loss, exergy
 destruction or internal exergy streams not bound to mass flows). Therefore
 colors can be assigned to these types of streams.
 
 .. note::
```

### Comparing `TESPy-0.6.2/docs/api/_images/CombustionChamber.svg` & `TESPy-0.6.3/docs/api/_images/CombustionChamber.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/CombustionChamber_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/CombustionChamber_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/CombustionEngine.svg` & `TESPy-0.6.3/docs/api/_images/CombustionEngine.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/CombustionEngine_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/CombustionEngine_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Compressor.svg` & `TESPy-0.6.3/docs/api/_images/Compressor.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Compressor_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/Compressor_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Condenser.svg` & `TESPy-0.6.3/docs/api/_images/Condenser.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Condenser_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/Condenser_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/DropletSeparator.svg` & `TESPy-0.6.3/docs/api/_images/DropletSeparator.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/DropletSeparator_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/DropletSeparator_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Drum.svg` & `TESPy-0.6.3/docs/api/_images/Drum.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Drum_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/Drum_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/FuelCell.svg` & `TESPy-0.6.3/docs/api/_images/FuelCell.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/FuelCell_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/FuelCell_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/HeatExchanger.svg` & `TESPy-0.6.3/docs/api/_images/HeatExchanger.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/HeatExchanger_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/HeatExchanger_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Merge.svg` & `TESPy-0.6.3/docs/api/_images/Merge.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Merge_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/Merge_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/ORCEvaporator.svg` & `TESPy-0.6.3/docs/api/_images/ORCEvaporator.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/ParabolicTrough.svg` & `TESPy-0.6.3/docs/api/_images/ParabolicTrough.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/ParabolicTrough_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/ParabolicTrough_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Pipe.svg` & `TESPy-0.6.3/docs/api/_images/Pipe.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Pipe_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/Pipe_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Pump.svg` & `TESPy-0.6.3/docs/api/_images/Pump.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Pump_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/Pump_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/SolarCollector.svg` & `TESPy-0.6.3/docs/api/_images/SolarCollector.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/SolarCollector_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/SolarCollector_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Splitter.svg` & `TESPy-0.6.3/docs/api/_images/Splitter.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Splitter_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/Splitter_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/SubsystemInterface.svg` & `TESPy-0.6.3/docs/api/_images/SubsystemInterface.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/SubsystemInterface_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/SubsystemInterface_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Turbine.svg` & `TESPy-0.6.3/docs/api/_images/Turbine.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Turbine_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/Turbine_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Valve.svg` & `TESPy-0.6.3/docs/api/_images/Valve.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/Valve_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/Valve_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/WaterElectrolyzer.svg` & `TESPy-0.6.3/docs/api/_images/WaterElectrolyzer.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/WaterElectrolyzer_darkmode.svg` & `TESPy-0.6.3/docs/api/_images/WaterElectrolyzer_darkmode.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/combustion_engine_Q1_char_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/combustion_engine_Q1_char_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/combustion_engine_Q2_char_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/combustion_engine_Q2_char_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/combustion_engine_Qloss_char_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/combustion_engine_Qloss_char_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/combustion_engine_tiP_char_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/combustion_engine_tiP_char_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/compressor_char_map_eta_s_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/compressor_char_map_eta_s_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/compressor_char_map_pr_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/compressor_char_map_pr_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/compressor_eta_s_char_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/compressor_eta_s_char_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/condenser_kA_char1_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/condenser_kA_char1_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/condenser_kA_char2_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/condenser_kA_char2_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/desuperheater_kA_char1_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/desuperheater_kA_char1_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/desuperheater_kA_char2_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/desuperheater_kA_char2_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/heat_exchanger_kA_char1_CONDENSING_FLUID.svg` & `TESPy-0.6.3/docs/api/_images/heat_exchanger_kA_char1_CONDENSING_FLUID.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/heat_exchanger_kA_char1_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/heat_exchanger_kA_char1_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/heat_exchanger_kA_char2_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/heat_exchanger_kA_char2_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/heat_exchanger_kA_char2_EVAPORATING_FLUID.svg` & `TESPy-0.6.3/docs/api/_images/heat_exchanger_kA_char2_EVAPORATING_FLUID.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/heat_exchanger_simple_kA_char_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/heat_exchanger_simple_kA_char_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/pipe_kA_char_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/pipe_kA_char_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/pump_eta_s_char_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/pump_eta_s_char_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/turbine_eta_s_char_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/turbine_eta_s_char_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/turbine_eta_s_char_TRAUPEL.svg` & `TESPy-0.6.3/docs/api/_images/turbine_eta_s_char_TRAUPEL.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/_images/water_electrolyzer_eta_char_DEFAULT.svg` & `TESPy-0.6.3/docs/api/_images/water_electrolyzer_eta_char_DEFAULT.svg`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/components.rst` & `TESPy-0.6.3/docs/api/components.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/data.rst` & `TESPy-0.6.3/docs/api/data.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api/tools.rst` & `TESPy-0.6.3/docs/api/tools.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/api.rst` & `TESPy-0.6.3/docs/api.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/basics/district_heating.rst` & `TESPy-0.6.3/docs/basics/district_heating.rst`

 * *Files 3% similar despite different names*

```diff
@@ -26,15 +26,23 @@
 :download:`district_heating.py </../tutorial/basics/district_heating.py>`
 
 Setting up the System
 ^^^^^^^^^^^^^^^^^^^^^
 For this model we have to import the :code:`Network` and :code:`Connection`
 classes as well as the respective components. After setting up the network we
 can create the components, connect them to the network (as shown in the other)
-examples.
+examples. As a fluid, we will use the incompressibles back-end of CoolProp,
+since we only need liquid water. The incompressible back-end has much higher
+access speed while preserving high accuracy.
+
+
+.. tip::
+
+    For more information on the fluid properties in TESPy,
+    :ref:`check out this page <tespy_fluid_properties_label>`.
 
 .. dropdown:: Click to expand to code section
 
     .. literalinclude:: /../tutorial/basics/district_heating.py
         :language: python
         :start-after: [sec_1]
         :end-before: [sec_2]
```

### Comparing `TESPy-0.6.2/docs/basics/gas_turbine.rst` & `TESPy-0.6.3/docs/basics/gas_turbine.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/basics/heat_pump.rst` & `TESPy-0.6.3/docs/basics/heat_pump.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/basics/intro.rst` & `TESPy-0.6.3/docs/basics/intro.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/basics/rankine_cycle.rst` & `TESPy-0.6.3/docs/basics/rankine_cycle.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/basics.rst` & `TESPy-0.6.3/docs/basics.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/benchmarks.rst` & `TESPy-0.6.3/docs/benchmarks.rst`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 Benchmarks
 ==========
 To ensure credibility as well as reproducibility for the software, several
 measures are taken. The most important information is listed below:
 
 Model Validation
 ----------------
-TESPy has been used to model several different research and engineering
-applications. In the paper on integration of generic exergy analysis in TESPy
+TESPy has been used to model several research and engineering applications. In
+the paper on integration of generic exergy analysis in TESPy
 :cite:`Witte2022` three models have been built from literature sources: A
 solar thermal power plant, a supercritical CO2 brayton cycle as well as a
 refrigeration machine using air as working fluid.
 
 For the solar thermal power plant we have created a full model of the plant
 using a standard industry software in parallel. **The comparison showed**
 **identical results**. For the other two applications we have compared the
```

### Comparing `TESPy-0.6.2/docs/development/how.rst` & `TESPy-0.6.3/docs/development/how.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/development/what.rst` & `TESPy-0.6.3/docs/development/what.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/index.rst` & `TESPy-0.6.3/docs/index.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/installation.rst` & `TESPy-0.6.3/docs/installation.rst`

 * *Files 10% similar despite different names*

```diff
@@ -24,16 +24,16 @@
          sudo apt-get install python3
 
       You can also download different versions of Python via
       https://www.python.org/downloads/.
 
       **Having Python 3 installed**
 
-      We recommend installting TESPy within a virtual Python enviroment an not
-      into the base, system wide Python installation. On Linux you can use
+      We recommend installing TESPy within a virtual Python environment and not
+      into the base, system-wide Python installation. On Linux you can use
       virtualenv to do so.
 
       1. Install virtualenv using the package management of your Linux distribution,
          pip install or install it from source
          (`see virtualenv documentation <https://virtualenv.pypa.io/en/stable/installation.html>`_)
       2. Open terminal to create and activate a virtual environment by typing:
 
@@ -45,27 +45,39 @@
       3. In terminal type: :code:`pip install tespy`
 
       Warning: If you have an older version of virtualenv you should update pip
       :code:`pip install --upgrade pip`.
 
       **Using Conda**
 
-      Alternatively you can use conda for enviroment and package management. You
+      Alternatively you can use conda for environment and package management. You
       can follow the installation instructions for windows users.
 
    .. tab-item:: Windows
 
       For windows we recommend using conda as package manager. You can download a
-      light weight open source variant of conda: "miniforge3".
+      lightweight open source variant of conda: "miniforge3".
 
       1. Download latest `miniforge3 <https://github.com/conda-forge/miniforge>`__
          for Python 3.x (64 or 32 bit).
       2. Install miniforge3
       3. Open "miniforge prompt" to manage your virtual environments. You can
          create a new environment and acivate it by
 
          .. code-block:: console
 
             conda create -n tespy-env python=3.9
             activate tespy-env
 
       4. In the active prompt type: :code:`pip install tespy`
+
+   .. tab-item:: Developer Version
+
+      If you would like to get access to not yet released features or features
+      under development you can install the developer version. The steps are
+      similar to the steps here, but INSTEAD of installing TESPy using
+
+      .. code-block:: console
+
+           pip install tespy
+
+      follow the instructions on :ref:`this page <tespy_development_how_label>`.
```

### Comparing `TESPy-0.6.2/docs/introduction.rst` & `TESPy-0.6.3/docs/introduction.rst`

 * *Files 0% similar despite different names*

```diff
@@ -68,15 +68,15 @@
 :ref:`modules <tespy_modules_label>` section provides you with in depth
 information on the different modules of TESPy.
 
 Citation
 ========
 
 The scope and functionalities of TESPy have been documented in a paper
-published in the Journal of Open Source Software with an OpenAccess license.
+published in the Journal of Open Source Software with an Open-Access license.
 Download the paper from https://doi.org/10.21105/joss.02178 :cite:`Witte2020`.
 As TESPy is a free software, we kindly ask that you add a reference to TESPy
 if you use the software for your scientific work. Please cite the article with
 the BibTeX citation below.
 
 BibTeX citation
```

### Comparing `TESPy-0.6.2/docs/modules/characteristics.rst` & `TESPy-0.6.3/docs/modules/characteristics.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/modules/components.rst` & `TESPy-0.6.3/docs/modules/components.rst`

 * *Files 0% similar despite different names*

```diff
@@ -26,15 +26,15 @@
   * :py:class:`Diabatic combustion chamber <tespy.components.combustion.diabatic.DiabaticCombustionChamber>`
     (Advanced version of combustion chamber, featuring heat losses and pressure
     drop)
   * :py:class:`Combustion engine <tespy.components.combustion.engine.CombustionEngine>`
 
 - Heat exchangers
 
-  * :py:class:`Simplified heat exchanger <tespy.components.heat_exchangers.simple.HeatExchangerSimple>`
+  * :py:class:`Simplified heat exchanger <tespy.components.heat_exchangers.simple.SimpleHeatExchanger>`
   * :py:class:`Solar collector <tespy.components.heat_exchangers.solar_collector.SolarCollector>`
   * :py:class:`Parabolic trough <tespy.components.heat_exchangers.parabolic_trough.ParabolicTrough>`
   * :py:class:`Heat exchanger <tespy.components.heat_exchangers.base.HeatExchanger>`
   * :py:class:`Condenser <tespy.components.heat_exchangers.condenser.Condenser>`
   * :py:class:`Desuperheater <tespy.components.heat_exchangers.desuperheater.Desuperheater>`
 
 - Nodes
@@ -366,15 +366,15 @@
 - pump
 
   * :py:meth:`eta_s_char <tespy.components.turbomachinery.pump.Pump.eta_s_char_func>`: isentropic efficiency.
   * :py:meth:`flow_char <tespy.components.turbomachinery.pump.Pump.flow_char_func>`: absolute pressure change.
 
 - simple heat exchangers
 
-  * :py:meth:`kA_char <tespy.components.heat_exchangers.simple.HeatExchangerSimple.kA_char_group_func>`: heat transfer coefficient.
+  * :py:meth:`kA_char <tespy.components.heat_exchangers.simple.SimpleHeatExchanger.kA_char_group_func>`: heat transfer coefficient.
 
 - turbine
 
   * :py:meth:`eta_s_char <tespy.components.turbomachinery.turbine.Turbine.eta_s_char_func>`: isentropic efficiency.
 
 - valve
 
@@ -404,15 +404,15 @@
 If the equation uses a single parameter, use the :code:`ComponentProperties`
 type DataContainer (or the :code:`ComponentCharacteristics` type in case you
 only apply a characteristic curve). If your equations requires multiple
 parameters, add these parameters as :code:`ComponentProperties` or
 :code:`ComponentCharacteristics` respectively and add a
 :code:`GroupedComponentProperties` type DataContainer holding the information,
 e.g. like the :code:`hydro_group` parameter of the
-:py:class:`tespy.components.heat_exchangers.simple.HeatExchangerSimple`
+:py:class:`tespy.components.heat_exchangers.simple.SimpleHeatExchanger`
 class shown below.
 
 .. code:: python
 
     # [...]
     'D': dc_cp(min_val=1e-2, max_val=2, d=1e-4),
     'L': dc_cp(min_val=1e-1, d=1e-3),
```

### Comparing `TESPy-0.6.2/docs/modules/connections.rst` & `TESPy-0.6.3/docs/modules/connections.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/modules/fluid_properties.rst` & `TESPy-0.6.3/docs/modules/fluid_properties.rst`

 * *Files 3% similar despite different names*

```diff
@@ -10,14 +10,17 @@
 ------------------
 CoolProp provides multiple back ends for fluid property calculation. The
 back ends vary in calculation speed and calculation accuracy. It is possible
 to choose from the following back ends:
 
 - :code:`HEOS`: Helmhotz Equation Of State with highest accuracy and lowest
   calculation speed. **This is the default back end!**
+- :code:`REFPROP`: Highest accuracy and highest convergence stability.
+  **This back end is not free**, a separate
+  `REFPROP <https://www.nist.gov/srd/refprop>`__ license is required.
 - :code:`BICUBIC`: Tabular back end with high accuracy and very high
   calculation speed.
 - :code:`TTSE`: Tabular back end with lowest accuracy and very high calculation
   speed.
 - :code:`INCOMP`: Back end for incompressible fluids.
 - :code:`IF97`: Back end for the IAPWS-IF97 of water, very accurate and much
   higher calculation speed than :code:`HEOS`. Due to a bug in the CoolProp
```

### Comparing `TESPy-0.6.2/docs/modules/networks.rst` & `TESPy-0.6.3/docs/modules/networks.rst`

 * *Files 1% similar despite different names*

```diff
@@ -434,14 +434,21 @@
   manipulated. If you want to look up, what exactly the convergence check for a
   specific component does, look out for the :code:`convergence_check` methods
   in the :py:mod:`tespy.components module <tespy.components>`.
 
 In a lot of different tests the algorithm has found a near enough solution
 after the third iteration, further checks are usually not required.
 
+.. tip::
+
+    To check if the solver successfully found a solution for your model you can
+    check the `.converged` attribute of the Network class after calling the
+    `solve` method. It will be `True` in case no linear dependency was and the
+    residual value of all equations is below the minimum threshold.
+
 Calculation speed improvement
 +++++++++++++++++++++++++++++
 For improvement of calculation speed, the calculation of specific derivatives
 is skipped if possible. If you specify :code:`always_all_equations=False` for
 your simulation, equations may also be skipped: There are two criteria for
 equations and one criterion for derivatives that are checked for calculation
 intensive operations, e.g. whenever fluid property library calls are necessary:
@@ -451,29 +458,29 @@
 - only if you specified :code:`always_all_equations=False` and
 - if the absolute of the residual value of that equations is lower than the
   threshold of :code:`1e-12` in the iteration before and
 - the iteration count is not a multiple of 4.
 
 Connections equations are skipped
 
-- only if you specified :code:`always_all_equations=False` and
+- if you specified :code:`always_all_equations=False` and
 - if the absolute of the residual value of that equations is lower than the
   threshold of :code:`1e-12` in the iteration before and
 - the iteration count is not a multiple of 2 and
 - the specified property is not temperature.
 
 The calculation of derivatives is skipped, if the change of the corresponding
 variable was below a threshold of :code:`1e-12` in the iteration before.
 Again, this does not apply to temperature value specification, as especially
 when using fluid mixtures, the convergence stability is very sensitive to
 these equations and derivatives.
 
 .. note::
 
-    In order to make sure, that every equations is evaluated at least twice,
+    In order to make sure, that every equation is evaluated at least twice,
     the minimum amount of iterations before convergence can be accepted is at
     4.
 
 Troubleshooting
 +++++++++++++++
 In this section we show you how you can troubleshoot your calculation and list
 up common mistakes. If you want to debug your code, make sure to enable the
@@ -498,15 +505,15 @@
 :code:`fluids=['water', 'air', 'methane']` and at some point you want to have
 water only, you still need to specify the mass fractions for both air and
 methane (although beeing zero) at that point
 :code:`fluid={'water': 1, 'air': 0, 'methane': 0}`. Also, setting
 :code:`fluid={water: 1}, fluid_balance=True` will still not be sufficient, as
 the fluid_balance parameter adds only one equation to your system.
 
-If you are modeling a cycle, e.g. the clausius rankine cylce, you need to make
+If you are modeling a cycle, e.g. the Clausius Rankine cylce, you need to make
 a cut in the cycle using the cycle_closer or a sink and a source not to
 overdetermine the system. Have a look in the
 :ref:`tutorial section <tespy_basics_label>` to understand why this is
 important and how it can be implemented.
 
 If you have provided the correct number of parameters in your system and the
 calculations stops after or even before the first iteration, there are four
@@ -522,15 +529,15 @@
   stops the calculation (overdetermining one variable, while missing out on
   another).
 - A linear dependency in the Jacobian matrix due to bad starting values stops
   the calculation.
 
 The first reason can be eliminated by carefully choosing the parametrization.
 **A linear dependency due to bad starting values is often more difficult to**
-**resolve and it may require some experience.** In many cases, the linear
+**resolve, and it may require some experience.** In many cases, the linear
 dependency is caused by equations, that require the **calculation of a**
 **temperature**, e.g. specifying a temperature at some point of the network,
 terminal temperature differences at heat exchangers, etc.. In this case,
 **the starting enthalpy and pressure should be adjusted in a way, that the**
 **fluid state is not within the two-phase region:** The specification of
 temperature and pressure in a two-phase region does not yield a distinct value
 for the enthalpy. Even if this specific case appears after some iterations,
```

### Comparing `TESPy-0.6.2/docs/modules/ude.rst` & `TESPy-0.6.3/docs/modules/ude.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/modules.rst` & `TESPy-0.6.3/docs/modules.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/references.bib` & `TESPy-0.6.3/docs/references.bib`

 * *Files 9% similar despite different names*

```diff
@@ -29,15 +29,14 @@
 
 @TechReport{Lippke1995,
   author      = {Lippke, Frank},
   institution = {Sandia National Lab.},
   title       = {Simulation of the part-load behavior of a 30 MWe SEGS plant},
   doi         = {10.2172/95571},
   number      = {SAND-95-1293},
-  url         = {https://www.osti.gov/biblio/95571},
   address     = {Albuquerque},
   groups      = {solar-case-study},
   month       = jun,
   place       = {United States},
   year        = {1995},
 }
 
@@ -243,14 +242,25 @@
  pages = {2328--2340},
  volume = {17},
  number = {4},
  journal = {Entropy},
  doi = {10.3390/e17042328}
 }
 
+@article{Chen2022,
+  title = {Parametric optimization and comparative study of an organic Rankine cycle power plant for two-phase geothermal sources},
+  journal = {Energy},
+  volume = {252},
+  pages = {123910},
+  year = {2022},
+  issn = {0360-5442},
+  doi = {https://doi.org/10.1016/j.energy.2022.123910},
+  author = {Chaofan Chen and Francesco Witte and Ilja Tuschy and Olaf Kolditz and Haibing Shao},
+}
+
 @article{CODATA1989,
   doi = {10.1002/bbpc.19900940121},
   year = {1990},
   month = jan,
   publisher = {Wiley},
   volume = {94},
   number = {1},
@@ -300,7 +310,84 @@
 	volume = {19},
 	number = {3},
 	pages = {279--286},
 	author = {Antonio Valero and Miguel A. Lozano and Luis Serra and George Tsatsaronis and Javier Pisa and Christos Frangopoulos and Michael R. von Spakovsky},
 	title = {{CGAM} problem: Definition and conventional solution},
 	journal = {Energy}
 }
+
+@inproceedings{Fry2022,
+  url = {https://www.geothermal-library.org/index.php?mode=pubs&action=view&record=1034577},
+  booktitle = {Geothermal Resources Council Transactions},
+  year = 2022,
+  month = aug,
+  publisher = {Geothermal Rising},
+  venue = {Reno (Nevada), USA},
+  pages = {23--47},
+  author = {Fry, Nicholas and Eagle-Bluestone, Jessica and Witte, Francesco},
+  title = {Computational Modeling of Organic Rankine Cycle Combined Heat and Power for Sedimentary Geothermal Exploitation}
+}
+
+@article{Gasanzade2023,
+title = {Integration of geological compressed air energy storage into future energy supply systems dominated by renewable power sources},
+journal = {Energy Conversion and Management},
+volume = {277},
+pages = {116643},
+year = {2023},
+issn = {0196-8904},
+doi = {https://doi.org/10.1016/j.enconman.2022.116643},
+author = {Firdovsi Gasanzade and Francesco Witte and Ilja Tuschy and Sebastian Bauer},
+}
+
+@book{Szargut2007,
+  title={Egzergia: poradnik obliczania i stosowania},
+  author={Szargut, Jan},
+  year={2007},
+  publisher={Wydawnictwo Politechniki {\'S}l{\k{a}}skiej}
+}
+
+@book{Bakshi2011,
+  place={Cambridge},
+  title={Thermodynamics and the Destruction of Resources},
+  doi={10.1017/CBO9780511976049},
+  publisher={Cambridge University Press},
+  year={2011},
+  editor={{}}
+}
+
+@book{Szargut1988,
+  title = {Exergy analysis of thermal, chemical, and metallurgical processes},
+  author = {Szargut, J. and Morris, D. R. and Steward, F. R.},
+  place = {Germany},
+  year = {1988},
+  publisher = {Springer-Verlag Berlin Heidelberg}
+}
+
+@article{Ahrendts1980,
+  doi = {10.1016/0360-5442(80)90087-0},
+  year = {1980},
+  month = aug,
+  publisher = {Elsevier {BV}},
+  volume = {5},
+  number = {8-9},
+  pages = {666--677},
+  author = {Joachim Ahrendts},
+  title = {Reference states},
+  journal = {Energy}
+}
+
+
+@book{Ahrendts1977,
+  title={Die Exergie chemisch reaktionsfhiger Systeme},
+  author={Ahrendts, Joachim},
+  year={1977},
+  publisher={VDI-Verlag},
+  journal = {VDI-Forschungsheft},
+  volume = {579}
+}
+
+@phdthesis{Ahrendts1974,
+  title={Die Exergie chemisch reaktionsfhiger Systeme},
+  author={Ahrendts, Joachim},
+  year={1977},
+  school={Ruhr-Universitt Bochum}
+}
```

### Comparing `TESPy-0.6.2/docs/regular_meeting.rst` & `TESPy-0.6.3/docs/regular_meeting.rst`

 * *Files 10% similar despite different names*

```diff
@@ -17,12 +17,7 @@
 
 User forum
 ==========
 We have implemented a
 `discussion room on GitHub <https://github.com/oemof/tespy/discussions>`__ as
 user forum. If you have issues with setting up your model or any other question
 about using the software, you are invited to start a discussion there.
-
-In-person meetings
-==================
-Currently, no in-person meetings are scheduled. We will update this section, as
-soon as a meeting is planned.
```

### Comparing `TESPy-0.6.2/docs/tutorials/district_heating.rst` & `TESPy-0.6.3/docs/tutorials/district_heating.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/tutorials/heat_pump_exergy.rst` & `TESPy-0.6.3/docs/tutorials/heat_pump_exergy.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/tutorials/heat_pump_steps.rst` & `TESPy-0.6.3/docs/tutorials/heat_pump_steps.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/tutorials/pygmo_optimization.rst` & `TESPy-0.6.3/docs/tutorials/pygmo_optimization.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/tutorials/starting_values.rst` & `TESPy-0.6.3/docs/tutorials/starting_values.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/tutorials.rst` & `TESPy-0.6.3/docs/tutorials.rst`

 * *Files 20% similar despite different names*

```diff
@@ -13,20 +13,22 @@
 - set up a code structure, which allows you to generate stable starting values
   flexibly, helping you to build reliable setups faster.
 - use the inbuilt exergy analysis method in a simple geothermal heat pump
   setting.
 
 Furthermore, we introduce the coupling of TESPy with pygmo in order to create
 an optimization problem, which optimizes thermal efficiency of a clausius
-rankine power plant. Another typical setup are heat recovery steam generators
-using exhaust gases from an open cycle gas turbine.
+rankine power plant. Also, there is a tutorial on the implementation of an air
+source heat pump in an energy system dispatch optimization problem using
+`oemof-solph <https://github.com/oemof/oemof-solph>`__. For that tutorial an air
+source heat pump is implemented in various details of modeling complexity and
+the results are transferred to the energy system optimization problem.
 
-Finally, we provide an approach on how to model complex district heating
-systems. If you have any questions, ideas for other tutorials or feedback,
-please reach out to us. We are looking forward to hearing from you!
+If you have any questions, ideas for other tutorials or feedback, please reach
+out to us. We are looking forward to hearing from you!
 
 .. grid:: 2
     :gutter: 1
 
     .. grid-item-card::  Build complex systems step by step
         :link: tespy_tutorial_heat_pump_label
         :link-type: ref
@@ -56,17 +58,23 @@
 
         .. image:: /_static/images/tutorials/heat_pump_exergy/diagram_E_D.svg
             :class: only-light
 
         .. image:: /_static/images/tutorials/heat_pump_exergy/diagram_E_D_darkmode.svg
             :class: only-dark
 
-    .. grid-item-card::  Building Complex District Heating Systems
+    .. grid-item-card::  Integration of an air source heat pump in energy system optimization
+        :link: https://oemof.github.io/heat-pump-tutorial/
+
+        .. image:: /_static/images/tutorials/osmses-2023.svg
+            :class: only-light
+
+        .. image:: /_static/images/tutorials/osmses-2023_darkmode.svg
+            :class: only-dark
 
-        Coming soon!
 
 .. grid:: 2
     :gutter: 1
 
     .. grid-item-card::  Optimization of a thermal power plant
         :link: tespy_tutorial_pygmo_optimization_label
         :link-type: ref
```

### Comparing `TESPy-0.6.2/docs/whats_new/v0-0-2.rst` & `TESPy-0.6.3/docs/whats_new/v0-0-2.rst`

 * *Files 9% similar despite different names*

```diff
@@ -16,15 +16,15 @@
 - Added an example for combustion chamber usage.
 
 Testing
 #######
 
 Bug fixes
 #########
-- Adjusted the generic pump characteristics to cause less instabilites and adjusted function parameters according to `KSB <https://www.ksb.com/kreiselpumpenlexikon/spezifische-drehzahl/186490>`_.
+- Adjusted the generic pump characteristics to cause less instabilities and adjusted function parameters according to `KSB <https://www.ksb.com/de-global/kreiselpumpenlexikon/artikel/spezifische-drehzahl-1075774>`_.
 - Fixed bug in combustion chamber's thermal input equation.
 - Fixed parameters for numerical calculation of derivatives.
 - Fixed starting relaxation parameter.
 
 Other changes
 #############
 - Improved convergence stability for combustion chamber and heat exchanger.
```

### Comparing `TESPy-0.6.2/docs/whats_new/v0-0-3.rst` & `TESPy-0.6.3/docs/whats_new/v0-0-3.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-0-4.rst` & `TESPy-0.6.3/docs/whats_new/v0-0-4.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-0-5.rst` & `TESPy-0.6.3/docs/whats_new/v0-0-5.rst`

 * *Ordering differences only*

 * *Files 11% similar despite different names*

```diff
@@ -1,60 +1,60 @@
-v0.0.5 (October, 25, 2018)
-++++++++++++++++++++++++++
-
-New Features
-############
-- added new component: motoric cogeneration unit (`79a1177 <https://github.com/oemof/tespy/commit/79a1177d5db130465676907d9a51b680005bdc7a>`_).
-  An example is provided `here <https://github.com/oemof/oemof-examples/tree/master/oemof_examples/tespy/combustion>`__.
-- improved fluid property checks (`8adc76c <https://github.com/oemof/tespy/commit/8adc76c25ef976ed90ac6fba0d8c2f94e43ca7c5>`_).
-- added bus characteristics for modeling variable efficiencys (e.g. for generator, motor, boiler) (`79a1177 <https://github.com/oemof/tespy/commit/79a1177d5db130465676907d9a51b680005bdc7a>`_).
-- isentropic efficiency characteristic for compressor linked to pressure ratio (`85d317d <https://github.com/oemof/tespy/commit/85d317dea8cce8b7f6d149cca90317e6595a2485>`_).
-- added volumetric flow specification (`63db64d <https://github.com/oemof/tespy/commit/63db64de7fc5a26eb4d36b94bdd67fc3a4f7f715>`_).
-
-Documentation
-#############
-- adapted documentation and (`example code <https://github.com/oemof/oemof-examples/tree/master/oemof_examples/tespy/>`_)
-  in regard of new features.
-- fixed some typos in documentation.
-
-Parameter renaming
-##################
-
-**compressor**
-- vigv -> igva (inlet guide vane angle)
-
-**simple heat exchanger**
-- t_a -> Tamb (ambient temperature)
-
-**solar collector**
-- t_a -> Tamb (ambient temperature)
-
-Testing
-#######
-
-Bug fixes
-#########
-- fixed a bug in the function v_mix_ph (specific volume for gas mixtures) (`d487381 <https://github.com/oemof/tespy/commit/d48738163c402c17456193a17d4bce60782258d0>`_).
-- fixed compressor derivatives for usage with custom variables (`71cae48 <https://github.com/oemof/tespy/commit/71cae481a2dabfdd92334f23bf87433fb4a571f7>`_).
-- adjusted error messages (`cccd89c <https://github.com/oemof/tespy/commit/cccd89c6b1648be3e1819deccecc0df69ca92ba4>`_).
-- removed unecessary loop (`187505b <https://github.com/oemof/tespy/commit/187505ba73b4749df6451e4d5464fc909c4f63ed>`_).
-- fixed attribute handling in subsystem: condenser with subcooler (`2c926bb <https://github.com/oemof/tespy/commit/2c926bb5cb9b9c04d5f767a2c866bba00efcf5aa>`_).
-
-Other changes
-#############
-- remodeled the characteristic map for compressors: if not specified, igva is assumed to be 0 (`2425a77 <https://github.com/oemof/tespy/commit/2425a774309655f8577c5a460403e02282db0135>`_).
-- redesigned the printouts for component parameters (`9465be6 <https://github.com/oemof/tespy/commit/9465be65fc74403c6f4d07c068a4727ef4149e77>`_,
-  `b2c0897 <https://github.com/oemof/tespy/commit/b2c08977d10b11c370089f87d5838fd4ff59c906>`_,
-  `cbbc1a1 <https://github.com/oemof/tespy/commit/cbbc1a1438d250074b1a556df4ec21424eb53d34>`_,
-  `1e55e36 <https://github.com/oemof/tespy/commit/1e55e36b5aa9bbfda15537cc305379f5198edeca>`_,
-  `2e795c2 <https://github.com/oemof/tespy/commit/2e795c2af35a9b6ad3af1834cfc9b7c01f9da3a4>`_)
-- custom variables are available for (`977a5be <https://github.com/oemof/tespy/commit/977a5be7f8441c1d67ff83feeabd13645cb51052>`_):
-	- turbomachines,
-	- vessels,
-	- simple heat exchangers (as well as pipes and solar collctors) and
-	- cogeneration unit.
-
-Contributors
-############
-
-- Francesco Witte
-- Paul Hansen
+v0.0.5 (October, 25, 2018)
+++++++++++++++++++++++++++
+
+New Features
+############
+- added new component: motoric cogeneration unit (`79a1177 <https://github.com/oemof/tespy/commit/79a1177d5db130465676907d9a51b680005bdc7a>`_).
+  An example is provided `here <https://github.com/oemof/oemof-examples/tree/master/oemof_examples/tespy/combustion>`__.
+- improved fluid property checks (`8adc76c <https://github.com/oemof/tespy/commit/8adc76c25ef976ed90ac6fba0d8c2f94e43ca7c5>`_).
+- added bus characteristics for modeling variable efficiencys (e.g. for generator, motor, boiler) (`79a1177 <https://github.com/oemof/tespy/commit/79a1177d5db130465676907d9a51b680005bdc7a>`_).
+- isentropic efficiency characteristic for compressor linked to pressure ratio (`85d317d <https://github.com/oemof/tespy/commit/85d317dea8cce8b7f6d149cca90317e6595a2485>`_).
+- added volumetric flow specification (`63db64d <https://github.com/oemof/tespy/commit/63db64de7fc5a26eb4d36b94bdd67fc3a4f7f715>`_).
+
+Documentation
+#############
+- adapted documentation and (`example code <https://github.com/oemof/oemof-examples/tree/master/oemof_examples/tespy/>`_)
+  in regard of new features.
+- fixed some typos in documentation.
+
+Parameter renaming
+##################
+
+**compressor**
+- vigv -> igva (inlet guide vane angle)
+
+**simple heat exchanger**
+- t_a -> Tamb (ambient temperature)
+
+**solar collector**
+- t_a -> Tamb (ambient temperature)
+
+Testing
+#######
+
+Bug fixes
+#########
+- fixed a bug in the function v_mix_ph (specific volume for gas mixtures) (`d487381 <https://github.com/oemof/tespy/commit/d48738163c402c17456193a17d4bce60782258d0>`_).
+- fixed compressor derivatives for usage with custom variables (`71cae48 <https://github.com/oemof/tespy/commit/71cae481a2dabfdd92334f23bf87433fb4a571f7>`_).
+- adjusted error messages (`cccd89c <https://github.com/oemof/tespy/commit/cccd89c6b1648be3e1819deccecc0df69ca92ba4>`_).
+- removed unecessary loop (`187505b <https://github.com/oemof/tespy/commit/187505ba73b4749df6451e4d5464fc909c4f63ed>`_).
+- fixed attribute handling in subsystem: condenser with subcooler (`2c926bb <https://github.com/oemof/tespy/commit/2c926bb5cb9b9c04d5f767a2c866bba00efcf5aa>`_).
+
+Other changes
+#############
+- remodeled the characteristic map for compressors: if not specified, igva is assumed to be 0 (`2425a77 <https://github.com/oemof/tespy/commit/2425a774309655f8577c5a460403e02282db0135>`_).
+- redesigned the printouts for component parameters (`9465be6 <https://github.com/oemof/tespy/commit/9465be65fc74403c6f4d07c068a4727ef4149e77>`_,
+  `b2c0897 <https://github.com/oemof/tespy/commit/b2c08977d10b11c370089f87d5838fd4ff59c906>`_,
+  `cbbc1a1 <https://github.com/oemof/tespy/commit/cbbc1a1438d250074b1a556df4ec21424eb53d34>`_,
+  `1e55e36 <https://github.com/oemof/tespy/commit/1e55e36b5aa9bbfda15537cc305379f5198edeca>`_,
+  `2e795c2 <https://github.com/oemof/tespy/commit/2e795c2af35a9b6ad3af1834cfc9b7c01f9da3a4>`_)
+- custom variables are available for (`977a5be <https://github.com/oemof/tespy/commit/977a5be7f8441c1d67ff83feeabd13645cb51052>`_):
+	- turbomachines,
+	- vessels,
+	- simple heat exchangers (as well as pipes and solar collctors) and
+	- cogeneration unit.
+
+Contributors
+############
+
+- Francesco Witte
+- Paul Hansen
```

### Comparing `TESPy-0.6.2/docs/whats_new/v0-1-0.rst` & `TESPy-0.6.3/docs/whats_new/v0-1-0.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-1-1.rst` & `TESPy-0.6.3/docs/whats_new/v0-1-1.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-1-2.rst` & `TESPy-0.6.3/docs/whats_new/v0-1-2.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-1-3.rst` & `TESPy-0.6.3/docs/whats_new/v0-1-3.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-1-4.rst` & `TESPy-0.6.3/docs/whats_new/v0-1-4.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-2-0.rst` & `TESPy-0.6.3/docs/whats_new/v0-2-0.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-2-1.rst` & `TESPy-0.6.3/docs/whats_new/v0-2-1.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-2-2.rst` & `TESPy-0.6.3/docs/whats_new/v0-2-2.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-3-0.rst` & `TESPy-0.6.3/docs/whats_new/v0-3-0.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-3-2.rst` & `TESPy-0.6.3/docs/whats_new/v0-3-2.rst`

 * *Ordering differences only*

 * *Files 20% similar despite different names*

```diff
@@ -1,47 +1,47 @@
-v0.3.2 - Carnot's Colors (June, 10, 2020)
-+++++++++++++++++++++++++++++++++++++++++
-
-New features
-############
-- Colored printouts are available in the :code:`print_results()` method of the
-  network class. There are three different color codes available with default
-  settings:
-
-  - user specified parameters (:code:`'set'`, blue)
-  - component parameters specified as variables (:code:`'var'`, green)
-  - faulty parameters (:code:`'err'`, red)
-
-  In order to change the colors, simply import :code:`coloring` from the
-  :py:mod:`tespy.tools.global_vars` module and adjust the escape codes. For
-  example, to reset all colors to white text:
-
-  .. code-block:: python
-
-        from tespy.tools.global_vars import coloring
-        coloring['set'] = '\033[0m'
-        coloring['err'] = '\033[0m'
-        coloring['var'] = '\033[0m'
-
-  See `here <https://en.wikipedia.org/wiki/ANSI_escape_code#Colors>`__ for a
-  list of available codes
-  (`PR #205 <https://github.com/oemof/tespy/pull/205>`_).
-
-Bug fixes
-#########
-- Readd method for :code:`T_mix_ps` calculation for pure fluids: In case the
-  fluid propagation did not go through (e.g. due to availability of good
-  starting values) the fluid composition at a turbomachine's inlet and outlet
-  may not be equal (`PR #207 <https://github.com/oemof/tespy/pull/207>`_).
-- Fix the calculation of mixture density: The density is calculated as sum of
-  the densities of the mixture components at their respective partial pressure
-  and the mixture temperature
-  (`PR #207 <https://github.com/oemof/tespy/pull/207>`_). With the old method,
-  the specific volume was calculated according to Amagat's law, which produced
-  incorrect values if one or more components of the mixture were liquid at the
-  mixture's temperature and pressure. See discussion about humid air propreties
-  here: `Issue #206 <https://github.com/oemof/tespy/issues/206>`_.
-
-Contributors
-############
-- Francesco Witte (`@fwitte <https://github.com/fwitte>`_)
-- `@jbueck <https://github.com/jbueck>`_
+v0.3.2 - Carnot's Colors (June, 10, 2020)
++++++++++++++++++++++++++++++++++++++++++
+
+New features
+############
+- Colored printouts are available in the :code:`print_results()` method of the
+  network class. There are three different color codes available with default
+  settings:
+
+  - user specified parameters (:code:`'set'`, blue)
+  - component parameters specified as variables (:code:`'var'`, green)
+  - faulty parameters (:code:`'err'`, red)
+
+  In order to change the colors, simply import :code:`coloring` from the
+  :py:mod:`tespy.tools.global_vars` module and adjust the escape codes. For
+  example, to reset all colors to white text:
+
+  .. code-block:: python
+
+        from tespy.tools.global_vars import coloring
+        coloring['set'] = '\033[0m'
+        coloring['err'] = '\033[0m'
+        coloring['var'] = '\033[0m'
+
+  See `here <https://en.wikipedia.org/wiki/ANSI_escape_code#Colors>`__ for a
+  list of available codes
+  (`PR #205 <https://github.com/oemof/tespy/pull/205>`_).
+
+Bug fixes
+#########
+- Readd method for :code:`T_mix_ps` calculation for pure fluids: In case the
+  fluid propagation did not go through (e.g. due to availability of good
+  starting values) the fluid composition at a turbomachine's inlet and outlet
+  may not be equal (`PR #207 <https://github.com/oemof/tespy/pull/207>`_).
+- Fix the calculation of mixture density: The density is calculated as sum of
+  the densities of the mixture components at their respective partial pressure
+  and the mixture temperature
+  (`PR #207 <https://github.com/oemof/tespy/pull/207>`_). With the old method,
+  the specific volume was calculated according to Amagat's law, which produced
+  incorrect values if one or more components of the mixture were liquid at the
+  mixture's temperature and pressure. See discussion about humid air propreties
+  here: `Issue #206 <https://github.com/oemof/tespy/issues/206>`_.
+
+Contributors
+############
+- Francesco Witte (`@fwitte <https://github.com/fwitte>`_)
+- `@jbueck <https://github.com/jbueck>`_
```

### Comparing `TESPy-0.6.2/docs/whats_new/v0-3-3.rst` & `TESPy-0.6.3/docs/whats_new/v0-3-3.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-3-4.rst` & `TESPy-0.6.3/docs/whats_new/v0-3-4.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-4-0.rst` & `TESPy-0.6.3/docs/whats_new/v0-4-0.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-4-1.rst` & `TESPy-0.6.3/docs/whats_new/v0-4-1.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-4-2.rst` & `TESPy-0.6.3/docs/whats_new/v0-4-2.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-4-3-001.rst` & `TESPy-0.6.3/docs/whats_new/v0-4-3-001.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-4-3-003.rst` & `TESPy-0.6.3/docs/whats_new/v0-4-3-003.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-4-3.rst` & `TESPy-0.6.3/docs/whats_new/v0-4-3.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-4-4.rst` & `TESPy-0.6.3/docs/whats_new/v0-4-4.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-5-0.rst` & `TESPy-0.6.3/docs/whats_new/v0-5-0.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-5-1.rst` & `TESPy-0.6.3/docs/whats_new/v0-5-1.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-6-0.rst` & `TESPy-0.6.3/docs/whats_new/v0-6-0.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new/v0-6-1.rst` & `TESPy-0.6.3/docs/whats_new/v0-6-1.rst`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/docs/whats_new.rst` & `TESPy-0.6.3/docs/whats_new.rst`

 * *Files 0% similar despite different names*

```diff
@@ -1,12 +1,13 @@
 What's New
 ~~~~~~~~~~
 
 Discover noteable new features and improvements in each release
 
+.. include::  whats_new/v0-6-3.rst
 .. include::  whats_new/v0-6-2.rst
 .. include::  whats_new/v0-6-1.rst
 .. include::  whats_new/v0-6-0.rst
 .. include::  whats_new/v0-5-1.rst
 .. include::  whats_new/v0-5-0.rst
 .. include::  whats_new/v0-4-4.rst
 .. include::  whats_new/v0-4-3-003.rst
```

### Comparing `TESPy-0.6.2/paper.bib` & `TESPy-0.6.3/paper.bib`

 * *Files 1% similar despite different names*

```diff
@@ -48,15 +48,15 @@
     month = nov,
     pages = {41--50},
     title = {Modelica open library for power plant simulation: Design and experimental validation},
     journal = {Proc. 3rd Modelica Conference}
 }
 
 @misc{ThermoPowerOnline,
-    author = {{Politecnico di Milano}},
+    author = {{Politecnico di Milano}},
     title = {ThermoPower},
     year = {2014},
     howpublished = {\url{https://build.openmodelica.org/Documentation/ThermoPower.html}}
 }
 
 @misc{TESPy,
     author = {Witte, Francesco},
```

### Comparing `TESPy-0.6.2/paper.md` & `TESPy-0.6.3/paper.md`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/setup.cfg` & `TESPy-0.6.3/setup.cfg`

 * *Files 13% similar despite different names*

```diff
@@ -37,17 +37,16 @@
 00000240: 7365 7061 7261 7465 203d 2074 6573 745f  separate = test_
 00000250: 7465 7370 790d 0a6e 6f74 5f73 6b69 7020  tespy..not_skip 
 00000260: 3d20 5f5f 696e 6974 5f5f 2e70 790d 0a73  = __init__.py..s
 00000270: 6b69 7020 3d20 6d69 6772 6174 696f 6e73  kip = migrations
 00000280: 0d0a 0d0a 5b6d 6174 7269 785d 0d0a 7079  ....[matrix]..py
 00000290: 7468 6f6e 5f76 6572 7369 6f6e 7320 3d20  thon_versions = 
 000002a0: 0d0a 0970 7933 370d 0a09 7079 3338 0d0a  ...py37...py38..
-000002b0: 0970 7933 390d 0a09 7079 3331 300d 0a64  .py39...py310..d
-000002c0: 6570 656e 6465 6e63 6965 7320 3d20 0d0a  ependencies = ..
-000002d0: 636f 7665 7261 6765 5f66 6c61 6773 203d  coverage_flags =
-000002e0: 200d 0a09 636f 7665 723a 2074 7275 650d   ...cover: true.
-000002f0: 0a09 6e6f 636f 763a 2066 616c 7365 0d0a  ..nocov: false..
-00000300: 656e 7669 726f 6e6d 656e 745f 7661 7269  environment_vari
-00000310: 6162 6c65 7320 3d20 0d0a 092d 0d0a 0d0a  ables = ...-....
-00000320: 5b65 6767 5f69 6e66 6f5d 0d0a 7461 675f  [egg_info]..tag_
-00000330: 6275 696c 6420 3d20 0d0a 7461 675f 6461  build = ..tag_da
-00000340: 7465 203d 2030 0d0a 0d0a                 te = 0....
+000002b0: 0970 7933 390d 0a09 7079 3331 300d 0a63  .py39...py310..c
+000002c0: 6f76 6572 6167 655f 666c 6167 7320 3d20  overage_flags = 
+000002d0: 0d0a 0963 6f76 6572 3a20 7472 7565 0d0a  ...cover: true..
+000002e0: 096e 6f63 6f76 3a20 6661 6c73 650d 0a65  .nocov: false..e
+000002f0: 6e76 6972 6f6e 6d65 6e74 5f76 6172 6961  nvironment_varia
+00000300: 626c 6573 203d 200d 0a09 2d0d 0a0d 0a5b  bles = ...-....[
+00000310: 6567 675f 696e 666f 5d0d 0a74 6167 5f62  egg_info]..tag_b
+00000320: 7569 6c64 203d 200d 0a74 6167 5f64 6174  uild = ..tag_dat
+00000330: 6520 3d20 300d 0a0d 0a                   e = 0....
```

### Comparing `TESPy-0.6.2/setup.py` & `TESPy-0.6.3/setup.py`

 * *Files 9% similar despite different names*

```diff
@@ -7,40 +7,40 @@
 import re
 from glob import glob
 from os.path import basename
 from os.path import dirname
 from os.path import join
 from os.path import splitext
 
-from setuptools import find_packages
+from setuptools import find_namespace_packages
 from setuptools import setup
 
 
 def read(*names, **kwargs):
     with io.open(
         join(dirname(__file__), *names),
         encoding=kwargs.get('encoding', 'utf8')
     ) as fh:
         return fh.read()
 
 
 setup(
     name='TESPy',
-    version='0.6.2',
+    version='0.6.3',
     license='MIT',
     description='Thermal Engineering Systems in Python (TESPy)',
     long_description='%s' % (
         re.compile('^.. start-badges.*^.. end-badges', re.M | re.S).sub(
             '', read('README.rst')
         )
     ),
     author='Francesco Witte',
-    author_email='francesco.witte@dlr.de',
+    author_email='tespy@witte.sh',
     url='https://github.com/oemof/tespy',
-    packages=find_packages('src'),
+    packages=find_namespace_packages('src'),
     package_dir={'': 'src'},
     py_modules=[splitext(basename(path))[0] for path in glob('src/*.py')],
     include_package_data=True,
     zip_safe=False,
     package_data={'src': ['*.json']},
     classifiers=[
         'Development Status :: 4 - Beta',
```

### Comparing `TESPy-0.6.2/src/TESPy.egg-info/PKG-INFO` & `TESPy-0.6.3/src/TESPy.egg-info/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 Metadata-Version: 2.1
 Name: TESPy
-Version: 0.6.2
+Version: 0.6.3
 Summary: Thermal Engineering Systems in Python (TESPy)
 Home-page: https://github.com/oemof/tespy
 Author: Francesco Witte
-Author-email: francesco.witte@dlr.de
+Author-email: tespy@witte.sh
 License: MIT
 Project-URL: Documentation, https://tespy.readthedocs.io/
 Project-URL: Changelog, https://tespy.readthedocs.io/en/main/whats_new.html
 Project-URL: Issue Tracker, https://github.com/oemof/tespy/issues
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Education
 Classifier: Intended Audience :: Science/Research
```

### Comparing `TESPy-0.6.2/src/TESPy.egg-info/SOURCES.txt` & `TESPy-0.6.3/src/TESPy.egg-info/SOURCES.txt`

 * *Files 4% similar despite different names*

```diff
@@ -14,21 +14,14 @@
 pyproject.toml
 setup.cfg
 setup.py
 tox.ini
 .github/workflows/packaging.yml
 .github/workflows/tox_checks.yml
 .github/workflows/tox_pytest.yml
-ci/appveyor-with-compiler.cmd
-ci/bootstrap.py
-ci/generate_tespy_data_module.py
-ci/requirements.txt
-ci/templates/.appveyor.yml
-ci/templates/.travis.yml
-ci/templates/tox.ini
 docs/api.rst
 docs/basics.rst
 docs/benchmarks.rst
 docs/conf.py
 docs/examples.rst
 docs/index.rst
 docs/installation.rst
@@ -70,28 +63,34 @@
 docs/_static/images/basics/modeling_concept.svg
 docs/_static/images/basics/rankine_cycle.svg
 docs/_static/images/basics/rankine_cycle_darkmode.svg
 docs/_static/images/basics/rankine_parametric.svg
 docs/_static/images/basics/rankine_parametric_darkmode.svg
 docs/_static/images/basics/rankine_partload.svg
 docs/_static/images/basics/rankine_partload_darkmode.svg
-docs/_static/images/examples/GRC_electrical_power_output.svg
-docs/_static/images/examples/GRC_electrical_power_output_darkmode.svg
+docs/_static/images/examples/GRC_flowsheet.svg
+docs/_static/images/examples/GRC_flowsheet_darkmode.svg
+docs/_static/images/examples/ORC_parametric_flowsheet.svg
+docs/_static/images/examples/ORC_parametric_flowsheet_darkmode.svg
+docs/_static/images/examples/PM_CAES_graphical-abstract.svg
+docs/_static/images/examples/PM_CAES_graphical-abstract_darkmode.svg
 docs/_static/images/modules/Ts_diagram_states.svg
 docs/_static/images/modules/characteristics.svg
 docs/_static/images/modules/characteristics_darkmode.svg
 docs/_static/images/modules/connections.svg
 docs/_static/images/modules/connections_darkmode.svg
 docs/_static/images/modules/fluid_properties.svg
 docs/_static/images/modules/fluid_properties_darkmode.svg
 docs/_static/images/modules/logph_diagram_states.svg
 docs/_static/images/modules/subsystem_waste_heat_generator.svg
 docs/_static/images/modules/subsystem_waste_heat_generator_darkmode.svg
 docs/_static/images/modules/ude.svg
 docs/_static/images/modules/ude_darkmode.svg
+docs/_static/images/tutorials/osmses-2023.svg
+docs/_static/images/tutorials/osmses-2023_darkmode.svg
 docs/_static/images/tutorials/district_heating_system/dhs.svg
 docs/_static/images/tutorials/district_heating_system/dhs_closed.svg
 docs/_static/images/tutorials/district_heating_system/dhs_forks.svg
 docs/_static/images/tutorials/district_heating_system/dhs_open.svg
 docs/_static/images/tutorials/heat_pump_exergy/NH3_logph.svg
 docs/_static/images/tutorials/heat_pump_exergy/NH3_sankey.svg
 docs/_static/images/tutorials/heat_pump_exergy/diagram_E_D.svg
@@ -171,15 +170,14 @@
 docs/api/_images/compressor_char_map_eta_s_DEFAULT.svg
 docs/api/_images/compressor_char_map_pr_DEFAULT.svg
 docs/api/_images/compressor_eta_s_char_DEFAULT.svg
 docs/api/_images/condenser_kA_char1_DEFAULT.svg
 docs/api/_images/condenser_kA_char2_DEFAULT.svg
 docs/api/_images/desuperheater_kA_char1_DEFAULT.svg
 docs/api/_images/desuperheater_kA_char2_DEFAULT.svg
-docs/api/_images/flowsheet.svg
 docs/api/_images/heat_exchanger_kA_char1_CONDENSING_FLUID.svg
 docs/api/_images/heat_exchanger_kA_char1_DEFAULT.svg
 docs/api/_images/heat_exchanger_kA_char2_DEFAULT.svg
 docs/api/_images/heat_exchanger_kA_char2_EVAPORATING_FLUID.svg
 docs/api/_images/heat_exchanger_simple_kA_char_DEFAULT.svg
 docs/api/_images/pipe_kA_char_DEFAULT.svg
 docs/api/_images/pump_eta_s_char_DEFAULT.svg
@@ -195,14 +193,15 @@
 docs/development/what.rst
 docs/modules/characteristics.rst
 docs/modules/components.rst
 docs/modules/connections.rst
 docs/modules/fluid_properties.rst
 docs/modules/networks.rst
 docs/modules/ude.rst
+docs/scripts/generate_tespy_data_module.py
 docs/tutorials/district_heating.rst
 docs/tutorials/heat_pump_exergy.rst
 docs/tutorials/heat_pump_steps.rst
 docs/tutorials/pygmo_optimization.rst
 docs/tutorials/starting_values.rst
 docs/whats_new/v0-0-1.rst
 docs/whats_new/v0-0-2.rst
@@ -230,14 +229,15 @@
 docs/whats_new/v0-4-3.rst
 docs/whats_new/v0-4-4.rst
 docs/whats_new/v0-5-0.rst
 docs/whats_new/v0-5-1.rst
 docs/whats_new/v0-6-0.rst
 docs/whats_new/v0-6-1.rst
 docs/whats_new/v0-6-2.rst
+docs/whats_new/v0-6-3.rst
 src/TESPy.egg-info/PKG-INFO
 src/TESPy.egg-info/SOURCES.txt
 src/TESPy.egg-info/dependency_links.txt
 src/TESPy.egg-info/not-zip-safe
 src/TESPy.egg-info/requires.txt
 src/TESPy.egg-info/top_level.txt
 src/tespy/__init__.py
@@ -281,14 +281,17 @@
 src/tespy/components/turbomachinery/pump.py
 src/tespy/components/turbomachinery/turbine.py
 src/tespy/connections/__init__.py
 src/tespy/connections/bus.py
 src/tespy/connections/connection.py
 src/tespy/data/char_lines.json
 src/tespy/data/char_maps.json
+src/tespy/data/ChemEx/Ahrendts.json
+src/tespy/data/ChemEx/Szargut1988.json
+src/tespy/data/ChemEx/Szargut2007.json
 src/tespy/networks/__init__.py
 src/tespy/networks/network.py
 src/tespy/networks/network_reader.py
 src/tespy/tools/__init__.py
 src/tespy/tools/analyses.py
 src/tespy/tools/characteristics.py
 src/tespy/tools/data_containers.py
@@ -305,14 +308,15 @@
 tests/test_analyses/test_exergy_analysis.py
 tests/test_components/test_combustion.py
 tests/test_components/test_customs.py
 tests/test_components/test_heat_exchangers.py
 tests/test_components/test_piping.py
 tests/test_components/test_reactors.py
 tests/test_components/test_turbomachinery.py
+tests/test_models/cgam-ebsilon-results.csv
 tests/test_models/test_CGAM_model.py
 tests/test_models/test_heat_pump_model.py
 tests/test_models/test_solar_energy_generating_system.py
 tests/test_networks/test_network.py
 tests/test_tools/test_characteristics.py
 tests/test_tools/test_fluid_properties.py
 tests/test_tools/test_helpers.py
```

### Comparing `TESPy-0.6.2/src/tespy/__init__.py` & `TESPy-0.6.3/src/tespy/__init__.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 # -*- coding: utf-8
 from pkg_resources import resource_filename
 
 __datapath__ = resource_filename('tespy', 'data/')
-__version__ = '0.6.2 - Leidenfrost\'s Library'
+__version__ = '0.6.3 - Leidenfrost\'s Library'
 
 # tespy data and connections import
 from . import connections  # noqa: F401
 from . import data  # noqa: F401
 # tespy components imports
 from .components import basics  # noqa: F401
 from .components import combustion  # noqa: F401
```

### Comparing `TESPy-0.6.2/src/tespy/components/__init__.py` & `TESPy-0.6.3/src/tespy/components/__init__.py`

 * *Files 4% similar despite different names*

```diff
@@ -9,14 +9,15 @@
 from .combustion.engine import CombustionEngine  # noqa: F401
 from .customs.orc_evaporator import ORCEvaporator  # noqa: F401
 from .heat_exchangers.base import HeatExchanger  # noqa: F401
 from .heat_exchangers.condenser import Condenser  # noqa: F401
 from .heat_exchangers.desuperheater import Desuperheater  # noqa: F401
 from .heat_exchangers.parabolic_trough import ParabolicTrough  # noqa: F401
 from .heat_exchangers.simple import HeatExchangerSimple  # noqa: F401
+from .heat_exchangers.simple import SimpleHeatExchanger  # noqa: F401
 from .heat_exchangers.solar_collector import SolarCollector  # noqa: F401
 from .nodes.droplet_separator import DropletSeparator  # noqa: F401
 from .nodes.drum import Drum  # noqa: F401
 from .nodes.merge import Merge  # noqa: F401
 from .nodes.separator import Separator  # noqa: F401
 from .nodes.splitter import Splitter  # noqa: F401
 from .piping.pipe import Pipe  # noqa: F401
```

### Comparing `TESPy-0.6.2/src/tespy/components/basics/source.py` & `TESPy-0.6.3/src/tespy/components/basics/source.py`

 * *Files 27% similar despite different names*

```diff
@@ -1,110 +1,114 @@
-# -*- coding: utf-8
-
-"""Module for class Source.
-
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location tespy/components/basics/source.py
-
-SPDX-License-Identifier: MIT
-"""
-
-import numpy as np
-
-from tespy.components.component import Component
-
-
-class Source(Component):
-    r"""
-    A flow originates from a Source.
-
-    Parameters
-    ----------
-    label : str
-        The label of the component.
-
-    design : list
-        List containing design parameters (stated as String).
-
-    offdesign : list
-        List containing offdesign parameters (stated as String).
-
-    design_path : str
-        Path to the components design case.
-
-    local_offdesign : boolean
-        Treat this component in offdesign mode in a design calculation.
-
-    local_design : boolean
-        Treat this component in design mode in an offdesign calculation.
-
-    char_warnings : boolean
-        Ignore warnings on default characteristics usage for this component.
-
-    printout : boolean
-        Include this component in the network's results printout.
-
-    Example
-    -------
-    Create a source and specify a label.
-
-    >>> from tespy.components import Source
-    >>> so = Source('a labeled source')
-    >>> so.component()
-    'source'
-    >>> so.label
-    'a labeled source'
-    """
-
-    @staticmethod
-    def component():
-        return 'source'
-
-    @staticmethod
-    def outlets():
-        return ['out1']
-
-    @staticmethod
-    def get_mandatory_constraints():
-        return {}
-
-    def propagate_fluid_to_source(self, outconn, start):
-        r"""
-        Fluid propagation to source stops here.
-
-        Parameters
-        ----------
-        outconn : tespy.connections.connection.Connection
-            Connection to initialise.
-
-        start : tespy.components.component.Component
-            This component is the fluid propagation starting point.
-            The starting component is saved to prevent infinite looping.
-        """
-        return
-
-    def exergy_balance(self, T0):
-        r"""Exergy balance calculation method of a source.
-
-        A source does not destroy or produce exergy. The value of
-        :math:`\dot{E}_\mathrm{bus}` is set to the exergy of the mass flow to
-        make exergy balancing methods more simple as in general a mass flow can
-        be fuel, product or loss.
-
-        Parameters
-        ----------
-        T0 : float
-            Ambient temperature T0 / K.
-
-        Note
-        ----
-        .. math::
-
-            \dot{E}_\mathrm{bus} = \dot{E}_\mathrm{out}^\mathrm{PH}
-        """
-        self.E_P = np.nan
-        self.E_F = np.nan
-        self.E_bus = self.outl[0].Ex_physical
-        self.E_D = np.nan
-        self.epsilon = np.nan
+# -*- coding: utf-8
+
+"""Module for class Source.
+
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location tespy/components/basics/source.py
+
+SPDX-License-Identifier: MIT
+"""
+
+import numpy as np
+
+from tespy.components.component import Component
+
+
+class Source(Component):
+    r"""
+    A flow originates from a Source.
+
+    Parameters
+    ----------
+    label : str
+        The label of the component.
+
+    design : list
+        List containing design parameters (stated as String).
+
+    offdesign : list
+        List containing offdesign parameters (stated as String).
+
+    design_path : str
+        Path to the components design case.
+
+    local_offdesign : boolean
+        Treat this component in offdesign mode in a design calculation.
+
+    local_design : boolean
+        Treat this component in design mode in an offdesign calculation.
+
+    char_warnings : boolean
+        Ignore warnings on default characteristics usage for this component.
+
+    printout : boolean
+        Include this component in the network's results printout.
+
+    Example
+    -------
+    Create a source and specify a label.
+
+    >>> from tespy.components import Source
+    >>> so = Source('a labeled source')
+    >>> so.component()
+    'source'
+    >>> so.label
+    'a labeled source'
+    """
+
+    @staticmethod
+    def component():
+        return 'source'
+
+    @staticmethod
+    def outlets():
+        return ['out1']
+
+    @staticmethod
+    def get_mandatory_constraints():
+        return {}
+
+    def propagate_fluid_to_source(self, outconn, start, entry_point=False):
+        r"""
+        Fluid propagation to source stops here.
+
+        Parameters
+        ----------
+        outconn : tespy.connections.connection.Connection
+            Connection to initialise.
+
+        start : tespy.components.component.Component
+            This component is the fluid propagation starting point.
+            The starting component is saved to prevent infinite looping.
+        """
+        return
+
+    def exergy_balance(self, T0):
+        r"""Exergy balance calculation method of a source.
+
+        A source does not destroy or produce exergy. The value of
+        :math:`\dot{E}_\mathrm{bus}` is set to the exergy of the mass flow to
+        make exergy balancing methods more simple as in general a mass flow can
+        be fuel, product or loss.
+
+        Parameters
+        ----------
+        T0 : float
+            Ambient temperature T0 / K.
+
+        Note
+        ----
+        .. math::
+
+            \dot{E}_\mathrm{bus} = \dot{E}_\mathrm{out}^\mathrm{PH}
+        """
+        self.E_P = np.nan
+        self.E_F = np.nan
+        self.E_bus = {
+            "chemical": self.outl[0].Ex_chemical,
+            "physical": self.outl[0].Ex_physical,
+            "massless": 0
+        }
+        self.E_D = np.nan
+        self.epsilon = np.nan
```

### Comparing `TESPy-0.6.2/src/tespy/components/basics/subsystem_interface.py` & `TESPy-0.6.3/src/tespy/components/basics/subsystem_interface.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 available from its original location
 tespy/components/basics/subsystem_interface.py
 
 SPDX-License-Identifier: MIT
 """
 
 from tespy.components.component import Component
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
+from tespy.tools.data_containers import SimpleDataContainer as dc_simple
 
 
 class SubsystemInterface(Component):
     r"""
     The subsystem interface does not change fluid properties.
 
     **Mandatory Equations**
```

### Comparing `TESPy-0.6.2/src/tespy/components/combustion/base.py` & `TESPy-0.6.3/src/tespy/components/combustion/base.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,27 +7,28 @@
 by the contributors recorded in the version control history of the file,
 available from its original location
 tespy/components/combustion/base.py
 
 SPDX-License-Identifier: MIT
 """
 
-import logging
-
 import CoolProp.CoolProp as CP
 import numpy as np
 
 from tespy.components.component import Component
+from tespy.tools import logger
 from tespy.tools.data_containers import ComponentProperties as dc_cp
 from tespy.tools.document_models import generate_latex_eq
 from tespy.tools.fluid_properties import h_mix_pT
 from tespy.tools.fluid_properties import s_mix_pT
+from tespy.tools.global_vars import combustion_gases
 from tespy.tools.global_vars import molar_masses
 from tespy.tools.helpers import TESPyComponentError
 from tespy.tools.helpers import fluid_structure
+from tespy.tools.helpers import fluidalias_in_list
 
 
 class CombustionChamber(Component):
     r"""
     The class CombustionChamber is parent class of all combustion components.
 
     **Mandatory Equations**
@@ -196,58 +197,52 @@
     def inlets():
         return ['in1', 'in2']
 
     @staticmethod
     def outlets():
         return ['out1']
 
-    def comp_init(self, nw):
-        Component.comp_init(self, nw)
+    def preprocess(self, nw):
+        super().preprocess(nw)
         self.setup_reaction_parameters()
 
     def setup_reaction_parameters(self):
         r"""Setup parameters for reaction (gas name aliases and LHV)."""
         self.fuel_list = []
-        fuels = [
-            'methane', 'ethane', 'propane', 'butane', 'hydrogen', 'nDodecane']
-        for f in fuels:
-            self.fuel_list += [x for x in self.nw_fluids if x in [
-                a.replace(' ', '') for a in CP.get_aliases(f)]]
+        for f in self.nw_fluids:
+            if fluidalias_in_list(f, combustion_gases):
+                self.fuel_list += [f]
 
         if len(self.fuel_list) == 0:
             msg = ('Your network\'s fluids do not contain any fuels, that are '
                    'available for the component ' + self.label + ' of type ' +
                    self.component() + '. Available fuels are: ' +
-                   ', '.join(fuels) + '.')
-            logging.error(msg)
+                   ', '.join(combustion_gases) + '.')
+            logger.error(msg)
             raise TESPyComponentError(msg)
 
         else:
             msg = ('The fuels for component ' + self.label + ' of type ' +
                    self.component() + ' are: ' + ', '.join(self.fuel_list) +
                    '.')
-            logging.debug(msg)
+            logger.debug(msg)
 
-        for fluid in ['o2', 'co2', 'h2o', 'n2']:
-            try:
-                setattr(
-                    self, fluid, [x for x in self.nw_fluids if x in [
-                        a.replace(' ', '') for a in
-                        CP.get_aliases(fluid.upper())
-                    ]][0])
-            except IndexError:
+        for fluid in ['O2', 'CO2', 'H2O', 'N2']:
+            if not fluidalias_in_list(fluid, self.nw_fluids):
+                aliases = ', '.join(CP.get_aliases(fluid))
                 msg = (
                     'The component ' + self.label + ' (class ' +
                     self.__class__.__name__ + ') requires that the fluid '
-                    '[fluid] is in the network\'s list of fluids.')
-                aliases = ', '.join(CP.get_aliases(fluid.upper()))
-                msg = msg.replace(
-                    '[fluid]', fluid.upper() + ' (aliases: ' + aliases + ')')
-                logging.error(msg)
+                    f'{fluid} (aliases: {aliases}) is in the network\'s list '
+                    'of fluids.'
+                )
+                logger.error(msg)
                 raise TESPyComponentError(msg)
+            else:
+                setattr(self, fluid.lower(), fluid)
 
         self.fuels = {}
         for f in self.fuel_list:
             self.fuels[f] = {}
             structure = fluid_structure(f)
             for el in ['C', 'H', 'O']:
                 if el in structure:
@@ -1296,30 +1291,30 @@
                 \end{cases}
         """
         if key == 'p':
             return 5e5
         elif key == 'h':
             return 5e5
 
-    def propagate_fluid_to_target(self, inconn, start):
+    def propagate_fluid_to_target(self, inconn, start, entry_point=False):
         r"""
         Fluid propagation to target stops here.
 
         Parameters
         ----------
         inconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
         return
 
-    def propagate_fluid_to_source(self, outconn, start):
+    def propagate_fluid_to_source(self, outconn, start, entry_point=False):
         r"""
         Fluid propagation to source stops here.
 
         Parameters
         ----------
         outconn : tespy.connections.connection.Connection
             Connection to initialise.
@@ -1395,7 +1390,20 @@
         for c in self.inl:
             self.S_comb -= c.m.val_SI * (
                 c.s.val_SI -
                 s_mix_pT([0, p_ref, 0, c.fluid.val], T_ref, force_gas=True))
 
         self.S_irr = 0
         self.T_mcomb = self.calc_ti() / self.S_comb
+
+    def exergy_balance(self, T0):
+        self.E_P = self.outl[0].Ex_physical - (
+            self.inl[0].Ex_physical + self.inl[1].Ex_physical
+        )
+        self.E_F = (
+            self.inl[0].Ex_chemical + self.inl[1].Ex_chemical
+            - self.outl[0].Ex_chemical
+        )
+
+        self.E_D = self.E_F - self.E_P
+        self.epsilon = self.E_P/self.E_F
+        self.E_bus = np.nan
```

### Comparing `TESPy-0.6.2/src/tespy/components/combustion/diabatic.py` & `TESPy-0.6.3/src/tespy/components/combustion/diabatic.py`

 * *Files 14% similar despite different names*

```diff
@@ -7,17 +7,18 @@
 by the contributors recorded in the version control history of the file,
 available from its original location
 tespy/components/combustion/diabatic.py
 
 SPDX-License-Identifier: MIT
 """
 
-import logging
+import numpy as np
 
 from tespy.components import CombustionChamber
+from tespy.tools import logger
 from tespy.tools.data_containers import ComponentProperties as dc_cp
 from tespy.tools.document_models import generate_latex_eq
 from tespy.tools.fluid_properties import h_mix_pT
 
 
 class DiabaticCombustionChamber(CombustionChamber):
     r"""
@@ -143,27 +144,42 @@
     ratio of the combustion chamber must be specified. Since the component is
     not adiabatic, an efficiency value :code:`eta` can be supplied to account
     for heat loss to the ambient. First, we specify :code:`eta=1` and expect
     identical lambda or outlet temperature as in an adiabatic combustion
     chamber.
 
     >>> comb.set_attr(ti=500000, pr=0.95, eta=1)
-    >>> amb_comb.set_attr(p=1, T=20, fluid={'Ar': 0.0129, 'N2': 0.7553,
+    >>> amb_comb.set_attr(p=1.2, T=20, fluid={'Ar': 0.0129, 'N2': 0.7553,
     ... 'H2O': 0, 'CH4': 0, 'CO2': 0.0004, 'O2': 0.2314, 'H2': 0})
     >>> sf_comb.set_attr(T=25, fluid={'CO2': 0.03, 'H2': 0.01, 'Ar': 0,
-    ... 'N2': 0, 'O2': 0, 'H2O': 0, 'CH4': 0.96}, p=1.2)
+    ... 'N2': 0, 'O2': 0, 'H2O': 0, 'CH4': 0.96}, p=1.3)
     >>> comb_fg.set_attr(T=1200)
     >>> nw.solve('design')
     >>> round(comb.lamb.val, 3)
     2.014
+    >>> round(comb_fg.p.val, 2)
+    1.14
+
+    Instead of the pressure ration, we can also specify the outlet pressure.
+    The pressure ratio is the ratio or pressure at the outlet to the pressure
+    at the inlet 1 (ambient air inlet in this example).
+
+    >>> comb.set_attr(pr=None)
+    >>> comb_fg.set_attr(p=1)
+    >>> nw.solve('design')
+    >>> round(comb.pr.val, 3)
+    0.833
+
+    We can change lambda to a specific value and unset the flue gas temperature:
+
     >>> comb.set_attr(lamb=2)
     >>> comb_fg.set_attr(T=None)
     >>> nw.solve('design')
     >>> round(comb_fg.T.val, 1)
-    1206.6
+    1206.5
 
     Now, if we change the efficiency value, e.g. to 0.9, a total of 10 % of
     heat respective to the thermal input will be transferred to the ambient.
     Note, that the heat loss :code:`Q_loss` has a negative value as it is
     extracted from the system.
 
     >>> eta = 0.9
@@ -337,15 +353,15 @@
             r'\;p_\mathrm{ref}=\unit[10^5]{Pa}\\'
             '\n' + r'\end{split}'
         )
         return generate_latex_eq(self, latex, label)
 
     def calc_parameters(self):
         r"""Postprocessing parameter calculation."""
-        CombustionChamber.calc_parameters(self)
+        super().calc_parameters()
 
         T_ref = 298.15
         p_ref = 1e5
 
         res = 0
         for i in self.inl:
             res += i.m.val_SI * (i.h.val_SI - h_mix_pT(
@@ -354,13 +370,29 @@
         for o in self.outl:
             res -= o.m.val_SI * (o.h.val_SI - h_mix_pT(
                 [0, p_ref, 0, o.fluid.val], T_ref, force_gas=True))
 
         self.eta.val = -res / self.ti.val
         self.Q_loss.val = -(1 - self.eta.val) * self.ti.val
 
-        if self.inl[1].p.val < self.inl[0].p.val:
-            msg = (
-                "The pressure at inlet 2 is lower than the pressure at inlet 1 "
-                "at component " + self.label + "."
-            )
-            logging.warning(msg)
+        self.pr.val = self.outl[0].p.val_SI / self.inl[0].p.val_SI
+        for i in range(self.num_i):
+            if self.inl[i].p.val < self.outl[0].p.val:
+                msg = (
+                    f"The pressure at inlet {i + 1} is lower than the pressure "
+                    f"at the outlet of component {self.label}."
+                )
+                logger.warning(msg)
+
+    def exergy_balance(self, T0):
+
+        self.E_P = self.outl[0].Ex_physical - (
+            self.inl[0].Ex_physical + self.inl[1].Ex_physical
+        )
+        self.E_F = (
+            self.inl[0].Ex_chemical + self.inl[1].Ex_chemical -
+            self.outl[0].Ex_chemical
+        )
+
+        self.E_D = self.E_F - self.E_P
+        self.epsilon = self.E_P / self.E_F
+        self.E_bus = {"chemical": np.nan, "physical": np.nan, "massless": np.nan}
```

### Comparing `TESPy-0.6.2/src/tespy/components/combustion/engine.py` & `TESPy-0.6.3/src/tespy/components/combustion/engine.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,24 +6,21 @@
 This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
 by the contributors recorded in the version control history of the file,
 available from its original location
 tespy/components/combustion/engine.py
 
 SPDX-License-Identifier: MIT
 """
-
-import logging
-
 import numpy as np
 
 from tespy.components.combustion.base import CombustionChamber
-from tespy.components.component import Component
+from tespy.tools import logger
 from tespy.tools.data_containers import ComponentCharacteristics as dc_cc
 from tespy.tools.data_containers import ComponentProperties as dc_cp
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
+from tespy.tools.data_containers import SimpleDataContainer as dc_simple
 from tespy.tools.document_models import generate_latex_eq
 from tespy.tools.fluid_properties import h_mix_pT
 from tespy.tools.fluid_properties import s_mix_ph
 from tespy.tools.fluid_properties import s_mix_pT
 from tespy.tools.global_vars import molar_masses
 
 
@@ -343,31 +340,31 @@
     def inlets():
         return ['in1', 'in2', 'in3', 'in4']
 
     @staticmethod
     def outlets():
         return ['out1', 'out2', 'out3']
 
-    def comp_init(self, nw):
+    def preprocess(self, nw):
 
         if not self.P.is_set:
             self.set_attr(P='var')
             msg = ('The power output of combustion engines must be set! '
                    'We are adding the power output of component ' +
                    self.label + ' as custom variable of the system.')
-            logging.info(msg)
+            logger.info(msg)
 
         if not self.Qloss.is_set:
             self.set_attr(Qloss='var')
             msg = ('The heat loss of combustion engines must be set! '
                    'We are adding the heat loss of component ' +
                    self.label + ' as custom variable of the system.')
-            logging.info(msg)
+            logger.info(msg)
 
-        Component.comp_init(self, nw)
+        super().preprocess(nw)
 
         self.setup_reaction_parameters()
 
     def mass_flow_func(self):
         r"""
         Calculate the residual value for component's mass flow balance.
 
@@ -1233,15 +1230,15 @@
             val = self.calc_Qloss()
 
         ######################################################################
         # missing/invalid bus parameter
         else:
             msg = ('The parameter ' + str(bus['param']) +
                    ' is not a valid parameter for a ' + self.component() + '.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         return val
 
     def bus_func_doc(self, bus):
         r"""
         Return LaTeX string of the bus function.
@@ -1354,15 +1351,15 @@
             deriv[0, 5, 2] = self.numeric_deriv(f, 'h', 5, bus=bus)
 
         ######################################################################
         # missing/invalid bus parameter
         else:
             msg = ('The parameter ' + str(b['param']) +
                    ' is not a valid parameter for a ' + self.component() + '.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         return deriv
 
     def initialise_fluids(self):
         """Calculate reaction balance for generic starting values at outlet."""
         N_2 = 0.7655
@@ -1470,47 +1467,51 @@
                 \end{cases}
         """
         if key == 'p':
             return 5e5
         elif key == 'h':
             return 5e5
 
-    def propagate_fluid_to_target(self, inconn, start):
+    def propagate_fluid_to_target(self, inconn, start, entry_point=False):
         r"""
         Propagate the fluids towards connection's target in recursion.
 
         Parameters
         ----------
         inconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
+        if not entry_point and inconn == start:
+            return
         for outconn in self.outl[:2]:
             for fluid, x in inconn.fluid.val.items():
                 if (outconn.fluid.val_set[fluid] is False and
                         outconn.good_starting_values is False):
                     outconn.fluid.val[fluid] = x
             outconn.target.propagate_fluid_to_target(outconn, start)
 
-    def propagate_fluid_to_source(self, outconn, start):
+    def propagate_fluid_to_source(self, outconn, start, entry_point=False):
         r"""
         Propagate the fluids towards connection's source in recursion.
 
         Parameters
         ----------
         outconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
+        if not entry_point and outconn == start:
+            return
         for inconn in self.inl[:2]:
             for fluid, x in outconn.fluid.val.items():
                 if (inconn.fluid.val_set[fluid] is False and
                         inconn.good_starting_values is False):
                     inconn.fluid.val[fluid] = x
 
             inconn.source.propagate_fluid_to_source(inconn, start)
@@ -1528,19 +1529,19 @@
                     4 * self.inl[i].m.val_SI ** 2 *
                     (self.inl[i].vol.val_SI + self.outl[i].vol.val_SI)
                 ))
 
         self.P.val = self.calc_P()
         self.Qloss.val = self.calc_Qloss()
 
-        CombustionChamber.calc_parameters(self)
+        super().calc_parameters()
 
     def check_parameter_bounds(self):
         r"""Check parameter value limits."""
-        Component.check_parameter_bounds(self)
+        super().check_parameter_bounds()
         # get bound errors for characteristic lines
         if np.isnan(self.P.design):
             expr = 1
         else:
             expr = self.P.val / self.P.design
         self.tiP_char.char_func.get_domain_errors(expr, self.label)
         self.Qloss_char.char_func.get_domain_errors(expr, self.label)
@@ -1687,7 +1688,23 @@
 
         # thermodynamic temperature of heat input
         self.T_mcomb = self.calc_ti() / self.S_comb
         # total irreversibilty production
         self.S_irr = (
             self.S_irr_i + self.S_irr2 + self.S_irr1 + self.S_Q1irr +
             self.S_Q2irr)
+
+    def exergy_balance(self, T0):
+
+        self.E_P = (
+            self.outl[2].Ex_physical - (self.inl[3].Ex_physical + self.inl[2].Ex_physical)
+            - self.P.val + (self.outl[1] - self.inl[1]) + (self.outl[0] - self.inl[0])
+        )
+        self.E_F = (
+            self.inl[3].Ex_chemical + self.inl[2].Ex_chemical
+            - self.outl[2].Ex_chemical
+        )
+        self.E_D = self.E_F - self.E_P
+        self.epsilon = self.E_P / self.E_F
+        self.E_bus = {
+            "chemical": np.nan, "physical": np.nan, "massless": -self.P.val
+        }
```

### Comparing `TESPy-0.6.2/src/tespy/components/component.py` & `TESPy-0.6.3/src/tespy/components/heat_exchangers/simple.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,1475 +1,1143 @@
-# -*- coding: utf-8
-
-"""Module class component.
-
-All tespy components inherit from this class.
-
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location tespy/components/components.py
-
-SPDX-License-Identifier: MIT
-"""
-
-import logging
-from collections import OrderedDict
-
-import numpy as np
-
-from tespy.tools.characteristics import CharLine
-from tespy.tools.characteristics import CharMap
-from tespy.tools.characteristics import load_default_char as ldc
-from tespy.tools.data_containers import ComponentCharacteristicMaps as dc_cm
-from tespy.tools.data_containers import ComponentCharacteristics as dc_cc
-from tespy.tools.data_containers import ComponentProperties as dc_cp
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
-from tespy.tools.data_containers import GroupedComponentCharacteristics as dc_gcc
-from tespy.tools.data_containers import GroupedComponentProperties as dc_gcp
-from tespy.tools.document_models import generate_latex_eq
-from tespy.tools.fluid_properties import v_mix_ph
-from tespy.tools.global_vars import err
-from tespy.tools.helpers import bus_char_derivative
-from tespy.tools.helpers import bus_char_evaluation
-from tespy.tools.helpers import newton
-
-# %%
-
-
-class Component:
-    r"""
-    Class Component is the base class of all TESPy components.
-
-    Parameters
-    ----------
-    label : str
-        The label of the component.
-
-    design : list
-        List containing design parameters (stated as String).
-
-    offdesign : list
-        List containing offdesign parameters (stated as String).
-
-    design_path : str
-        Path to the components design case.
-
-    local_offdesign : boolean
-        Treat this component in offdesign mode in a design calculation.
-
-    local_design : boolean
-        Treat this component in design mode in an offdesign calculation.
-
-    char_warnings : boolean
-        Ignore warnings on default characteristics usage for this component.
-
-    printout : boolean
-        Include this component in the network's results printout.
-
-    **kwargs :
-        See the class documentation of desired component for available
-        keywords.
-
-    Note
-    ----
-    The initialisation method (__init__), setter method (set_attr) and getter
-    method (get_attr) are used for instances of class component and its
-    children.
-
-    Allowed keywords in kwargs are 'design_path', 'design' and 'offdesign'.
-    Additional keywords depend on the type of component you want to create.
-
-    Example
-    -------
-    Basic example for a setting up a
-    :py:class:`tespy.components.component.Component` object. This example does
-    not run a tespy calculation.
-
-    >>> from tespy.components.component import Component
-    >>> comp = Component('myComponent')
-    >>> type(comp)
-    <class 'tespy.components.component.Component'>
-    """
-
-    def __init__(self, label, **kwargs):
-
-        # check if components label is of type str and for prohibited chars
-        if not isinstance(label, str):
-            msg = 'Component label must be of type str!'
-            logging.error(msg)
-            raise ValueError(msg)
-
-        elif len([x for x in [';', ',', '.'] if x in label]) > 0:
-            msg = (
-                'You must not use ' + str([';', ',', '.']) + ' in label (' +
-                str(self.component()) + ').')
-            logging.error(msg)
-            raise ValueError(msg)
-
-        else:
-            self.label = label
-
-        # defaults
-        self.new_design = True
-        self.design_path = None
-        self.design = []
-        self.offdesign = []
-        self.local_design = False
-        self.local_offdesign = False
-        self.char_warnings = True
-        self.printout = True
-
-        # add container for components attributes
-        self.variables = OrderedDict(self.get_variables().copy())
-        self.__dict__.update(self.variables)
-        self.set_attr(**kwargs)
-
-    def set_attr(self, **kwargs):
-        r"""
-        Set, reset or unset attributes of a component for provided arguments.
-
-        Parameters
-        ----------
-        design : list
-            List containing design parameters (stated as String).
-
-        offdesign : list
-            List containing offdesign parameters (stated as String).
-
-        design_path: str
-            Path to the components design case.
-
-        **kwargs :
-            See the class documentation of desired component for available
-            keywords.
-
-        Note
-        ----
-        Allowed keywords in kwargs are obtained from class documentation as all
-        components share the
-        :py:meth:`tespy.components.component.Component.set_attr` method.
-        """
-        # set specified values
-        for key in kwargs:
-            if key in self.variables:
-                data = self.get_attr(key)
-                if kwargs[key] is None:
-                    data.set_attr(is_set=False)
-                    try:
-                        data.set_attr(is_var=False)
-                    except KeyError:
-                        pass
-                    continue
-
-                try:
-                    float(kwargs[key])
-                    is_numeric = True
-                except (TypeError, ValueError):
-                    is_numeric = False
-
-                # dict specification
-                if (isinstance(kwargs[key], dict) and
-                        not isinstance(data, dc_simple)):
-                    data.set_attr(**kwargs[key])
-
-                # value specification for component properties
-                elif isinstance(data, dc_cp) or isinstance(data, dc_simple):
-                    if is_numeric:
-                        if np.isnan(kwargs[key]):
-                            data.set_attr(is_set=False)
-                            if isinstance(data, dc_cp):
-                                data.set_attr(is_var=False)
-
-                        else:
-                            data.set_attr(val=kwargs[key], is_set=True)
-                            if isinstance(data, dc_cp):
-                                data.set_attr(is_var=False)
-
-                    elif (kwargs[key] == 'var' and
-                          isinstance(data, dc_cp)):
-                        data.set_attr(is_set=True, is_var=True)
-
-                    elif isinstance(data, dc_simple):
-                        data.set_attr(val=kwargs[key], is_set=True)
-
-                    # invalid datatype for keyword
-                    else:
-                        msg = (
-                            'Bad datatype for keyword argument ' + key +
-                            ' at ' + self.label + '.')
-                        logging.error(msg)
-                        raise TypeError(msg)
-
-                elif isinstance(data, dc_cc) or isinstance(data, dc_cm):
-                    # value specification for characteristics
-                    if (isinstance(kwargs[key], CharLine) or
-                            isinstance(kwargs[key], CharMap)):
-                        data.char_func = kwargs[key]
-
-                    # invalid datatype for keyword
-                    else:
-                        msg = (
-                            'Bad datatype for keyword argument ' + key +
-                            ' at ' + self.label + '.')
-                        logging.error(msg)
-                        raise TypeError(msg)
-
-                elif isinstance(data, dc_gcp):
-                    # value specification of grouped component parameter method
-                    if isinstance(kwargs[key], str):
-                        data.method = kwargs[key]
-
-                    # invalid datatype for keyword
-                    else:
-                        msg = (
-                            'Bad datatype for keyword argument ' + key +
-                            ' at ' + self.label + '.')
-                        logging.error(msg)
-                        raise TypeError(msg)
-
-            elif key in ['design', 'offdesign']:
-                if not isinstance(kwargs[key], list):
-                    msg = (
-                        'Please provide the ' + key + ' parameters as list '
-                        'at ' + self.label + '.')
-                    logging.error(msg)
-                    raise TypeError(msg)
-                if set(kwargs[key]).issubset(list(self.variables.keys())):
-                    self.__dict__.update({key: kwargs[key]})
-
-                else:
-                    msg = (
-                        'Available parameters for (off-)design specification '
-                        'are: ' + str(list(self.variables.keys())) + ' at ' +
-                        self.label + '.')
-                    logging.error(msg)
-                    raise ValueError(msg)
-
-            elif key in ['local_design', 'local_offdesign',
-                         'printout', 'char_warnings']:
-                if not isinstance(kwargs[key], bool):
-                    msg = (
-                        'Please provide the parameter ' + key + ' as boolean '
-                        'at component ' + self.label + '.')
-                    logging.error(msg)
-                    raise TypeError(msg)
-
-                else:
-                    self.__dict__.update({key: kwargs[key]})
-
-            elif key == 'design_path' or key == 'fkt_group':
-                if isinstance(kwargs[key], str):
-                    self.__dict__.update({key: kwargs[key]})
-                elif kwargs[key] is None:
-                    self.design_path = None
-                elif np.isnan(kwargs[key]):
-                    self.design_path = None
-                else:
-                    msg = (
-                        'Please provide the design_path parameter as string. '
-                        'For unsetting use np.nan or None.')
-                    logging.error(msg)
-                    raise TypeError(msg)
-
-                self.new_design = True
-
-            # invalid keyword
-            else:
-                msg = (
-                    'Component ' + self.label + ' has no attribute ' +
-                    str(key) + '.')
-                logging.error(msg)
-                raise KeyError(msg)
-
-    def get_attr(self, key):
-        r"""
-        Get the value of a component's attribute.
-
-        Parameters
-        ----------
-        key : str
-            The attribute you want to retrieve.
-
-        Returns
-        -------
-        out :
-            Value of specified attribute.
-        """
-        if key in self.__dict__:
-            return self.__dict__[key]
-        else:
-            msg = ('Component ' + self.label + ' has no attribute \"' +
-                   key + '\".')
-            logging.error(msg)
-            raise KeyError(msg)
-
-    def comp_init(self, nw, num_eq=0):
-        r"""
-        Perform component initialization in network preprocessing.
-
-        Parameters
-        ----------
-        nw : tespy.networks.network.Network
-            Network this component is integrated in.
-        """
-        self.num_nw_fluids = len(nw.fluids)
-        self.nw_fluids = nw.fluids
-        self.always_all_equations = nw.always_all_equations
-        self.num_nw_vars = self.num_nw_fluids + 3
-        self.it = 0
-        self.num_eq = 0
-        self.vars = {}
-        self.num_vars = 0
-        self.constraints = OrderedDict(self.get_mandatory_constraints().copy())
-        self.prop_specifications = {}
-        self.var_specifications = {}
-        self.group_specifications = {}
-        self.char_specifications = {}
-        self.__dict__.update(self.constraints)
-
-        for constraint in self.constraints.values():
-            self.num_eq += constraint['num_eq']
-
-        for key, val in self.variables.items():
-            data = self.get_attr(key)
-            if isinstance(val, dc_cp):
-                if data.is_var:
-                    data.var_pos = self.num_vars
-                    self.num_vars += 1
-                    self.vars[data] = key
-
-                self.prop_specifications[key] = val.is_set
-                self.var_specifications[key] = val.is_var
-
-            # component characteristics
-            elif isinstance(val, dc_cc):
-                if data.func is not None:
-                    self.char_specifications[key] = val.is_set
-                if data.char_func is None:
-                    try:
-                        data.char_func = ldc(
-                            self.component(), key, 'DEFAULT', CharLine)
-                    except KeyError:
-                        data.char_func = CharLine(x=[0, 1], y=[1, 1])
-
-            # component characteristics
-            elif isinstance(val, dc_cm):
-                if data.func is not None:
-                    self.char_specifications[key] = val.is_set
-                if data.char_func is None:
-                    try:
-                        data.char_func = ldc(
-                            self.component(), key, 'DEFAULT', CharMap)
-                    except KeyError:
-                        data.char_func = CharLine(x=[0, 1], y=[1, 1])
-
-            # grouped component properties
-            elif isinstance(val, dc_gcp):
-                is_set = True
-                for e in data.elements:
-                    if not self.get_attr(e).is_set:
-                        is_set = False
-
-                if is_set:
-                    data.set_attr(is_set=True)
-                elif data.is_set:
-                    start = (
-                        'All parameters of the component group have to be '
-                        'specified! This component group uses the following '
-                        'parameters: ')
-                    end = ' at ' + self.label + '. Group will be set to False.'
-                    logging.warning(start + ', '.join(val.elements) + end)
-                    val.set_attr(is_set=False)
-                else:
-                    val.set_attr(is_set=False)
-                self.group_specifications[key] = val.is_set
-
-            # grouped component characteristics
-            elif isinstance(val, dc_gcc):
-                self.group_specifications[key] = val.is_set
-
-            # component properties
-            if data.is_set and data.func is not None:
-                self.num_eq += data.num_eq
-
-        # set up Jacobian matrix and residual vector
-        self.jacobian = np.zeros((
-            self.num_eq,
-            self.num_i + self.num_o + self.num_vars,
-            self.num_nw_vars))
-        self.residual = np.zeros(self.num_eq)
-
-        sum_eq = 0
-        for constraint in self.constraints.values():
-            num_eq = constraint['num_eq']
-            if constraint['constant_deriv']:
-                self.jacobian[sum_eq:sum_eq + num_eq] = constraint['deriv']()
-            sum_eq += num_eq
-
-        # done
-        msg = (
-            'The component ' + self.label + ' has ' + str(self.num_vars) +
-            ' custom variables.')
-        logging.debug(msg)
-
-    def get_variables(self):
-        return {}
-
-    def get_mandatory_constraints(self):
-        return {
-            'mass_flow_constraints': {
-                'func': self.mass_flow_func, 'deriv': self.mass_flow_deriv,
-                'constant_deriv': True, 'latex': self.mass_flow_func_doc,
-                'num_eq': self.num_i},
-            'fluid_constraints': {
-                'func': self.fluid_func, 'deriv': self.fluid_deriv,
-                'constant_deriv': True, 'latex': self.fluid_func_doc,
-                'num_eq': self.num_nw_fluids * self.num_i}
-        }
-
-    @staticmethod
-    def inlets():
-        return []
-
-    @staticmethod
-    def outlets():
-        return []
-
-    def get_char_expr(self, param, type='rel', inconn=0, outconn=0):
-        r"""
-        Generic method to access characteristic function parameters.
-
-        Parameters
-        ----------
-        param : str
-            Parameter for characteristic function evaluation.
-
-        type : str
-            Type of expression:
-
-            - :code:`rel`: relative to design value
-            - :code:`abs`: absolute value
-
-        inconn : int
-            Index of inlet connection.
-
-        outconn : int
-            Index of outlet connection.
-
-        Returns
-        -------
-        expr : float
-            Value of expression
-        """
-        if type == 'rel':
-            if param == 'm':
-                return (
-                    self.inl[inconn].m.val_SI / self.inl[inconn].m.design)
-            elif param == 'm_out':
-                return (
-                    self.outl[outconn].m.val_SI /
-                    self.outl[outconn].m.design)
-            elif param == 'v':
-                v = self.inl[inconn].m.val_SI * v_mix_ph(
-                    self.inl[inconn].get_flow(),
-                    T0=self.inl[inconn].T.val_SI)
-                return v / self.inl[inconn].v.design
-            elif param == 'pr':
-                return (
-                    (self.outl[outconn].p.val_SI *
-                     self.inl[inconn].p.design) /
-                    (self.inl[inconn].p.val_SI *
-                     self.outl[outconn].p.design))
-            else:
-                msg = (
-                    'The parameter ' + str(param) + ' is not available '
-                    'for characteristic function evaluation.')
-                logging.error(msg)
-                raise ValueError(msg)
-        else:
-            if param == 'm':
-                return self.inl[inconn].m.val_SI
-            elif param == 'm_out':
-                return self.outl[outconn].m.val_SI
-            elif param == 'v':
-                return self.inl[inconn].m.val_SI * v_mix_ph(
-                    self.inl[inconn].get_flow(),
-                    T0=self.inl[inconn].T.val_SI)
-            elif param == 'pr':
-                return (
-                    self.outl[outconn].p.val_SI /
-                    self.inl[inconn].p.val_SI)
-            else:
-                return False
-
-    def get_char_expr_doc(self, param, type='rel', inconn=0, outconn=0):
-        r"""
-        Generic method to access characteristic function parameters.
-
-        Parameters
-        ----------
-        param : str
-            Parameter for characteristic function evaluation.
-
-        type : str
-            Type of expression:
-
-            - :code:`rel`: relative to design value
-            - :code:`abs`: absolute value
-
-        inconn : int
-            Index of inlet connection.
-
-        outconn : int
-            Index of outlet connection.
-
-        Returns
-        -------
-        expr : str
-            LaTeX code for documentation
-        """
-        if type == 'rel':
-            if param == 'm':
-                return (
-                    r'\frac{\dot{m}_\mathrm{in,' + str(inconn + 1) + r'}}'
-                    r'{\dot{m}_\mathrm{in,' + str(inconn + 1) +
-                    r',design}}')
-            elif param == 'm_out':
-                return (
-                    r'\frac{\dot{m}_\mathrm{out,' + str(outconn + 1) +
-                    r'}}{\dot{m}_\mathrm{out,' + str(outconn + 1) +
-                    r',design}}')
-            elif param == 'v':
-                return (
-                    r'\frac{\dot{V}_\mathrm{in,' + str(inconn + 1) + r'}}'
-                    r'{\dot{V}_\mathrm{in,' + str(inconn + 1) +
-                    r',design}}')
-            elif param == 'pr':
-                return (
-                    r'\frac{p_\mathrm{out,' + str(outconn + 1) +
-                    r'}\cdot p_\mathrm{in,' + str(inconn + 1) +
-                    r',design}}{p_\mathrm{out,' + str(outconn + 1) +
-                    r',design}\cdot p_\mathrm{in,' + str(inconn + 1) +
-                    r'}}')
-        else:
-            if param == 'm':
-                return r'\dot{m}_\mathrm{in,' + str(inconn + 1) + r'}'
-            elif param == 'm_out':
-                return r'\dot{m}_\mathrm{out,' + str(outconn + 1) + r'}'
-            elif param == 'v':
-                return r'\dot{V}_\mathrm{in,' + str(inconn + 1) + r'}'
-            elif param == 'pr':
-                return (
-                    r'\frac{p_\mathrm{out,' + str(outconn + 1) +
-                    r'}}{p_\mathrm{in,' + str(inconn + 1) + r'}}')
-
-    def solve(self, increment_filter):
-        """
-        Solve equations and calculate partial derivatives of a component.
-
-        Parameters
-        ----------
-        increment_filter : ndarray
-            Matrix for filtering non-changing variables.
-        """
-        sum_eq = 0
-        for constraint in self.constraints.values():
-            num_eq = constraint['num_eq']
-            self.residual[sum_eq:sum_eq + num_eq] = constraint['func']()
-            if not constraint['constant_deriv']:
-                constraint['deriv'](increment_filter, sum_eq)
-            sum_eq += num_eq
-
-        for parameter, data in self.variables.items():
-            if data.is_set and data.func is not None:
-                self.residual[sum_eq:sum_eq + data.num_eq] = data.func(
-                    **data.func_params)
-                data.deriv(increment_filter, sum_eq, **data.func_params)
-
-                sum_eq += data.num_eq
-
-    def bus_func(self, bus):
-        r"""
-        Base method for calculation of the value of the bus function.
-
-        Parameters
-        ----------
-        bus : tespy.connections.bus.Bus
-            TESPy bus object.
-
-        Returns
-        -------
-        residual : float
-            Residual value of bus equation.
-        """
-        return 0
-
-    def bus_func_doc(self, bus):
-        r"""
-        Base method for LaTeX equation generation of the bus function.
-
-        Parameters
-        ----------
-        bus : tespy.connections.bus.Bus
-            TESPy bus object.
-
-        Returns
-        -------
-        latex : str
-            Bus function in LaTeX format.
-        """
-        return None
-
-    def bus_deriv(self, bus):
-        r"""
-        Base method for partial derivatives of the bus function.
-
-        Parameters
-        ----------
-        bus : tespy.connections.bus.Bus
-            TESPy bus object.
-
-        Returns
-        -------
-        deriv : ndarray
-            Matrix of partial derivatives.
-        """
-        return np.zeros((1, self.num_i + self.num_o, self.num_nw_vars))
-
-    def calc_bus_expr(self, bus):
-        r"""
-        Return the busses' characteristic line input expression.
-
-        Parameters
-        ----------
-        bus : tespy.connections.bus.Bus
-            Bus to calculate the characteristic function expression for.
-
-        Returns
-        -------
-        expr : float
-            Ratio of power to power design depending on the bus base
-            specification.
-        """
-        b = bus.comps.loc[self]
-        if np.isnan(b['P_ref']) or b['P_ref'] == 0:
-            return 1
-        else:
-            comp_val = self.bus_func(b)
-            if b['base'] == 'component':
-                return abs(comp_val / b['P_ref'])
-            else:
-                bus_value = newton(
-                    bus_char_evaluation,
-                    bus_char_derivative,
-                    [comp_val, b['P_ref'], b['char']], 0,
-                    val0=b['P_ref'], valmin=-1e15, valmax=1e15)
-                return bus_value / b['P_ref']
-
-    def calc_bus_efficiency(self, bus):
-        r"""
-        Return the busses' efficiency.
-
-        Parameters
-        ----------
-        bus : tespy.connections.bus.Bus
-            Bus to calculate the efficiency value on.
-
-        Returns
-        -------
-        efficiency : float
-            Efficiency value of the bus.
-
-            .. math::
-
-                \eta_\mathrm{bus} = \begin{cases}
-                \eta\left(
-                \frac{\dot{E}_\mathrm{bus}}{\dot{E}_\mathrm{bus,ref}}\right) &
-                \text{bus base = 'bus'}\\
-                \eta\left(
-                \frac{\dot{E}_\mathrm{component}}
-                {\dot{E}_\mathrm{component,ref}}\right) &
-                \text{bus base = 'component'}
-                \end{cases}
-
-        Note
-        ----
-        If the base value of the bus is the bus value itself, a newton
-        iteration is used to find the bus value satisfying the corresponding
-        equation (case 1).
-        """
-        return bus.comps.loc[self, 'char'].evaluate(self.calc_bus_expr(bus))
-
-    def calc_bus_value(self, bus):
-        r"""
-        Return the busses' value of the component's energy transfer.
-
-        Parameters
-        ----------
-        bus : tespy.connections.bus.Bus
-            Bus to calculate energy transfer on.
-
-        Returns
-        -------
-        bus_value : float
-            Value of the energy transfer on the specified bus.
-
-            .. math::
-
-                \dot{E}_\mathrm{bus} = \begin{cases}
-                \frac{\dot{E}_\mathrm{component}}{f\left(
-                \frac{\dot{E}_\mathrm{bus}}{\dot{E}_\mathrm{bus,ref}}\right)} &
-                \text{bus base = 'bus'}\\
-                \dot{E}_\mathrm{component} \cdot f\left(
-                \frac{\dot{E}_\mathrm{component}}
-                {\dot{E}_\mathrm{component,ref}}\right) &
-                \text{bus base = 'component'}
-                \end{cases}
-
-        Note
-        ----
-        If the base value of the bus is the bus value itself, a newton
-        iteration is used to find the bus value satisfying the corresponding
-        equation (case 1).
-        """
-        b = bus.comps.loc[self]
-        comp_val = self.bus_func(b)
-        expr = self.calc_bus_expr(bus)
-        if b['base'] == 'component':
-            return comp_val * b['char'].evaluate(expr)
-        else:
-            return comp_val / b['char'].evaluate(expr)
-
-    def initialise_source(self, c, key):
-        r"""
-        Return a starting value for pressure and enthalpy at outlet.
-
-        Parameters
-        ----------
-        c : tespy.connections.connection.Connection
-            Connection to perform initialisation on.
-
-        key : str
-            Fluid property to retrieve.
-
-        Returns
-        -------
-        val : float
-            Starting value for pressure/enthalpy in SI units.
-
-            .. math::
-
-                val = \begin{cases}
-                0 & \text{key = 'p'}\\
-                0 & \text{key = 'h'}
-                \end{cases}
-        """
-        return 0
-
-    def initialise_target(self, c, key):
-        r"""
-        Return a starting value for pressure and enthalpy at inlet.
-
-        Parameters
-        ----------
-        c : tespy.connections.connection.Connection
-            Connection to perform initialisation on.
-
-        key : str
-            Fluid property to retrieve.
-
-        Returns
-        -------
-        val : float
-            Starting value for pressure/enthalpy in SI units.
-
-            .. math::
-
-                val = \begin{cases}
-                0 & \text{key = 'p'}\\
-                0 & \text{key = 'h'}
-                \end{cases}
-        """
-        return 0
-
-    def propagate_fluid_to_target(self, inconn, start):
-        r"""
-        Propagate the fluids towards connection's target in recursion.
-
-        Parameters
-        ----------
-        inconn : tespy.connections.connection.Connection
-            Connection to initialise.
-
-        start : tespy.components.component.Component
-            This component is the fluid propagation starting point.
-            The starting component is saved to prevent infinite looping.
-        """
-        conn_idx = self.inl.index(inconn)
-        outconn = self.outl[conn_idx]
-
-        for fluid, x in inconn.fluid.val.items():
-            if (outconn.fluid.val_set[fluid] is False and
-                    outconn.good_starting_values is False):
-                outconn.fluid.val[fluid] = x
-
-        outconn.target.propagate_fluid_to_target(outconn, start)
-
-    def propagate_fluid_to_source(self, outconn, start):
-        r"""
-        Propagate the fluids towards connection's source in recursion.
-
-        Parameters
-        ----------
-        outconn : tespy.connections.connection.Connection
-            Connection to initialise.
-
-        start : tespy.components.component.Component
-            This component is the fluid propagation starting point.
-            The starting component is saved to prevent infinite looping.
-        """
-        conn_idx = self.outl.index(outconn)
-        inconn = self.inl[conn_idx]
-
-        for fluid, x in outconn.fluid.val.items():
-            if (inconn.fluid.val_set[fluid] is False and
-                    inconn.good_starting_values is False):
-                inconn.fluid.val[fluid] = x
-
-        inconn.source.propagate_fluid_to_source(inconn, start)
-
-    def set_parameters(self, mode, data):
-        r"""
-        Set or unset design values of component parameters.
-
-        Parameters
-        ----------
-        mode : str
-            Setting component design values for :code:`mode='offdesign'`
-            and unsetting them for :code:`mode='design'`.
-
-        df : pandas.core.series.Series
-            Series containing the component parameters.
-        """
-        if mode == 'design' or self.local_design:
-            self.new_design = True
-
-        for key, dc in self.variables.items():
-            if isinstance(dc, dc_cp):
-                if ((mode == 'offdesign' and not self.local_design) or
-                        (mode == 'design' and self.local_offdesign)):
-                    self.get_attr(key).design = data[key]
-
-                else:
-                    self.get_attr(key).design = np.nan
-
-    def calc_parameters(self):
-        r"""Postprocessing parameter calculation."""
-        return
-
-    def check_parameter_bounds(self):
-        r"""Check parameter value limits."""
-        for p in self.variables.keys():
-            data = self.get_attr(p)
-            if isinstance(data, dc_cp):
-                if data.val > data.max_val + err:
-                    msg = (
-                        'Invalid value for ' + p + ': ' + p + ' = ' +
-                        str(data.val) + ' above maximum value (' +
-                        str(data.max_val) + ') at component ' + self.label +
-                        '.')
-                    logging.warning(msg)
-
-                elif data.val < data.min_val - err:
-                    msg = (
-                        'Invalid value for ' + p + ': ' + p + ' = ' +
-                        str(data.val) + ' below minimum value (' +
-                        str(data.min_val) + ') at component ' + self.label +
-                        '.')
-                    logging.warning(msg)
-
-            elif isinstance(data, dc_cc) and data.is_set:
-                expr = self.get_char_expr(data.param, **data.char_params)
-                data.char_func.get_domain_errors(expr, self.label)
-
-            elif isinstance(data, dc_gcc) and data.is_set:
-                for char in data.elements:
-                    char_data = self.get_attr(char)
-                    expr = self.get_char_expr(
-                        char_data.param, **char_data.char_params)
-                    char_data.char_func.get_domain_errors(expr, self.label)
-
-    def initialise_fluids(self):
-        return
-
-    def convergence_check(self):
-        return
-
-    def entropy_balance(self):
-        r"""Entropy balance calculation method."""
-        return
-
-    def exergy_balance(self, T0):
-        r"""
-        Exergy balance calculation method.
-
-        Parameters
-        ----------
-        T0 : float
-            Ambient temperature T0 / K.
-        """
-        self.E_P = np.nan
-        self.E_F = np.nan
-        self.E_bus = np.nan
-        self.E_D = np.nan
-        self.epsilon = np.nan
-
-    def get_plotting_data(self):
-        return
-
-    def fluid_func(self):
-        r"""
-        Calculate the vector of residual values for fluid balance equations.
-
-        Returns
-        -------
-        residual : list
-            Vector of residual values for component's fluid balance.
-
-            .. math::
-
-                0 = x_{fl,in,i} - x_{fl,out,i} \; \forall fl \in
-                \text{network fluids,} \; \forall i \in \text{inlets}
-        """
-        residual = []
-        for i in range(self.num_i):
-            for fluid, x in self.inl[0].fluid.val.items():
-                residual += [x - self.outl[0].fluid.val[fluid]]
-        return residual
-
-    def fluid_func_doc(self, label):
-        r"""
-        Get fluid balance equations in LaTeX format.
-
-        Parameters
-        ----------
-        label : str
-            Label for equation.
-
-        Returns
-        -------
-        latex : str
-            LaTeX code of equations applied.
-        """
-        indices = list(range(1, self.num_i + 1))
-        if len(indices) > 1:
-            indices = ', '.join(str(idx) for idx in indices)
-        else:
-            indices = str(indices[0])
-        latex = (
-            r'0=x_{fl\mathrm{,in,}i}-x_{fl\mathrm{,out,}i}\;'
-            r'\forall fl \in\text{network fluids,}'
-            r'\; \forall i \in [' + indices + r']')
-        return generate_latex_eq(self, latex, label)
-
-    def fluid_deriv(self):
-        r"""
-        Calculate partial derivatives for all fluid balance equations.
-
-        Returns
-        -------
-        deriv : ndarray
-            Matrix with partial derivatives for the fluid equations.
-        """
-        deriv = np.zeros((self.fluid_constraints['num_eq'],
-                          2 * self.num_i + self.num_vars,
-                          self.num_nw_vars))
-        for i in range(self.num_i):
-            for j in range(self.num_nw_fluids):
-                deriv[i * self.num_nw_fluids + j, i, j + 3] = 1
-                deriv[i * self.num_nw_fluids + j, self.num_i + i, j + 3] = -1
-        return deriv
-
-    def mass_flow_func(self):
-        r"""
-        Calculate the residual value for mass flow balance equation.
-
-        Returns
-        -------
-        residual : list
-            Vector with residual value for component's mass flow balance.
-
-            .. math::
-
-                0 = \dot{m}_{in,i} -\dot{m}_{out,i} \;\forall i\in\text{inlets}
-        """
-        residual = []
-        for i in range(self.num_i):
-            residual += [self.inl[i].m.val_SI - self.outl[i].m.val_SI]
-        return residual
-
-    def mass_flow_func_doc(self, label):
-        r"""
-        Get mass flow equations in LaTeX format.
-
-        Parameters
-        ----------
-        label : str
-            Label for equation.
-
-        Returns
-        -------
-        latex : str
-            LaTeX code of equations applied.
-        """
-        indices = list(range(1, self.num_i + 1))
-        if len(indices) > 1:
-            indices = ', '.join(str(idx) for idx in indices)
-        else:
-            indices = str(indices[0])
-        latex = (
-            r'0=\dot{m}_{\mathrm{in,}i}-\dot{m}_{\mathrm{out,}i}'
-            r'\; \forall i \in [' + indices + r']')
-        return generate_latex_eq(self, latex, label)
-
-    def mass_flow_deriv(self):
-        r"""
-        Calculate partial derivatives for all mass flow balance equations.
-
-        Returns
-        -------
-        deriv : ndarray
-            Matrix with partial derivatives for the mass flow balance
-            equations.
-        """
-        deriv = np.zeros((
-            self.num_i,
-            self.num_i + self.num_o + self.num_vars,
-            self.num_nw_vars))
-        for i in range(self.num_i):
-            deriv[i, i, 0] = 1
-        for j in range(self.num_o):
-            deriv[j, j + i + 1, 0] = -1
-        return deriv
-
-    def pressure_equality_func(self):
-        r"""
-        Equation for pressure equality.
-
-        Returns
-        -------
-        residual : float
-            Residual value of equation.
-
-            .. math::
-
-                0 = p_{in,i} - p_{out,i} \;\forall i\in\text{inlets}
-        """
-        residual = []
-        for i in range(self.num_i):
-            residual += [self.inl[i].p.val_SI - self.outl[i].p.val_SI]
-        return residual
-
-    def pressure_equality_func_doc(self, label):
-        r"""
-        Equation for pressure equality.
-
-        Parameters
-        ----------
-        label : str
-            Label for equation.
-
-        Returns
-        -------
-        latex : str
-            LaTeX code of equations applied.
-        """
-        indices = list(range(1, self.num_i + 1))
-        if len(indices) > 1:
-            indices = ', '.join(str(idx) for idx in indices)
-        else:
-            indices = str(indices[0])
-        latex = (
-            r'0=p_{\mathrm{in,}i}-p_{\mathrm{out,}i}'
-            r'\; \forall i \in [' + indices + r']')
-        return generate_latex_eq(self, latex, label)
-
-    def pressure_equality_deriv(self):
-        r"""
-        Calculate partial derivatives for all mass flow balance equations.
-
-        Returns
-        -------
-        deriv : ndarray
-            Matrix with partial derivatives for the mass flow balance
-            equations.
-        """
-        deriv = np.zeros((
-            self.num_i,
-            self.num_i + self.num_o + self.num_vars,
-            self.num_nw_vars))
-        for i in range(self.num_i):
-            deriv[i, i, 1] = 1
-        for j in range(self.num_o):
-            deriv[j, j + i + 1, 1] = -1
-        return deriv
-
-    def enthalpy_equality_func(self):
-        r"""
-        Equation for enthalpy equality.
-
-        Returns
-        -------
-        residual : list
-            Residual values of equations.
-
-            .. math::
-
-                0 = h_{in,i} - h_{out,i} \;\forall i\in\text{inlets}
-        """
-        residual = []
-        for i in range(self.num_i):
-            residual += [self.inl[i].h.val_SI - self.outl[i].h.val_SI]
-        return residual
-
-    def enthalpy_equality_func_doc(self, label):
-        r"""
-        Equation for enthalpy equality.
-
-        Parameters
-        ----------
-        label : str
-            Label for equation.
-
-        Returns
-        -------
-        latex : str
-            LaTeX code of equations applied.
-        """
-        indices = list(range(1, self.num_i + 1))
-        if len(indices) > 1:
-            indices = ', '.join(str(idx) for idx in indices)
-        else:
-            indices = str(indices[0])
-        latex = (
-            r'0=h_{\mathrm{in,}i}-h_{\mathrm{out,}i}'
-            r'\; \forall i \in [' + indices + r']')
-        return generate_latex_eq(self, latex, label)
-
-    def enthalpy_equality_deriv(self):
-        r"""
-        Calculate partial derivatives for all mass flow balance equations.
-
-        Returns
-        -------
-        deriv : ndarray
-            Matrix with partial derivatives for the mass flow balance
-            equations.
-        """
-        deriv = np.zeros((
-            self.num_i,
-            self.num_i + self.num_o + self.num_vars,
-            self.num_nw_vars))
-        for i in range(self.num_i):
-            deriv[i, i, 2] = 1
-        for j in range(self.num_o):
-            deriv[j, j + i + 1, 2] = -1
-        return deriv
-
-    def numeric_deriv(self, func, dx, pos, **kwargs):
-        r"""
-        Calculate partial derivative of the function func to dx.
-
-        Parameters
-        ----------
-        func : function
-            Function :math:`f` to calculate the partial derivative for.
-
-        dx : str
-            Partial derivative.
-
-        pos : int
-            Position of connection regarding to inlets and outlet of the
-            component, logic: ['in1', 'in2', ..., 'out1', ...] ->
-            0, 1, ..., n, n + 1, ..., n + m
-
-        Returns
-        -------
-        deriv : float/list
-            Partial derivative(s) of the function :math:`f` to variable(s)
-            :math:`x`.
-
-            .. math::
-
-                \frac{\partial f}{\partial x} = \frac{f(x + d) + f(x - d)}{2 d}
-        """
-        if dx == 'fluid':
-            d = 1e-5
-            conns = self.inl + self.outl
-            deriv = []
-            for f in conns[0].fluid.val.keys():
-                val = conns[pos].fluid.val[f]
-                if conns[pos].fluid.val[f] + d <= 1:
-                    conns[pos].fluid.val[f] += d
-                else:
-                    conns[pos].fluid.val[f] = 1
-                exp = func(**kwargs)
-                if conns[pos].fluid.val[f] - 2 * d >= 0:
-                    conns[pos].fluid.val[f] -= 2 * d
-                else:
-                    conns[pos].fluid.val[f] = 0
-                exp -= func(**kwargs)
-                conns[pos].fluid.val[f] = val
-
-                deriv += [exp / (2 * d)]
-
-        elif dx in ['m', 'p', 'h']:
-
-            if dx == 'm':
-                d = 1e-4
-            else:
-                d = 1e-1
-            conns = self.inl + self.outl
-            conns[pos].get_attr(dx).val_SI += d
-            exp = func(**kwargs)
-
-            conns[pos].get_attr(dx).val_SI -= 2 * d
-            exp -= func(**kwargs)
-            deriv = exp / (2 * d)
-
-            conns[pos].get_attr(dx).val_SI += d
-
-        else:
-            d = self.get_attr(dx).d
-            exp = 0
-            self.get_attr(dx).val += d
-            exp += func(**kwargs)
-
-            self.get_attr(dx).val -= 2 * d
-            exp -= func(**kwargs)
-            deriv = exp / (2 * d)
-
-            self.get_attr(dx).val += d
-
-        return deriv
-
-    def pr_func(self, pr='', inconn=0, outconn=0):
-        r"""
-        Calculate residual value of pressure ratio function.
-
-        Parameters
-        ----------
-        pr : str
-            Component parameter to evaluate the pr_func on, e.g.
-            :code:`pr1`.
-
-        inconn : int
-            Connection index of inlet.
-
-        outconn : int
-            Connection index of outlet.
-
-        Returns
-        -------
-        residual : float
-            Residual value of function.
-
-            .. math::
-
-                0 = p_{in} \cdot pr - p_{out}
-        """
-        pr = self.get_attr(pr)
-        return (self.inl[inconn].p.val_SI * pr.val -
-                self.outl[outconn].p.val_SI)
-
-    def pr_func_doc(self, label, pr='', inconn=0, outconn=0):
-        r"""
-        Calculate residual value of pressure ratio function.
-
-        Parameters
-        ----------
-        pr : str
-            Component parameter to evaluate the pr_func on, e.g.
-            :code:`pr1`.
-
-        inconn : int
-            Connection index of inlet.
-
-        outconn : int
-            Connection index of outlet.
-
-        Returns
-        -------
-        residual : float
-            Residual value of function.
-        """
-        latex = (
-            r'0=p_\mathrm{in,' + str(inconn + 1) + r'}\cdot ' + pr +
-            r' - p_\mathrm{out,' + str(outconn + 1) + r'}'
-        )
-        return generate_latex_eq(self, latex, label)
-
-    def pr_deriv(self, increment_filter, k, pr='', inconn=0, outconn=0):
-        r"""
-        Calculate residual value of pressure ratio function.
-
-        Parameters
-        ----------
-        increment_filter : ndarray
-            Matrix for filtering non-changing variables.
-
-        k : int
-            Position of equation in Jacobian matrix.
-
-        pr : str
-            Component parameter to evaluate the pr_func on, e.g.
-            :code:`pr1`.
-
-        inconn : int
-            Connection index of inlet.
-
-        outconn : int
-            Connection index of outlet.
-        """
-        pr = self.get_attr(pr)
-        self.jacobian[k, inconn, 1] = pr.val
-        self.jacobian[k, self.num_i + outconn, 1] = -1
-        if pr.is_var:
-            pos = self.num_i + self.num_o + pr.var_pos
-            self.jacobian[k, pos, 0] = self.inl[inconn].p.val_SI
-
-    def zeta_func(self, zeta='', inconn=0, outconn=0):
-        r"""
-        Calculate residual value of :math:`\zeta`-function.
-
-        Parameters
-        ----------
-        zeta : str
-            Component parameter to evaluate the zeta_func on, e.g.
-            :code:`zeta1`.
-
-        inconn : int
-            Connection index of inlet.
-
-        outconn : int
-            Connection index of outlet.
-
-        Returns
-        -------
-        residual : float
-            Residual value of function.
-
-            .. math::
-
-                0 = \begin{cases}
-                p_{in} - p_{out} & |\dot{m}| < \epsilon \\
-                \frac{\zeta}{D^4} - \frac{(p_{in} - p_{out}) \cdot \pi^2}
-                {8 \cdot \dot{m}_{in} \cdot |\dot{m}_{in}| \cdot \frac{v_{in} +
-                v_{out}}{2}} &
-                |\dot{m}| > \epsilon
-                \end{cases}
-
-        Note
-        ----
-        The zeta value is caluclated on the basis of a given pressure loss at
-        a given flow rate in the design case. As the cross sectional area A
-        will not change, it is possible to handle the equation in this way:
-
-        .. math::
-
-            \frac{\zeta}{D^4} = \frac{\Delta p \cdot \pi^2}
-            {8 \cdot \dot{m}^2 \cdot v}
-        """
-        data = self.get_attr(zeta)
-        i = self.inl[inconn].get_flow()
-        o = self.outl[outconn].get_flow()
-
-        if abs(i[0]) < 1e-4:
-            return i[1] - o[1]
-
-        else:
-            v_i = v_mix_ph(i, T0=self.inl[inconn].T.val_SI)
-            v_o = v_mix_ph(o, T0=self.outl[outconn].T.val_SI)
-            return (data.val - (i[1] - o[1]) * np.pi ** 2 /
-                    (8 * abs(i[0]) * i[0] * (v_i + v_o) / 2))
-
-    def zeta_func_doc(self, label, zeta='', inconn=0, outconn=0):
-        r"""
-        Calculate residual value of :math:`\zeta`-function.
-
-        Parameters
-        ----------
-        zeta : str
-            Component parameter to evaluate the zeta_func on, e.g.
-            :code:`zeta1`.
-
-        inconn : int
-            Connection index of inlet.
-
-        outconn : int
-            Connection index of outlet.
-
-        Returns
-        -------
-        residual : float
-            Residual value of function.
-        """
-        inl = r'_\mathrm{in,' + str(inconn + 1) + r'}'
-        outl = r'_\mathrm{out,' + str(outconn + 1) + r'}'
-        latex = (
-            r'0 = \begin{cases}' + '\n' +
-            r'p' + inl + r'- p' + outl + r' & |\dot{m}' + inl +
-            r'| < \unitfrac[0.0001]{kg}{s} \\' + '\n' +
-            r'\frac{\zeta}{D^4}-\frac{(p' + inl + r'-p' + outl + r')'
-            r'\cdot\pi^2}{8\cdot\dot{m}' + inl + r'\cdot|\dot{m}' + inl +
-            r'|\cdot\frac{v' + inl + r' + v' + outl + r'}{2}}' +
-            r'& |\dot{m}' + inl + r'| \geq \unitfrac[0.0001]{kg}{s}' + '\n'
-            r'\end{cases}'
-        )
-        return generate_latex_eq(self, latex, label)
-
-    def zeta_deriv(self, increment_filter, k, zeta='', inconn=0, outconn=0):
-        r"""
-        Calculate partial derivatives of zeta function.
-
-        Parameters
-        ----------
-        increment_filter : ndarray
-            Matrix for filtering non-changing variables.
-
-        k : int
-            Position of equation in Jacobian matrix.
-
-        zeta : str
-            Component parameter to evaluate the zeta_func on, e.g.
-            :code:`zeta1`.
-
-        inconn : int
-            Connection index of inlet.
-
-        outconn : int
-            Connection index of outlet.
-        """
-        data = self.get_attr(zeta)
-        f = self.zeta_func
-        outpos = self.num_i + outconn
-        if not increment_filter[inconn, 0]:
-            self.jacobian[k, inconn, 0] = self.numeric_deriv(
-                f, 'm', inconn, zeta=zeta, inconn=inconn, outconn=outconn)
-        if not increment_filter[inconn, 2]:
-            self.jacobian[k, inconn, 1] = self.numeric_deriv(
-                f, 'p', inconn, zeta=zeta, inconn=inconn, outconn=outconn)
-        if not increment_filter[inconn, 2]:
-            self.jacobian[k, inconn, 2] = self.numeric_deriv(
-                f, 'h', inconn, zeta=zeta, inconn=inconn, outconn=outconn)
-        if not increment_filter[outpos, 1]:
-            self.jacobian[k, outpos, 1] = self.numeric_deriv(
-                f, 'p', outpos, zeta=zeta, inconn=inconn, outconn=outconn)
-        if not increment_filter[outpos, 2]:
-            self.jacobian[k, outpos, 2] = self.numeric_deriv(
-                f, 'h', outpos, zeta=zeta, inconn=inconn, outconn=outconn)
-        # custom variable zeta
-        if data.is_var:
-            pos = self.num_i + self.num_o + data.var_pos
-            self.jacobian[k, pos, 0] = self.numeric_deriv(
-                f, zeta, 2, zeta=zeta, inconn=inconn, outconn=outconn)
+# -*- coding: utf-8
+
+"""Module of class SimpleHeatExchanger.
+
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location
+tespy/components/heat_exchangers/simple.py
+
+SPDX-License-Identifier: MIT
+"""
+
+import warnings
+
+import numpy as np
+
+from tespy.components.component import Component
+from tespy.tools import logger
+from tespy.tools.data_containers import ComponentCharacteristics as dc_cc
+from tespy.tools.data_containers import ComponentProperties as dc_cp
+from tespy.tools.data_containers import GroupedComponentProperties as dc_gcp
+from tespy.tools.data_containers import SimpleDataContainer as dc_simple
+from tespy.tools.document_models import generate_latex_eq
+from tespy.tools.fluid_properties import T_mix_ph
+from tespy.tools.fluid_properties import s_mix_ph
+from tespy.tools.fluid_properties import v_mix_ph
+from tespy.tools.fluid_properties import visc_mix_ph
+from tespy.tools.helpers import convert_to_SI
+from tespy.tools.helpers import darcy_friction_factor as dff
+
+
+class SimpleHeatExchanger(Component):
+    r"""
+    A basic heat exchanger representing a heat source or heat sink.
+
+    The component SimpleHeatExchanger is the parent class for the components:
+
+    - :py:class:`tespy.components.heat_exchangers.solar_collector.SolarCollector`
+    - :py:class:`tespy.components.heat_exchangers.parabolic_trough.ParabolicTrough`
+    - :py:class:`tespy.components.piping.pipe.Pipe`
+
+    **Mandatory Equations**
+
+    - :py:meth:`tespy.components.component.Component.fluid_func`
+    - :py:meth:`tespy.components.component.Component.mass_flow_func`
+
+    **Optional Equations**
+
+    - :py:meth:`tespy.components.component.Component.pr_func`
+    - :py:meth:`tespy.components.component.Component.zeta_func`
+    - :py:meth:`tespy.components.heat_exchangers.simple.SimpleHeatExchanger.energy_balance_func`
+    - :py:meth:`tespy.components.heat_exchangers.simple.SimpleHeatExchanger.hydro_group_func`
+    - :py:meth:`tespy.components.heat_exchangers.simple.SimpleHeatExchanger.kA_group_func`
+    - :py:meth:`tespy.components.heat_exchangers.simple.SimpleHeatExchanger.kA_char_group_func`
+
+    Inlets/Outlets
+
+    - in1
+    - out1
+
+    Image
+
+    .. image:: /api/_images/Pipe.svg
+       :alt: flowsheet of the simple heat exchanger
+       :align: center
+       :class: only-light
+
+    .. image:: /api/_images/Pipe_darkmode.svg
+       :alt: flowsheet of the simple heat exchanger
+       :align: center
+       :class: only-dark
+
+    Parameters
+    ----------
+    label : str
+        The label of the component.
+
+    design : list
+        List containing design parameters (stated as String).
+
+    offdesign : list
+        List containing offdesign parameters (stated as String).
+
+    design_path : str
+        Path to the components design case.
+
+    local_offdesign : boolean
+        Treat this component in offdesign mode in a design calculation.
+
+    local_design : boolean
+        Treat this component in design mode in an offdesign calculation.
+
+    char_warnings : boolean
+        Ignore warnings on default characteristics usage for this component.
+
+    printout : boolean
+        Include this component in the network's results printout.
+
+    Q : float, dict, :code:`"var"`
+        Heat transfer, :math:`Q/\text{W}`.
+
+    pr : float, dict, :code:`"var"`
+        Outlet to inlet pressure ratio, :math:`pr/1`.
+
+    zeta : float, dict, :code:`"var"`
+        Geometry independent friction coefficient,
+        :math:`\frac{\zeta}{D^4}/\frac{1}{\text{m}^4}`.
+
+    D : float, dict, :code:`"var"`
+        Diameter of the pipes, :math:`D/\text{m}`.
+
+    L : float, dict, :code:`"var"`
+        Length of the pipes, :math:`L/\text{m}`.
+
+    ks : float, dict, :code:`"var"`
+        Pipe's roughness, :math:`ks/\text{m}` for darcy friction,
+        :math:`ks/\text{1}` for hazen-williams equation.
+
+    hydro_group : str, dict
+        Parametergroup for pressure drop calculation based on pipes dimensions.
+        Choose 'HW' for hazen-williams equation, else darcy friction factor is
+        used.
+
+    kA : float, dict, :code:`"var"`
+        Area independent heat transfer coefficient,
+        :math:`kA/\frac{\text{W}}{\text{K}}`.
+
+    kA_char : tespy.tools.characteristics.CharLine, dict
+        Characteristic line for heat transfer coefficient.
+
+    Tamb : float, dict
+        Ambient temperature, provide parameter in network's temperature unit.
+
+    kA_group : str, dict
+        Parametergroup for heat transfer calculation from ambient temperature
+        and area independent heat transfer coefficient kA.
+
+    Example
+    -------
+    The SimpleHeatExchanger can be used as a sink or source of heat. This
+    component does not simulate the secondary side of the heat exchanger. It
+    is possible to calculate the pressure ratio with the Darcy-Weisbach
+    equation or in case of liquid water use the Hazen-Williams equation.
+    Also, given ambient temperature and the heat transfer coeffiecient, it is
+    possible to predict heat transfer.
+
+    >>> from tespy.components import Sink, Source, SimpleHeatExchanger
+    >>> from tespy.connections import Connection
+    >>> from tespy.networks import Network
+    >>> import shutil
+    >>> fluids = ['N2']
+    >>> nw = Network(fluids=fluids)
+    >>> nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg', iterinfo=False)
+    >>> so1 = Source('source 1')
+    >>> si1 = Sink('sink 1')
+    >>> heat_sink = SimpleHeatExchanger('heat sink')
+    >>> heat_sink.component()
+    'heat exchanger simple'
+    >>> heat_sink.set_attr(Tamb=10, pr=0.95, design=['pr'],
+    ... offdesign=['zeta', 'kA_char'])
+    >>> inc = Connection(so1, 'out1', heat_sink, 'in1')
+    >>> outg = Connection(heat_sink, 'out1', si1, 'in1')
+    >>> nw.add_conns(inc, outg)
+
+    It is possible to determine the amount of heat transferred when the fluid
+    enters the heat sink at a temperature of 200 C and is cooled down to
+    150 C. Given an ambient temperature of 10 C this also determines the heat
+    transfer coefficient to the ambient. Assuming a characteristic function
+    for the heat transfer coefficient we can predict the heat transferred at
+    variable flow rates.
+
+    >>> inc.set_attr(fluid={'N2': 1}, m=1, T=200, p=5)
+    >>> outg.set_attr(T=150, design=['T'])
+    >>> nw.solve('design')
+    >>> nw.save('tmp')
+    >>> round(heat_sink.Q.val, 0)
+    -52581.0
+    >>> round(heat_sink.kA.val, 0)
+    321.0
+    >>> inc.set_attr(m=1.25)
+    >>> nw.solve('offdesign', design_path='tmp')
+    >>> round(heat_sink.Q.val, 0)
+    -56599.0
+    >>> round(outg.T.val, 1)
+    156.9
+    >>> inc.set_attr(m=0.75)
+    >>> nw.solve('offdesign', design_path='tmp')
+    >>> round(heat_sink.Q.val, 1)
+    -47275.8
+    >>> round(outg.T.val, 1)
+    140.0
+    >>> shutil.rmtree('./tmp', ignore_errors=True)
+    """
+
+    @staticmethod
+    def component():
+        return 'heat exchanger simple'
+
+    def get_variables(self):
+        return {
+            'Q': dc_cp(
+                deriv=self.energy_balance_deriv,
+                latex=self.energy_balance_func_doc, num_eq=1,
+                func=self.energy_balance_func),
+            'pr': dc_cp(
+                min_val=1e-4, max_val=1, num_eq=1,
+                deriv=self.pr_deriv, latex=self.pr_func_doc,
+                func=self.pr_func, func_params={'pr': 'pr'}),
+            'zeta': dc_cp(
+                min_val=0, max_val=1e15, num_eq=1,
+                deriv=self.zeta_deriv, func=self.zeta_func,
+                latex=self.zeta_func_doc,
+                func_params={'zeta': 'zeta'}),
+            'D': dc_cp(min_val=1e-2, max_val=2, d=1e-4),
+            'L': dc_cp(min_val=1e-1, d=1e-3),
+            'ks': dc_cp(val=1e-4, min_val=1e-7, max_val=1e-3, d=1e-8),
+            'kA': dc_cp(min_val=0, d=1),
+            'kA_char': dc_cc(param='m'), 'Tamb': dc_cp(),
+            'dissipative': dc_simple(val=True),
+            'hydro_group': dc_gcp(
+                elements=['L', 'ks', 'D'], num_eq=1,
+                latex=self.hydro_group_func_doc,
+                func=self.hydro_group_func, deriv=self.hydro_group_deriv),
+            'kA_group': dc_gcp(
+                elements=['kA', 'Tamb'], num_eq=1,
+                latex=self.kA_group_func_doc,
+                func=self.kA_group_func, deriv=self.kA_group_deriv),
+            'kA_char_group': dc_gcp(
+                elements=['kA_char', 'Tamb'], num_eq=1,
+                latex=self.kA_char_group_func_doc,
+                func=self.kA_char_group_func, deriv=self.kA_char_group_deriv)
+        }
+
+    @staticmethod
+    def inlets():
+        return ['in1']
+
+    @staticmethod
+    def outlets():
+        return ['out1']
+
+    def preprocess(self, nw):
+        super().preprocess(nw, num_eq=len(nw.fluids) + 1)
+
+        self.Tamb.val_SI = convert_to_SI('T', self.Tamb.val, nw.T_unit)
+
+    def energy_balance_func(self):
+        r"""
+        Equation for pressure drop calculation.
+
+        Returns
+        -------
+        residual : float
+            Residual value of equation:
+
+            .. math::
+
+                0 =\dot{m}_{in}\cdot\left( h_{out}-h_{in}\right) -\dot{Q}
+        """
+        return self.inl[0].m.val_SI * (
+            self.outl[0].h.val_SI - self.inl[0].h.val_SI) - self.Q.val
+
+    def energy_balance_func_doc(self, label):
+        r"""
+        Equation for pressure drop calculation.
+
+        Parameters
+        ----------
+        label : str
+            Label for equation.
+
+        Returns
+        -------
+        latex : str
+            LaTeX code of equations applied.
+        """
+        latex = (
+            r'0 = \dot{m}_\mathrm{in} \cdot \left(h_\mathrm{out} - '
+            r'h_\mathrm{in} \right) -\dot{Q}'
+        )
+        return generate_latex_eq(self, latex, label)
+
+    def energy_balance_deriv(self, increment_filter, k):
+        r"""
+        Calculate partial derivatives of energy balance.
+
+        Parameters
+        ----------
+        increment_filter : ndarray
+            Matrix for filtering non-changing variables.
+
+        k : int
+            Position of derivatives in Jacobian matrix (k-th equation).
+        """
+        self.jacobian[k, 0, 0] = (
+            self.outl[0].h.val_SI - self.inl[0].h.val_SI)
+        self.jacobian[k, 0, 2] = -self.inl[0].m.val_SI
+        self.jacobian[k, 1, 2] = self.inl[0].m.val_SI
+        # custom variable Q
+        if self.Q.is_var:
+            self.jacobian[k, 2 + self.Q.var_pos, 0] = -1
+
+    def hydro_group_func(self):
+        r"""
+        Equation for pressure drop calculation.
+
+        Returns
+        -------
+        residual : float
+            Residual value of corresponding equation:
+
+            - :py:meth:`tespy.components.heat_exchangers.simple.SimpleHeatExchanger.darcy_func`
+            - :py:meth:`tespy.components.heat_exchangers.simple.SimpleHeatExchanger.hazen_williams_func`
+        """
+        # hazen williams equation
+        if self.hydro_group.method == 'HW':
+            return self.hazen_williams_func()
+        # darcy friction factor
+        else:
+            return self.darcy_func()
+
+    def hydro_group_func_doc(self, label):
+        r"""
+        Equation for pressure drop calculation.
+
+        Parameters
+        ----------
+        label : str
+            Label for equation.
+
+        Returns
+        -------
+        latex : str
+            LaTeX code of equations applied.
+        """
+        # hazen williams equation
+        if self.hydro_group.method == 'HW':
+            msg = (
+                "The Hazen-Williams equation will be accessible through its "
+                "own ks-value in the next major version. That means, you will "
+                "not need to specify hydro_group='HW' and ks. Instead of ks "
+                "specify ks_HW"
+            )
+            warnings.warn(msg, FutureWarning)
+            return self.hazen_williams_func_doc(label)
+        # darcy friction factor
+        else:
+            return self.darcy_func_doc(label)
+
+    def hydro_group_deriv(self, increment_filter, k):
+        r"""
+        Calculate partial derivatives of hydro group (pressure drop).
+
+        Parameters
+        ----------
+        increment_filter : ndarray
+            Matrix for filtering non-changing variables.
+
+        k : int
+            Position of derivatives in Jacobian matrix (k-th equation).
+        """
+        # hazen williams equation
+        if self.hydro_group.method == 'HW':
+            func = self.hazen_williams_func
+        # darcy friction factor
+        else:
+            func = self.darcy_func
+        if not increment_filter[0, 0]:
+            self.jacobian[k, 0, 0] = self.numeric_deriv(func, 'm', 0)
+        if not increment_filter[0, 1]:
+            self.jacobian[k, 0, 1] = self.numeric_deriv(func, 'p', 0)
+        if not increment_filter[0, 2]:
+            self.jacobian[k, 0, 2] = self.numeric_deriv(func, 'h', 0)
+        if not increment_filter[1, 1]:
+            self.jacobian[k, 1, 1] = self.numeric_deriv(func, 'p', 1)
+        if not increment_filter[1, 2]:
+            self.jacobian[k, 1, 2] = self.numeric_deriv(func, 'h', 1)
+        # custom variables of hydro group
+        for var in self.hydro_group.elements:
+            var = self.get_attr(var)
+            if var.is_var:
+                self.jacobian[k, 2 + var.var_pos, 0] = (
+                    self.numeric_deriv(func, self.vars[var], 2))
+
+    def darcy_func(self):
+        r"""
+        Equation for pressure drop calculation from darcy friction factor.
+
+        Returns
+        -------
+        residual : float
+            Residual value of equation.
+
+            .. math::
+
+                0 = p_{in} - p_{out} - \frac{8 \cdot |\dot{m}_{in}| \cdot
+                \dot{m}_{in} \cdot \frac{v_{in}+v_{out}}{2} \cdot L \cdot
+                \lambda\left(Re, ks, D\right)}{\pi^2 \cdot D^5}\\
+
+                Re = \frac{4 \cdot |\dot{m}_{in}|}{\pi \cdot D \cdot
+                \frac{\eta_{in}+\eta_{out}}{2}}\\
+                \eta: \text{dynamic viscosity}\\
+                v: \text{specific volume}\\
+                \lambda: \text{darcy friction factor}
+        """
+        i, o = self.inl[0].get_flow(), self.outl[0].get_flow()
+
+        if abs(i[0]) < 1e-4:
+            return i[1] - o[1]
+
+        visc_i = visc_mix_ph(i, T0=self.inl[0].T.val_SI)
+        visc_o = visc_mix_ph(o, T0=self.outl[0].T.val_SI)
+        v_i = v_mix_ph(i, T0=self.inl[0].T.val_SI)
+        v_o = v_mix_ph(o, T0=self.outl[0].T.val_SI)
+
+        Re = 4 * abs(i[0]) / (np.pi * self.D.val * (visc_i + visc_o) / 2)
+
+        return ((i[1] - o[1]) - 8 * abs(i[0]) * i[0] * (v_i + v_o) / 2 *
+                self.L.val * dff(Re, self.ks.val, self.D.val) /
+                (np.pi ** 2 * self.D.val ** 5))
+
+    def darcy_func_doc(self, label):
+        r"""
+        Equation for pressure drop calculation from darcy friction factor.
+
+        Parameters
+        ----------
+        label : str
+            Label for equation.
+
+        Returns
+        -------
+        latex : str
+            LaTeX code of equations applied.
+        """
+        latex = (
+            r'\begin{split}' + '\n'
+            r'0 = &p_\mathrm{in}-p_\mathrm{out}-'
+            r'\frac{8\cdot|\dot{m}_\mathrm{in}| \cdot\dot{m}_\mathrm{in}'
+            r'\cdot \frac{v_\mathrm{in}+v_\mathrm{out}}{2} \cdot L \cdot'
+            r'\lambda\left(Re, ks, D\right)}{\pi^2 \cdot D^5}\\' + '\n'
+            r'Re =&\frac{4 \cdot |\dot{m}_\mathrm{in}|}{\pi \cdot D \cdot'
+            r'\frac{\eta_\mathrm{in}+\eta_\mathrm{out}}{2}}\\' + '\n'
+            r'\end{split}'
+        )
+        return generate_latex_eq(self, latex, label)
+
+    def hazen_williams_func(self):
+        r"""
+        Equation for pressure drop calculation from Hazen-Williams equation.
+
+        Returns
+        -------
+        residual : float
+            Residual value of equation.
+
+            .. math::
+
+                0 = \left(p_{in} - p_{out} \right) \cdot \left(-1\right)^i -
+                \frac{10.67 \cdot |\dot{m}_{in}| ^ {1.852}
+                \cdot L}{ks^{1.852} \cdot D^{4.871}} \cdot g \cdot
+                \left(\frac{v_{in} + v_{out}}{2}\right)^{0.852}
+
+                i = \begin{cases}
+                0 & \dot{m}_{in} \geq 0\\
+                1 & \dot{m}_{in} < 0
+                \end{cases}
+
+        Note
+        ----
+        Gravity :math:`g` is set to :math:`9.81 \frac{m}{s^2}`
+        """
+        i, o = self.inl[0].get_flow(), self.outl[0].get_flow()
+
+        if abs(i[0]) < 1e-4:
+            return i[1] - o[1]
+
+        v_i = v_mix_ph(i, T0=self.inl[0].T.val_SI)
+        v_o = v_mix_ph(o, T0=self.outl[0].T.val_SI)
+
+        return ((i[1] - o[1]) * np.sign(i[0]) -
+                (10.67 * abs(i[0]) ** 1.852 * self.L.val /
+                 (self.ks.val ** 1.852 * self.D.val ** 4.871)) *
+                (9.81 * ((v_i + v_o) / 2) ** 0.852))
+
+    def hazen_williams_func_doc(self, label):
+        r"""
+        Equation for pressure drop calculation from Hazen-Williams equation.
+
+        Parameters
+        ----------
+        label : str
+            Label for equation.
+
+        Returns
+        -------
+        latex : str
+            LaTeX code of equations applied.
+        """
+        latex = (
+            r'0 = \left(p_\mathrm{in} - p_\mathrm{out} \right) -'
+            r'\frac{10.67 \cdot |\dot{m}_\mathrm{in}| ^ {1.852}'
+            r'\cdot L}{ks^{1.852} \cdot D^{4.871}} \cdot g \cdot'
+            r'\left(\frac{v_\mathrm{in}+ v_\mathrm{out}}{2}\right)^{0.852}'
+        )
+        return generate_latex_eq(self, latex, label)
+
+    def kA_group_func(self):
+        r"""
+        Calculate heat transfer from heat transfer coefficient.
+
+        Returns
+        -------
+        residual : float
+            Residual value of equation.
+
+            .. math::
+
+                0 = \dot{m}_{in} \cdot \left( h_{out} - h_{in}\right) +
+                kA \cdot \Delta T_{log}
+
+                \Delta T_{log} = \begin{cases}
+                \frac{T_{in}-T_{out}}{\ln{\frac{T_{in}-T_{amb}}
+                {T_{out}-T_{amb}}}} & T_{in} > T_{out} \\
+                \frac{T_{out}-T_{in}}{\ln{\frac{T_{out}-T_{amb}}
+                {T_{in}-T_{amb}}}} & T_{in} < T_{out}\\
+                0 & T_{in} = T_{out}
+                \end{cases}
+
+                T_{amb}: \text{ambient temperature}
+        """
+        i, o = self.inl[0].get_flow(), self.outl[0].get_flow()
+
+        ttd_1 = T_mix_ph(i, T0=self.inl[0].T.val_SI) - self.Tamb.val_SI
+        ttd_2 = T_mix_ph(o, T0=self.outl[0].T.val_SI) - self.Tamb.val_SI
+
+        # For numerical stability: If temperature differences have
+        # different sign use mean difference to avoid negative logarithm.
+        if (ttd_1 / ttd_2) < 0:
+            td_log = (ttd_2 + ttd_1) / 2
+        elif ttd_1 > ttd_2:
+            td_log = (ttd_1 - ttd_2) / np.log(ttd_1 / ttd_2)
+        elif ttd_1 < ttd_2:
+            td_log = (ttd_2 - ttd_1) / np.log(ttd_2 / ttd_1)
+        else:
+            # both values are equal
+            td_log = ttd_2
+
+        return i[0] * (o[2] - i[2]) + self.kA.val * td_log
+
+    def kA_group_func_doc(self, label):
+        r"""
+        Calculate heat transfer from heat transfer coefficient.
+
+        Parameters
+        ----------
+        label : str
+            Label for equation.
+
+        Returns
+        -------
+        latex : str
+            LaTeX code of equations applied.
+        """
+        latex = (
+            r'\begin{split}' + '\n'
+            r'0=&\dot{m}_\mathrm{in}\cdot\left(h_\mathrm{out}-'
+            r'h_\mathrm{in}\right)+kA \cdot \Delta T_\mathrm{log}\\' + '\n'
+            r'\Delta T_\mathrm{log} = &\begin{cases}' + '\n'
+            r'\frac{T_\mathrm{in}-T_\mathrm{out}}{\ln{\frac{T_\mathrm{in}-'
+            r'T_\mathrm{amb}}{T_\mathrm{out}-T_\mathrm{amb}}}} &'
+            r' T_\mathrm{in} > T_\mathrm{out} \\' + '\n'
+            r'\frac{T_\mathrm{out}-T_\mathrm{in}}{\ln{\frac{'
+            r'T_\mathrm{out}-T_\mathrm{amb}}{T_\mathrm{in}-'
+            r'T_\mathrm{amb}}}} & T_\mathrm{in} < T_\mathrm{out}\\' + '\n'
+            r'0 & T_\mathrm{in} = T_\mathrm{out}' + '\n'
+            r'\end{cases}\\' + '\n'
+            r'T_\mathrm{amb} =& \text{ambient temperature}' + '\n'
+            r'\end{split}'
+        )
+        return generate_latex_eq(self, latex, label)
+
+    def kA_group_deriv(self, increment_filter, k):
+        r"""
+        Calculate partial derivatives of kA group.
+
+        Parameters
+        ----------
+        increment_filter : ndarray
+            Matrix for filtering non-changing variables.
+
+        k : int
+            Position of derivatives in Jacobian matrix (k-th equation).
+        """
+        f = self.kA_group_func
+        self.jacobian[k, 0, 0] = (
+            self.outl[0].h.val_SI - self.inl[0].h.val_SI)
+        if not increment_filter[0, 1]:
+            self.jacobian[k, 0, 1] = self.numeric_deriv(f, 'p', 0)
+        if not increment_filter[0, 2]:
+            self.jacobian[k, 0, 2] = self.numeric_deriv(f, 'h', 0)
+        if not increment_filter[1, 1]:
+            self.jacobian[k, 1, 1] = self.numeric_deriv(f, 'p', 1)
+        if not increment_filter[1, 2]:
+            self.jacobian[k, 1, 2] = self.numeric_deriv(f, 'h', 1)
+        if self.kA.is_var:
+            self.jacobian[k, 2 + self.kA.var_pos, 0] = (
+                self.numeric_deriv(f, self.vars[self.kA], 2))
+
+    def kA_char_group_func(self):
+        r"""
+        Calculate heat transfer from heat transfer coefficient characteristic.
+
+        Returns
+        -------
+        residual : float
+            Residual value of equation.
+
+            .. math::
+
+                0 = \dot{m}_{in} \cdot \left( h_{out} - h_{in}\right) +
+                kA_{design} \cdot f_{kA} \cdot \Delta T_{log}
+
+                \Delta T_{log} = \begin{cases}
+                \frac{T_{in}-T_{out}}{\ln{\frac{T_{in}-T_{amb}}
+                {T_{out}-T_{amb}}}} & T_{in} > T_{out} \\
+                \frac{T_{out}-T_{in}}{\ln{\frac{T_{out}-T_{amb}}
+                {T_{in}-T_{amb}}}} & T_{in} < T_{out}\\
+                0 & T_{in} = T_{out}
+                \end{cases}
+
+                f_{kA} = \frac{2}{1 + \frac{1}{f\left( expr\right)}}
+
+                T_{amb}: \text{ambient temperature}
+
+        Note
+        ----
+        For standard function of f\ :subscript:`kA` \ see module
+        :py:mod:`tespy.data`.
+        """
+        p = self.kA_char.param
+        expr = self.get_char_expr(p, **self.kA_char.char_params)
+        i, o = self.inl[0].get_flow(), self.outl[0].get_flow()
+
+        # For numerical stability: If temperature differences have
+        # different sign use mean difference to avoid negative logarithm.
+
+        ttd_1 = T_mix_ph(i, T0=self.inl[0].T.val_SI) - self.Tamb.val_SI
+        ttd_2 = T_mix_ph(o, T0=self.outl[0].T.val_SI) - self.Tamb.val_SI
+
+        if (ttd_1 / ttd_2) < 0:
+            td_log = (ttd_2 + ttd_1) / 2
+        elif ttd_1 > ttd_2:
+            td_log = (ttd_1 - ttd_2) / np.log(ttd_1 / ttd_2)
+        elif ttd_1 < ttd_2:
+            td_log = (ttd_2 - ttd_1) / np.log(ttd_2 / ttd_1)
+        else:
+            # both values are equal
+            td_log = ttd_2
+
+        fkA = 2 / (1 + 1 / self.kA_char.char_func.evaluate(expr))
+
+        return i[0] * (o[2] - i[2]) + self.kA.design * fkA * td_log
+
+    def kA_char_group_func_doc(self, label):
+        r"""
+        Calculate heat transfer from heat transfer coefficient characteristic.
+
+        Parameters
+        ----------
+        label : str
+            Label for equation.
+
+        Returns
+        -------
+        latex : str
+            LaTeX code of equations applied.
+        """
+        latex = (
+            r'\begin{split}' + '\n'
+            r'0=&\dot{m}_\mathrm{in}\cdot\left(h_\mathrm{out}-'
+            r'h_\mathrm{in}\right)+kA_\mathrm{design} \cdot f_\mathrm{kA}'
+            r' \cdot \Delta T_\mathrm{log}\\' + '\n'
+            r'\Delta T_\mathrm{log} = &\begin{cases}' + '\n'
+            r'\frac{T_\mathrm{in}-T_\mathrm{out}}{\ln{\frac{T_\mathrm{in}-'
+            r'T_\mathrm{amb}}{T_\mathrm{out}-T_\mathrm{amb}}}} &'
+            r' T_\mathrm{in} > T_\mathrm{out} \\' + '\n'
+            r'\frac{T_\mathrm{out}-T_\mathrm{in}}{\ln{\frac{'
+            r'T_\mathrm{out}-T_\mathrm{amb}}{T_\mathrm{in}-'
+            r'T_\mathrm{amb}}}} & T_\mathrm{in} < T_\mathrm{out}\\' + '\n'
+            r'0 & T_\mathrm{in} = T_\mathrm{out}' + '\n'
+            r'\end{cases}\\' + '\n'
+            r'f_{kA}=&\frac{2}{1 + \frac{1}{f\left(X\right)}}\\' + '\n'
+            r'T_\mathrm{amb} =& \text{ambient temperature}' + '\n'
+            r'\end{split}'
+        )
+        return generate_latex_eq(self, latex, label)
+
+    def kA_char_group_deriv(self, increment_filter, k):
+        r"""
+        Calculate partial derivatives of kA characteristics.
+
+        Parameters
+        ----------
+        increment_filter : ndarray
+            Matrix for filtering non-changing variables.
+
+        k : int
+            Position of derivatives in Jacobian matrix (k-th equation).
+        """
+        f = self.kA_char_group_func
+        if not increment_filter[0, 0]:
+            self.jacobian[k, 0, 0] = self.numeric_deriv(f, 'm', 0)
+        if not increment_filter[0, 1]:
+            self.jacobian[k, 0, 1] = self.numeric_deriv(f, 'p', 0)
+        if not increment_filter[0, 2]:
+            self.jacobian[k, 0, 2] = self.numeric_deriv(f, 'h', 0)
+        if not increment_filter[1, 1]:
+            self.jacobian[k, 1, 1] = self.numeric_deriv(f, 'p', 1)
+        if not increment_filter[1, 2]:
+            self.jacobian[k, 1, 2] = self.numeric_deriv(f, 'h', 1)
+
+    def bus_func(self, bus):
+        r"""
+        Calculate the value of the bus function.
+
+        Parameters
+        ----------
+        bus : tespy.connections.bus.Bus
+            TESPy bus object.
+
+        Returns
+        -------
+        val : float
+            Value of energy transfer :math:`\dot{E}`. This value is passed to
+            :py:meth:`tespy.components.component.Component.calc_bus_value`
+            for value manipulation according to the specified characteristic
+            line of the bus.
+
+            .. math::
+
+                \dot{E} = \dot{m}_{in} \cdot \left( h_{out} - h_{in} \right)
+        """
+        return self.inl[0].m.val_SI * (
+            self.outl[0].h.val_SI - self.inl[0].h.val_SI)
+
+    def bus_func_doc(self, bus):
+        r"""
+        Return LaTeX string of the bus function.
+
+        Parameters
+        ----------
+        bus : tespy.connections.bus.Bus
+            TESPy bus object.
+
+        Returns
+        -------
+        latex : str
+            LaTeX string of bus function.
+        """
+        return (
+            r'\dot{m}_\mathrm{in} \cdot \left(h_\mathrm{out} - '
+            r'h_\mathrm{in} \right)')
+
+    def bus_deriv(self, bus):
+        r"""
+        Calculate partial derivatives of the bus function.
+
+        Parameters
+        ----------
+        bus : tespy.connections.bus.Bus
+            TESPy bus object.
+
+        Returns
+        -------
+        deriv : ndarray
+            Matrix of partial derivatives.
+        """
+        deriv = np.zeros((1, 2, self.num_nw_vars))
+        f = self.calc_bus_value
+        deriv[0, 0, 0] = self.numeric_deriv(f, 'm', 0, bus=bus)
+        deriv[0, 0, 2] = self.numeric_deriv(f, 'h', 0, bus=bus)
+        deriv[0, 1, 2] = self.numeric_deriv(f, 'h', 1, bus=bus)
+        return deriv
+
+    def initialise_source(self, c, key):
+        r"""
+        Return a starting value for pressure and enthalpy the outlets.
+
+        Parameters
+        ----------
+        c : tespy.connections.connection.Connection
+            Connection to perform initialisation on.
+
+        key : str
+            Fluid property to retrieve.
+
+        Returns
+        -------
+        val : float
+            Starting value for pressure/enthalpy in SI units.
+
+            .. math::
+
+                val = \begin{cases}
+                \begin{cases}
+                1 \cdot 10^5 \; \frac{\text{J}}{\text{kg}} & \dot{Q} < 0\\
+                3 \cdot 10^5 \; \frac{\text{J}}{\text{kg}} & \dot{Q} = 0\\
+                5 \cdot 10^5 \; \frac{\text{J}}{\text{kg}} & \dot{Q} > 0
+                \end{cases} & \text{key = 'h'}\\
+                \; \; \; \; 10^5 \text{Pa} & \text{key = 'p'}
+                \end{cases}
+
+        """
+        if key == 'p':
+            return 1e5
+        elif key == 'h':
+            if self.Q.val < 0 and self.Q.is_set:
+                return 1e5
+            elif self.Q.val > 0 and self.Q.is_set:
+                return 5e5
+            else:
+                return 3e5
+
+    def initialise_target(self, c, key):
+        r"""
+        Return a starting value for pressure and enthalpy the inlets.
+
+        Parameters
+        ----------
+        c : tespy.connections.connection.Connection
+            Connection to perform initialisation on.
+
+        key : str
+            Fluid property to retrieve.
+
+        Returns
+        -------
+        val : float
+            Starting value for pressure/enthalpy in SI units.
+
+            .. math::
+
+                val = \begin{cases}
+                1 \cdot 10^5 & \text{key = 'p'}\\
+                \begin{cases}
+                5 \cdot 10^5 & \dot{Q} < 0\\
+                3 \cdot 10^5 & \dot{Q} = 0\\
+                1 \cdot 10^5 & \dot{Q} > 0
+                \end{cases} & \text{key = 'h'}\\
+                \end{cases}
+        """
+        if key == 'p':
+            return 1e5
+        elif key == 'h':
+            if self.Q.val < 0 and self.Q.is_set:
+                return 5e5
+            elif self.Q.val > 0 and self.Q.is_set:
+                return 1e5
+            else:
+                return 3e5
+
+    def calc_parameters(self):
+        r"""Postprocessing parameter calculation."""
+        i = self.inl[0].get_flow()
+        o = self.outl[0].get_flow()
+
+        self.Q.val = i[0] * (o[2] - i[2])
+        self.pr.val = o[1] / i[1]
+        self.zeta.val = ((i[1] - o[1]) * np.pi ** 2 / (
+            4 * i[0] ** 2 * (self.inl[0].vol.val_SI + self.outl[0].vol.val_SI)
+            ))
+
+        if self.Tamb.is_set:
+            ttd_1 = self.inl[0].T.val_SI - self.Tamb.val_SI
+            ttd_2 = self.outl[0].T.val_SI - self.Tamb.val_SI
+
+            if (ttd_1 / ttd_2) < 0:
+                td_log = np.nan
+            if ttd_1 > ttd_2:
+                td_log = (ttd_1 - ttd_2) / np.log(ttd_1 / ttd_2)
+            elif ttd_1 < ttd_2:
+                td_log = (ttd_2 - ttd_1) / np.log(ttd_2 / ttd_1)
+            else:
+                # both values are equal
+                td_log = ttd_1
+
+            self.kA.val = abs(i[0] * (o[2] - i[2]) / td_log)
+            self.kA.is_result = True
+        else:
+            self.kA.is_result = False
+
+    def entropy_balance(self):
+        r"""
+        Calculate entropy balance of a simple heat exchanger.
+
+        The allocation of the entropy streams due to heat exchanged and due to
+        irreversibility is performed by solving for T:
+
+        .. math::
+
+            h_\mathrm{out} - h_\mathrm{in} = \int_\mathrm{out}^\mathrm{in}
+            v \cdot dp - \int_\mathrm{out}^\mathrm{in} T \cdot ds
+
+        As solving :math:`\int_\mathrm{out}^\mathrm{in} v \cdot dp` for non
+        isobaric processes would require perfect process knowledge (the path)
+        on how specific volume and pressure change throught the component, the
+        heat transfer is splitted into three separate virtual processes:
+
+        - in->in*: decrease pressure to
+          :math:`p_\mathrm{in*}=p_\mathrm{in}\cdot\sqrt{\frac{p_\mathrm{out}}{p_\mathrm{in}}}`
+          without changing enthalpy.
+        - in*->out* transfer heat without changing pressure.
+          :math:`h_\mathrm{out*}-h_\mathrm{in*}=h_\mathrm{out}-h_\mathrm{in}`
+        - out*->out decrease pressure to outlet pressure :math:`p_\mathrm{out}`
+          without changing enthalpy.
+
+        Note
+        ----
+        The entropy balance makes the follwing parameter available:
+
+        .. math::
+
+            \text{S\_Q}=\dot{m} \cdot \left(s_\mathrm{out*}-s_\mathrm{in*}
+            \right)\\
+            \text{S\_irr}=\dot{m} \cdot \left(s_\mathrm{out}-s_\mathrm{in}
+            \right) - \text{S\_Q}\\
+            \text{T\_mQ}=\frac{\dot{Q}}{\text{S\_Q}}
+        """
+        i = self.inl[0].get_flow()
+        o = self.outl[0].get_flow()
+
+        p1_star = i[1] * (o[1] / i[1]) ** 0.5
+        s1_star = s_mix_ph([0, p1_star, i[2], i[3]], T0=self.inl[0].T.val_SI)
+        s2_star = s_mix_ph([0, p1_star, o[2], o[3]], T0=self.outl[0].T.val_SI)
+        self.S_Q = i[0] * (s2_star - s1_star)
+        self.S_irr = i[0] * (
+            self.outl[0].s.val_SI - self.inl[0].s.val_SI) - self.S_Q
+        self.T_mQ = (o[2] - i[2]) / (s2_star - s1_star)
+
+    def exergy_balance(self, T0):
+        r"""
+        Calculate exergy balance of a simple heat exchanger.
+
+        The exergy of heat is calculated by allocation of thermal and
+        mechanical share of exergy in the physical exergy. Depending on the
+        temperature levels at the inlet and outlet of the heat exchanger as
+        well as the direction of heat transfer (input or output) fuel and
+        product exergy are calculated as follows.
+
+        Parameters
+        ----------
+        T0 : float
+            Ambient temperature T0 / K.
+
+        Note
+        ----
+        If the fluid transfers heat to the ambient, you can specify
+        :code:`mysimpleheatexchanger.set_attr(dissipative=False)` if you do
+        NOT want the exergy production nan (only applicable in case
+        :math:`\dot{Q}<0`).
+
+        .. math ::
+
+            \dot{E}_\mathrm{P} =
+            \begin{cases}
+            \begin{cases}
+            \begin{cases}
+            \text{not defined (nan)} & \text{if dissipative}\\
+            \dot{E}_\mathrm{in}^\mathrm{T} - \dot{E}_\mathrm{out}^\mathrm{T} &
+            \text{else}\\
+            \end{cases}
+            & T_\mathrm{in}, T_\mathrm{out} \geq T_0\\
+            \dot{E}_\mathrm{out}^\mathrm{T}
+            & T_\mathrm{in} \geq T_0 > T_\mathrm{out}\\
+            \dot{E}_\mathrm{out}^\mathrm{T} - \dot{E}_\mathrm{in}^\mathrm{T}
+            & T_0 \geq T_\mathrm{in}, T_\mathrm{out}\\
+            \end{cases} & \dot{Q} < 0\\
+
+            \begin{cases}
+            \dot{E}_\mathrm{out}^\mathrm{PH} - \dot{E}_\mathrm{in}^\mathrm{PH}
+            & T_\mathrm{in}, T_\mathrm{out} \geq T_0\\
+            \dot{E}_\mathrm{in}^\mathrm{T} + \dot{E}_\mathrm{out}^\mathrm{T}
+            & T_\mathrm{out} > T_0 \geq T_\mathrm{in}\\
+            \dot{E}_\mathrm{in}^\mathrm{T} - \dot{E}_\mathrm{out}^\mathrm{T} +
+            \dot{E}_\mathrm{out}^\mathrm{M} - \dot{E}_\mathrm{in}^\mathrm{M} +
+            & T_0 \geq T_\mathrm{in}, T_\mathrm{out}\\
+            \end{cases} & \dot{Q} > 0\\
+            \end{cases}
+
+            \dot{E}_\mathrm{F} =
+            \begin{cases}
+            \begin{cases}
+            \dot{E}_\mathrm{in}^\mathrm{PH} - \dot{E}_\mathrm{out}^\mathrm{PH}
+            & T_\mathrm{in}, T_\mathrm{out} \geq T_0\\
+            \dot{E}_\mathrm{in}^\mathrm{T} + \dot{E}_\mathrm{in}^\mathrm{M} +
+            \dot{E}_\mathrm{out}^\mathrm{T} - \dot{E}_\mathrm{out}^\mathrm{M}
+            & T_\mathrm{in} \geq T_0 > T_\mathrm{out}\\
+            \dot{E}_\mathrm{out}^\mathrm{T} - \dot{E}_\mathrm{in}^\mathrm{T} +
+            \dot{E}_\mathrm{in}^\mathrm{M} - \dot{E}_\mathrm{out}^\mathrm{M} +
+            & T_0 \geq T_\mathrm{in}, T_\mathrm{out}\\
+            \end{cases} & \dot{Q} < 0\\
+
+            \begin{cases}
+            \dot{E}_\mathrm{out}^\mathrm{T} - \dot{E}_\mathrm{in}^\mathrm{T}
+            & T_\mathrm{in}, T_\mathrm{out} \geq T_0\\
+            \dot{E}_\mathrm{in}^\mathrm{T} + \dot{E}_\mathrm{in}^\mathrm{M} -
+            \dot{E}_\mathrm{out}^\mathrm{M}
+            & T_\mathrm{out} > T_0 \geq T_\mathrm{in}\\
+            \dot{E}_\mathrm{in}^\mathrm{T}-\dot{E}_\mathrm{out}^\mathrm{T}
+            & T_0 \geq T_\mathrm{in}, T_\mathrm{out}\\
+            \end{cases} & \dot{Q} > 0\\
+            \end{cases}
+
+            \dot{E}_\mathrm{bus} =
+            \begin{cases}
+            \begin{cases}
+            \dot{E}_\mathrm{P} & \text{other cases}\\
+            \dot{E}_\mathrm{in}^\mathrm{T}
+            & T_\mathrm{in} \geq T_0 > T_\mathrm{out}\\
+            \end{cases} & \dot{Q} < 0\\
+            \dot{E}_\mathrm{F} & \dot{Q} > 0\\
+            \end{cases}
+        """
+        if self.Q.val < 0:
+            if self.inl[0].T.val_SI >= T0 and self.outl[0].T.val_SI >= T0:
+                if self.dissipative.val:
+                    self.E_P = np.nan
+                else:
+                    self.E_P = self.inl[0].Ex_therm - self.outl[0].Ex_therm
+                self.E_F = self.inl[0].Ex_physical - self.outl[0].Ex_physical
+                self.E_bus = {
+                    "chemical": 0, "physical": 0, "massless": self.E_P
+                }
+            elif self.inl[0].T.val_SI >= T0 and self.outl[0].T.val_SI < T0:
+                self.E_P = self.outl[0].Ex_therm
+                self.E_F = self.inl[0].Ex_therm + self.outl[0].Ex_therm + (
+                    self.inl[0].Ex_mech - self.outl[0].Ex_mech)
+                self.E_bus = {
+                    "chemical": 0, "physical": 0,
+                    "massless": self.inl[0].Ex_therm + self.outl[0].Ex_therm
+                }
+            elif self.inl[0].T.val_SI <= T0 and self.outl[0].T.val_SI <= T0:
+                self.E_P = self.outl[0].Ex_therm - self.inl[0].Ex_therm
+                self.E_F = self.outl[0].Ex_therm - self.outl[0].Ex_therm + (
+                    self.inl[0].Ex_mech - self.outl[0].Ex_mech)
+                self.E_bus = {
+                    "chemical": 0, "physical": 0, "massless": self.E_P
+                }
+            else:
+                msg = ('Exergy balance of simple heat exchangers, where '
+                       'outlet temperature is higher than inlet temperature '
+                       'with heat extracted is not implmented.')
+                logger.warning(msg)
+                self.E_P = np.nan
+                self.E_F = np.nan
+                self.E_bus = {
+                    "chemical": np.nan, "physical": np.nan, "massless": np.nan
+                }
+        elif self.Q.val > 0:
+            if self.inl[0].T.val_SI >= T0 and self.outl[0].T.val_SI >= T0:
+                self.E_P = self.outl[0].Ex_physical - self.inl[0].Ex_physical
+                self.E_F = self.outl[0].Ex_therm - self.inl[0].Ex_therm
+                self.E_bus = {
+                    "chemical": 0, "physical": 0, "massless": self.E_F
+                }
+            elif self.inl[0].T.val_SI <= T0 and self.outl[0].T.val_SI > T0:
+                self.E_P = self.outl[0].Ex_therm + self.inl[0].Ex_therm
+                self.E_F = self.inl[0].Ex_therm + (
+                    self.inl[0].Ex_mech - self.outl[0].Ex_mech)
+                self.E_bus = {
+                    "chemical": 0, "physical": 0,
+                    "massless": self.inl[0].Ex_therm
+                }
+            elif self.inl[0].T.val_SI < T0 and self.outl[0].T.val_SI < T0:
+                if self.dissipative.val:
+                    self.E_P = np.nan
+                else:
+                    self.E_P = self.inl[0].Ex_therm - self.outl[0].Ex_therm + (
+                        self.outl[0].Ex_mech - self.inl[0].Ex_mech
+                    )
+                self.E_F = self.inl[0].Ex_therm - self.outl[0].Ex_therm
+                self.E_bus = {
+                    "chemical": 0, "physical": 0, "massless": self.E_F
+                }
+            else:
+                msg = ('Exergy balance of simple heat exchangers, where '
+                       'inlet temperature is higher than outlet temperature '
+                       'with heat injected is not implmented.')
+                logger.warning(msg)
+                self.E_P = np.nan
+                self.E_F = np.nan
+                self.E_bus = {
+                    "chemical": np.nan, "physical": np.nan, "massless": self.E_F
+                }
+        else:
+            # fully dissipative
+            self.E_P = np.nan
+            self.E_F = self.inl[0].Ex_physical - self.outl[0].Ex_physical
+            self.E_bus = {
+                "chemical": np.nan, "physical": np.nan, "massless": np.nan
+            }
+
+        if np.isnan(self.E_P):
+            self.E_D = self.E_F
+        else:
+            self.E_D = self.E_F - self.E_P
+        self.epsilon = self.E_P / self.E_F
+
+    def get_plotting_data(self):
+        """Generate a dictionary containing FluProDia plotting information.
+
+        Returns
+        -------
+        data : dict
+            A nested dictionary containing the keywords required by the
+            :code:`calc_individual_isoline` method of the
+            :code:`FluidPropertyDiagram` class. First level keys are the
+            connection index ('in1' -> 'out1', therefore :code:`1` etc.).
+        """
+        return {
+            1: {
+                'isoline_property': 'p',
+                'isoline_value': self.inl[0].p.val,
+                'isoline_value_end': self.outl[0].p.val,
+                'starting_point_property': 's',
+                'starting_point_value': self.inl[0].s.val,
+                'ending_point_property': 's',
+                'ending_point_value': self.outl[0].s.val
+            }
+        }
+
+
+class HeatExchangerSimple(SimpleHeatExchanger):
+
+    def __init__(self, label, **kwargs):
+        super().__init__(label, **kwargs)
+        msg = (
+            "The API for the component HeatExchangerSimple will change with "
+            "the next major release, please import SimpleHeatExchanger instead."
+        )
+        warnings.warn(msg, FutureWarning)
```

#### encoding

```diff
@@ -1 +1 @@
-us-ascii
+utf-8
```

### Comparing `TESPy-0.6.2/src/tespy/components/customs/orc_evaporator.py` & `TESPy-0.6.3/src/tespy/components/customs/orc_evaporator.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,20 +4,21 @@
 
 This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
 by the contributors recorded in the version control history of the file,
 available from its original location tespy/components/customs/orc_evaporator.py
 
 SPDX-License-Identifier: MIT
 """
+import warnings
 
 import numpy as np
 
 from tespy.components.component import Component
 from tespy.tools.data_containers import ComponentProperties as dc_cp
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
+from tespy.tools.data_containers import SimpleDataContainer as dc_simple
 from tespy.tools.document_models import generate_latex_eq
 from tespy.tools.fluid_properties import dh_mix_dpQ
 from tespy.tools.fluid_properties import h_mix_pQ
 from tespy.tools.fluid_properties import h_mix_pT
 from tespy.tools.fluid_properties import s_mix_ph
 
 
@@ -194,14 +195,19 @@
 
     >>> eva_wf_out.x.val
     1.0
     >>> eva_sink_s.x.val
     0.0
     """
 
+    def __init__(self, label, **kwargs):
+        super().__init__(label, **kwargs)
+        msg = "The component ORCEvaporator will be depricated with the next major release."
+        warnings.warn(msg, DeprecationWarning)
+
     @staticmethod
     def component():
         return 'orc evaporator'
 
     def get_variables(self):
         return {
             'Q': dc_cp(
@@ -261,19 +267,19 @@
     def inlets():
         return ['in1', 'in2', 'in3']
 
     @staticmethod
     def outlets():
         return ['out1', 'out2', 'out3']
 
-    def comp_init(self, nw):
+    def preprocess(self, nw):
 
         self.overheating.is_set = not self.overheating.val
         self.subcooling.is_set = not self.subcooling.val
-        Component.comp_init(self, nw)
+        super().preprocess(nw)
 
     def energy_balance_func(self):
         r"""
         Equation for heat exchanger energy balance.
 
         Returns
         -------
```

### Comparing `TESPy-0.6.2/src/tespy/components/heat_exchangers/base.py` & `TESPy-0.6.3/src/tespy/components/heat_exchangers/base.py`

 * *Files 1% similar despite different names*

```diff
@@ -372,30 +372,15 @@
         k : int
             Position of derivatives in Jacobian matrix (k-th equation).
         """
         self.jacobian[k, 0, 0] = self.outl[0].h.val_SI - self.inl[0].h.val_SI
         self.jacobian[k, 0, 2] = -self.inl[0].m.val_SI
         self.jacobian[k, 2, 2] = self.inl[0].m.val_SI
 
-    def kA_func(self):
-        r"""
-        Calculate heat transfer from heat transfer coefficient.
-
-        Returns
-        -------
-        residual : float
-            Residual value of equation.
-
-            .. math::
-
-                0 = \dot{m}_{in,1} \cdot \left( h_{out,1} - h_{in,1}\right) +
-                kA \cdot \frac{T_{out,1} -
-                T_{in,2} - T_{in,1} + T_{out,2}}
-                {\ln{\frac{T_{out,1} - T_{in,2}}{T_{in,1} - T_{out,2}}}}
-        """
+    def calculate_td_log(self):
         i1 = self.inl[0]
         i2 = self.inl[1]
         o1 = self.outl[0]
         o2 = self.outl[1]
 
         # temperature value manipulation for convergence stability
         T_i1 = T_mix_ph(i1.get_flow(), T0=i1.T.val_SI)
@@ -408,19 +393,46 @@
         if T_i1 <= T_o2:
             T_o2 = T_i1 - 0.01
         if T_i1 <= T_o2:
             T_o1 = T_i2 + 0.02
         if T_o1 <= T_i2:
             T_i2 = T_o1 - 0.02
 
-        td_log = ((T_o1 - T_i2 - T_i1 + T_o2) /
-                  np.log((T_o1 - T_i2) / (T_i1 - T_o2)))
+        ttd_u = T_i1 - T_o2
+        ttd_l = T_o1 - T_i2
 
-        return i1.m.val_SI * (
-            o1.h.val_SI - i1.h.val_SI) + self.kA.val * td_log
+        if ttd_u == ttd_l:
+            td_log = ttd_l
+        else:
+            td_log = (ttd_l - ttd_u) / np.log((ttd_l) / (ttd_u))
+
+        return td_log
+
+    def kA_func(self):
+        r"""
+        Calculate heat transfer from heat transfer coefficient.
+
+        Returns
+        -------
+        residual : float
+            Residual value of equation.
+
+            .. math::
+
+                0 = \dot{m}_{in,1} \cdot \left( h_{out,1} - h_{in,1}\right) +
+                kA \cdot \frac{T_{out,1} -
+                T_{in,2} - T_{in,1} + T_{out,2}}
+                {\ln{\frac{T_{out,1} - T_{in,2}}{T_{in,1} - T_{out,2}}}}
+        """
+
+        return (
+            self.inl[0].m.val_SI * (
+                self.outl[0].h.val_SI - self.inl[0].h.val_SI
+            ) + self.kA.val * self.calculate_td_log()
+        )
 
     def kA_func_doc(self, label):
         r"""
         Calculate heat transfer from heat transfer coefficient.
 
         Parameters
         ----------
@@ -486,44 +498,25 @@
         module :py:mod:`tespy.data`.
         """
         p1 = self.kA_char1.param
         p2 = self.kA_char2.param
         f1 = self.get_char_expr(p1, **self.kA_char1.char_params)
         f2 = self.get_char_expr(p2, **self.kA_char2.char_params)
 
-        i1 = self.inl[0]
-        i2 = self.inl[1]
-        o1 = self.outl[0]
-        o2 = self.outl[1]
-
-        # temperature value manipulation for convergence stability
-        T_i1 = T_mix_ph(i1.get_flow(), T0=i1.T.val_SI)
-        T_i2 = T_mix_ph(i2.get_flow(), T0=i2.T.val_SI)
-        T_o1 = T_mix_ph(o1.get_flow(), T0=o1.T.val_SI)
-        T_o2 = T_mix_ph(o2.get_flow(), T0=o2.T.val_SI)
-
-        if T_i1 <= T_o2:
-            T_i1 = T_o2 + 0.01
-        if T_i1 <= T_o2:
-            T_o2 = T_i1 - 0.01
-        if T_i1 <= T_o2:
-            T_o1 = T_i2 + 0.02
-        if T_o1 <= T_i2:
-            T_i2 = T_o1 - 0.02
-
-        td_log = ((T_o1 - T_i2 - T_i1 + T_o2) /
-                  np.log((T_o1 - T_i2) / (T_i1 - T_o2)))
-
         fkA1 = self.kA_char1.char_func.evaluate(f1)
         fkA2 = self.kA_char2.char_func.evaluate(f2)
         fkA = 2 / (1 / fkA1 + 1 / fkA2)
 
+        td_log = self.calculate_td_log()
+
         return (
-            i1.m.val_SI * (o1.h.val_SI - i1.h.val_SI) +
-            self.kA.design * fkA * td_log)
+            self.inl[0].m.val_SI * (
+                self.outl[0].h.val_SI - self.inl[0].h.val_SI
+            ) + self.kA.design * fkA * td_log
+        )
 
     def kA_char_func_doc(self, label):
         r"""
         Calculate heat transfer from heat transfer coefficient characteristic.
 
         Parameters
         ----------
@@ -830,19 +823,20 @@
                     4 * self.inl[i].m.val_SI ** 2 *
                     (self.inl[i].vol.val_SI + self.outl[i].vol.val_SI)
                 ))
 
         # kA and logarithmic temperature difference
         if self.ttd_u.val < 0 or self.ttd_l.val < 0:
             self.td_log.val = np.nan
-            self.kA.val = np.nan
+        elif self.ttd_l.val == self.ttd_u.val:
+            self.td_log.val = self.ttd_l.val
         else:
             self.td_log.val = ((self.ttd_l.val - self.ttd_u.val) /
                                np.log(self.ttd_l.val / self.ttd_u.val))
-            self.kA.val = -self.Q.val / self.td_log.val
+        self.kA.val = -self.Q.val / self.td_log.val
 
     def entropy_balance(self):
         r"""
         Calculate entropy balance of a heat exchanger.
 
         The allocation of the entropy streams due to heat exchanged and due to
         irreversibility is performed by solving for T on both sides of the heat
@@ -1011,15 +1005,15 @@
             self.E_F = self.inl[0].Ex_physical - self.outl[0].Ex_physical + (
                 self.inl[1].Ex_physical - self.outl[1].Ex_physical)
         else:
             self.E_P = self.outl[1].Ex_therm
             self.E_F = self.inl[0].Ex_physical - self.outl[0].Ex_physical + (
                 self.inl[1].Ex_physical - self.outl[1].Ex_mech)
 
-        self.E_bus = np.nan
+        self.E_bus = {"chemical": np.nan, "physical": np.nan, "massless": np.nan}
         if np.isnan(self.E_P):
             self.E_D = self.E_F
         else:
             self.E_D = self.E_F - self.E_P
         self.epsilon = self.E_P / self.E_F
 
     def get_plotting_data(self):
```

### Comparing `TESPy-0.6.2/src/tespy/components/heat_exchangers/condenser.py` & `TESPy-0.6.3/src/tespy/components/heat_exchangers/condenser.py`

 * *Files 5% similar despite different names*

```diff
@@ -9,20 +9,19 @@
 tespy/components/heat_exchangers/condenser.py
 
 SPDX-License-Identifier: MIT
 """
 
 import numpy as np
 
-from tespy.components.component import Component
 from tespy.components.heat_exchangers.base import HeatExchanger
 from tespy.tools.data_containers import ComponentCharacteristics as dc_cc
 from tespy.tools.data_containers import ComponentProperties as dc_cp
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
 from tespy.tools.data_containers import GroupedComponentCharacteristics as dc_gcc
+from tespy.tools.data_containers import SimpleDataContainer as dc_simple
 from tespy.tools.document_models import generate_latex_eq
 from tespy.tools.fluid_properties import T_bp_p
 from tespy.tools.fluid_properties import T_mix_ph
 from tespy.tools.fluid_properties import dh_mix_dpQ
 from tespy.tools.fluid_properties import h_mix_pQ
 
 
@@ -121,15 +120,15 @@
         Upper terminal temperature difference (referring to saturation
         temprature of condensing fluid) :math:`ttd_\mathrm{u}/\text{K}`.
 
     kA : float, dict
         Area independent heat transfer coefficient,
         :math:`kA/\frac{\text{W}}{\text{K}}`.
 
-    kA_char : tespy.tools.data_containers.DataContainerSimple
+    kA_char : tespy.tools.data_containers.SimpleDataContainer
         Area independent heat transfer coefficient characteristic.
 
     kA_char1 : tespy.tools.characteristics.CharLine, dict
         Characteristic line for hot side heat transfer coefficient.
 
     kA_char2 : tespy.tools.characteristics.CharLine, dict
         Characteristic line for cold side heat transfer coefficient.
@@ -257,19 +256,19 @@
                 param='m', char_params={
                     'type': 'rel', 'inconn': 1, 'outconn': 1}),
             'subcooling': dc_simple(
                 val=False, num_eq=1, latex=self.subcooling_func_doc,
                 deriv=self.subcooling_deriv, func=self.subcooling_func)
         }
 
-    def comp_init(self, nw):
+    def preprocess(self, nw):
 
         # if subcooling is True, outlet state method must not be calculated
         self.subcooling.is_set = not self.subcooling.val
-        Component.comp_init(self, nw)
+        super().preprocess(nw)
 
     def subcooling_func(self):
         r"""
         Equation for hot side outlet state.
 
         Returns
         -------
@@ -314,31 +313,16 @@
 
         k : int
             Position of derivatives in Jacobian matrix (k-th equation).
         """
         self.jacobian[k, 2, 1] = -dh_mix_dpQ(self.outl[0].get_flow(), 0)
         self.jacobian[k, 2, 2] = 1
 
-    def kA_func(self):
-        r"""
-        Calculate heat transfer from heat transfer coefficient.
-
-        Returns
-        -------
-        residual : float
-            Residual value of equation.
-
-            .. math::
+    def calculate_td_log(self):
 
-                0 = \dot{m}_{in,1} \cdot \left( h_{out,1} - h_{in,1}\right) +
-                kA \cdot \frac{T_{out,1} -
-                T_{in,2} - T_{sat} \left(p_{in,1}\right) + T_{out,2}}
-                {\ln{\frac{T_{out,1} - T_{in,2}}
-                {T_{sat} \left(p_{in,1}\right) - T_{out,2}}}}
-        """
         i1 = self.inl[0]
         i2 = self.inl[1]
         o1 = self.outl[0]
         o2 = self.outl[1]
 
         T_i1 = T_bp_p(i1.get_flow())
         T_i2 = T_mix_ph(i2.get_flow(), T0=i2.T.val_SI)
@@ -350,18 +334,22 @@
         if T_i1 <= T_o2 and not o2.T.val_set:
             T_o2 = T_i1 - 0.5
         if T_o1 <= T_i2 and not o1.T.val_set:
             T_o1 = T_i2 + 1
         if T_o1 <= T_i2 and not i2.T.val_set:
             T_i2 = T_o1 - 1
 
-        td_log = ((T_o1 - T_i2 - T_i1 + T_o2) /
-                  np.log((T_o1 - T_i2) / (T_i1 - T_o2)))
+        ttd_u = T_i1 - T_o2
+        ttd_l = T_o1 - T_i2
+        if ttd_u == ttd_l:
+            td_log = ttd_l
+        else:
+            td_log = (ttd_l - ttd_u) / np.log((ttd_l) / (ttd_u))
 
-        return i1.m.val_SI * (o1.h.val_SI - i1.h.val_SI) + self.kA.val * td_log
+        return td_log
 
     def kA_func_doc(self, label):
         r"""
         Calculate heat transfer from heat transfer coefficient.
 
         Parameters
         ----------
@@ -405,49 +393,15 @@
                 \frac{1}{f_2 \left( expr_2\right)}}
 
         Note
         ----
         For standard functions f\ :subscript:`1` \ and f\ :subscript:`2` \ see
         module :py:mod:`tespy.data`.
         """
-        p1 = self.kA_char1.param
-        p2 = self.kA_char2.param
-        f1 = self.get_char_expr(p1, **self.kA_char1.char_params)
-        f2 = self.get_char_expr(p2, **self.kA_char2.char_params)
-
-        i1 = self.inl[0]
-        i2 = self.inl[1]
-        o1 = self.outl[0]
-        o2 = self.outl[1]
-
-        # temperature value manipulation for convergence stability
-        T_i1 = T_bp_p(i1.get_flow())
-        T_i2 = T_mix_ph(i2.get_flow(), T0=i2.T.val_SI)
-        T_o1 = T_mix_ph(o1.get_flow(), T0=o1.T.val_SI)
-        T_o2 = T_mix_ph(o2.get_flow(), T0=o2.T.val_SI)
-
-        if T_i1 <= T_o2 and not i1.T.val_set:
-            T_i1 = T_o2 + 0.5
-        if T_i1 <= T_o2 and not o2.T.val_set:
-            T_o2 = T_i1 - 0.5
-        if T_o1 <= T_i2 and not o1.T.val_set:
-            T_o1 = T_i2 + 1
-        if T_o1 <= T_i2 and not i2.T.val_set:
-            T_i2 = T_o1 - 1
-
-        td_log = ((T_o1 - T_i2 - T_i1 + T_o2) /
-                  np.log((T_o1 - T_i2) / (T_i1 - T_o2)))
-
-        fkA1 = self.kA_char1.char_func.evaluate(f1)
-        fkA2 = self.kA_char2.char_func.evaluate(f2)
-        fkA = 2 / (1 / fkA1 + 1 / fkA2)
-
-        return (
-            i1.m.val_SI * (o1.h.val_SI - i1.h.val_SI) +
-            self.kA.design * fkA * td_log)
+        return super().kA_char_func()
 
     def kA_char_func_doc(self, label):
         r"""
         Calculate heat transfer from heat transfer coefficient characteristic.
 
         Parameters
         ----------
@@ -533,12 +487,13 @@
                     4 * self.inl[i].m.val_SI ** 2 *
                     (self.inl[i].vol.val_SI + self.outl[i].vol.val_SI)
                 ))
 
         # kA and logarithmic temperature difference
         if self.ttd_u.val < 0 or self.ttd_l.val < 0:
             self.td_log.val = np.nan
-            self.kA.val = np.nan
+        elif self.ttd_l.val == self.ttd_u.val:
+            self.td_log.val = self.ttd_l.val
         else:
             self.td_log.val = ((self.ttd_l.val - self.ttd_u.val) /
                                np.log(self.ttd_l.val / self.ttd_u.val))
-            self.kA.val = -self.Q.val / self.td_log.val
+        self.kA.val = -self.Q.val / self.td_log.val
```

### Comparing `TESPy-0.6.2/src/tespy/components/heat_exchangers/desuperheater.py` & `TESPy-0.6.3/src/tespy/components/heat_exchangers/desuperheater.py`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/src/tespy/components/heat_exchangers/parabolic_trough.py` & `TESPy-0.6.3/src/tespy/components/heat_exchangers/parabolic_trough.py`

 * *Files 0% similar despite different names*

```diff
@@ -9,37 +9,37 @@
 tespy/components/heat_exchangers/parabolic_trough.py
 
 SPDX-License-Identifier: MIT
 """
 
 import numpy as np
 
-from tespy.components.heat_exchangers.simple import HeatExchangerSimple
+from tespy.components.heat_exchangers.simple import SimpleHeatExchanger
 from tespy.tools.data_containers import ComponentProperties as dc_cp
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
 from tespy.tools.data_containers import GroupedComponentProperties as dc_gcp
+from tespy.tools.data_containers import SimpleDataContainer as dc_simple
 from tespy.tools.document_models import generate_latex_eq
 from tespy.tools.fluid_properties import T_mix_ph
 
 
-class ParabolicTrough(HeatExchangerSimple):
+class ParabolicTrough(SimpleHeatExchanger):
     r"""
     The ParabolicTrough calculates heat output from irradiance.
 
     **Mandatory Equations**
 
     - :py:meth:`tespy.components.component.Component.fluid_func`
     - :py:meth:`tespy.components.component.Component.mass_flow_func`
 
     **Optional Equations**
 
     - :py:meth:`tespy.components.component.Component.pr_func`
     - :py:meth:`tespy.components.component.Component.zeta_func`
-    - :py:meth:`tespy.components.heat_exchangers.simple.HeatExchangerSimple.energy_balance_func`
-    - :py:meth:`tespy.components.heat_exchangers.simple.HeatExchangerSimple.hydro_group_func`
+    - :py:meth:`tespy.components.heat_exchangers.simple.SimpleHeatExchanger.energy_balance_func`
+    - :py:meth:`tespy.components.heat_exchangers.simple.SimpleHeatExchanger.hydro_group_func`
     - :py:meth:`tespy.components.heat_exchangers.parabolic_trough.ParabolicTrough.energy_group_func`
 
     Inlets/Outlets
 
     - in1
     - out1
```

### Comparing `TESPy-0.6.2/src/tespy/components/heat_exchangers/simple.py` & `TESPy-0.6.3/src/tespy/tools/analyses.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,1095 +1,888 @@
 # -*- coding: utf-8
 
-"""Module of class HeatExchangerSimple.
+"""Module for thermodynamic analyses.
+
+The analyses module provides thermodynamic analysis tools for your simulation.
+Different analysis classes are available:
+
+- :py:class:`tespy.tools.analyses.ExergyAnalysis`
 
 
 This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
 by the contributors recorded in the version control history of the file,
-available from its original location
-tespy/components/heat_exchangers/simple.py
+available from its original location tespy/tools/analyses.py
 
 SPDX-License-Identifier: MIT
 """
-
-import logging
-
 import numpy as np
+import pandas as pd
+from tabulate import tabulate
 
-from tespy.components.component import Component
-from tespy.tools.data_containers import ComponentCharacteristics as dc_cc
-from tespy.tools.data_containers import ComponentProperties as dc_cp
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
-from tespy.tools.data_containers import GroupedComponentProperties as dc_gcp
-from tespy.tools.document_models import generate_latex_eq
-from tespy.tools.fluid_properties import T_mix_ph
-from tespy.tools.fluid_properties import s_mix_ph
-from tespy.tools.fluid_properties import v_mix_ph
-from tespy.tools.fluid_properties import visc_mix_ph
-from tespy.tools.helpers import convert_to_SI
-from tespy.tools.helpers import darcy_friction_factor as dff
-
-
-class HeatExchangerSimple(Component):
-    r"""
-    A basic heat exchanger representing a heat source or heat sink.
-
-    The component HeatExchangerSimple is the parent class for the components:
-
-    - :py:class:`tespy.components.heat_exchangers.solar_collector.SolarCollector`
-    - :py:class:`tespy.components.heat_exchangers.parabolic_trough.ParabolicTrough`
-    - :py:class:`tespy.components.piping.pipe.Pipe`
-
-    **Mandatory Equations**
-
-    - :py:meth:`tespy.components.component.Component.fluid_func`
-    - :py:meth:`tespy.components.component.Component.mass_flow_func`
-
-    **Optional Equations**
-
-    - :py:meth:`tespy.components.component.Component.pr_func`
-    - :py:meth:`tespy.components.component.Component.zeta_func`
-    - :py:meth:`tespy.components.heat_exchangers.simple.HeatExchangerSimple.energy_balance_func`
-    - :py:meth:`tespy.components.heat_exchangers.simple.HeatExchangerSimple.hydro_group_func`
-    - :py:meth:`tespy.components.heat_exchangers.simple.HeatExchangerSimple.kA_group_func`
-    - :py:meth:`tespy.components.heat_exchangers.simple.HeatExchangerSimple.kA_char_group_func`
-
-    Inlets/Outlets
-
-    - in1
-    - out1
-
-    Image
-
-    .. image:: /api/_images/Pipe.svg
-       :alt: flowsheet of the simple heat exchanger
-       :align: center
-       :class: only-light
-
-    .. image:: /api/_images/Pipe_darkmode.svg
-       :alt: flowsheet of the simple heat exchanger
-       :align: center
-       :class: only-dark
-
-    Parameters
-    ----------
-    label : str
-        The label of the component.
-
-    design : list
-        List containing design parameters (stated as String).
-
-    offdesign : list
-        List containing offdesign parameters (stated as String).
-
-    design_path : str
-        Path to the components design case.
-
-    local_offdesign : boolean
-        Treat this component in offdesign mode in a design calculation.
-
-    local_design : boolean
-        Treat this component in design mode in an offdesign calculation.
-
-    char_warnings : boolean
-        Ignore warnings on default characteristics usage for this component.
-
-    printout : boolean
-        Include this component in the network's results printout.
-
-    Q : float, dict, :code:`"var"`
-        Heat transfer, :math:`Q/\text{W}`.
-
-    pr : float, dict, :code:`"var"`
-        Outlet to inlet pressure ratio, :math:`pr/1`.
-
-    zeta : float, dict, :code:`"var"`
-        Geometry independent friction coefficient,
-        :math:`\frac{\zeta}{D^4}/\frac{1}{\text{m}^4}`.
-
-    D : float, dict, :code:`"var"`
-        Diameter of the pipes, :math:`D/\text{m}`.
-
-    L : float, dict, :code:`"var"`
-        Length of the pipes, :math:`L/\text{m}`.
-
-    ks : float, dict, :code:`"var"`
-        Pipe's roughness, :math:`ks/\text{m}` for darcy friction,
-        :math:`ks/\text{1}` for hazen-williams equation.
-
-    hydro_group : str, dict
-        Parametergroup for pressure drop calculation based on pipes dimensions.
-        Choose 'HW' for hazen-williams equation, else darcy friction factor is
-        used.
-
-    kA : float, dict, :code:`"var"`
-        Area independent heat transfer coefficient,
-        :math:`kA/\frac{\text{W}}{\text{K}}`.
-
-    kA_char : tespy.tools.characteristics.CharLine, dict
-        Characteristic line for heat transfer coefficient.
-
-    Tamb : float, dict
-        Ambient temperature, provide parameter in network's temperature unit.
-
-    kA_group : str, dict
-        Parametergroup for heat transfer calculation from ambient temperature
-        and area independent heat transfer coefficient kA.
-
-    Example
-    -------
-    The HeatExchangerSimple can be used as a sink or source of heat. This
-    component does not simulate the secondary side of the heat exchanger. It
-    is possible to calculate the pressure ratio with the Darcy-Weisbach
-    equation or in case of liquid water use the Hazen-Williams equation.
-    Also, given ambient temperature and the heat transfer coeffiecient, it is
-    possible to predict heat transfer.
-
-    >>> from tespy.components import Sink, Source, HeatExchangerSimple
-    >>> from tespy.connections import Connection
-    >>> from tespy.networks import Network
-    >>> import shutil
-    >>> fluids = ['N2']
-    >>> nw = Network(fluids=fluids)
-    >>> nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg', iterinfo=False)
-    >>> so1 = Source('source 1')
-    >>> si1 = Sink('sink 1')
-    >>> heat_sink = HeatExchangerSimple('heat sink')
-    >>> heat_sink.component()
-    'heat exchanger simple'
-    >>> heat_sink.set_attr(Tamb=10, pr=0.95, design=['pr'],
-    ... offdesign=['zeta', 'kA_char'])
-    >>> inc = Connection(so1, 'out1', heat_sink, 'in1')
-    >>> outg = Connection(heat_sink, 'out1', si1, 'in1')
-    >>> nw.add_conns(inc, outg)
-
-    It is possible to determine the amount of heat transferred when the fluid
-    enters the heat sink at a temperature of 200 C and is cooled down to
-    150 C. Given an ambient temperature of 10 C this also determines the heat
-    transfer coefficient to the ambient. Assuming a characteristic function
-    for the heat transfer coefficient we can predict the heat transferred at
-    variable flow rates.
-
-    >>> inc.set_attr(fluid={'N2': 1}, m=1, T=200, p=5)
-    >>> outg.set_attr(T=150, design=['T'])
-    >>> nw.solve('design')
-    >>> nw.save('tmp')
-    >>> round(heat_sink.Q.val, 0)
-    -52581.0
-    >>> round(heat_sink.kA.val, 0)
-    321.0
-    >>> inc.set_attr(m=1.25)
-    >>> nw.solve('offdesign', design_path='tmp')
-    >>> round(heat_sink.Q.val, 0)
-    -56599.0
-    >>> round(outg.T.val, 1)
-    156.9
-    >>> inc.set_attr(m=0.75)
-    >>> nw.solve('offdesign', design_path='tmp')
-    >>> round(heat_sink.Q.val, 1)
-    -47275.8
-    >>> round(outg.T.val, 1)
-    140.0
-    >>> shutil.rmtree('./tmp', ignore_errors=True)
-    """
-
-    @staticmethod
-    def component():
-        return 'heat exchanger simple'
-
-    def get_variables(self):
-        return {
-            'Q': dc_cp(
-                deriv=self.energy_balance_deriv,
-                latex=self.energy_balance_func_doc, num_eq=1,
-                func=self.energy_balance_func),
-            'pr': dc_cp(
-                min_val=1e-4, max_val=1, num_eq=1,
-                deriv=self.pr_deriv, latex=self.pr_func_doc,
-                func=self.pr_func, func_params={'pr': 'pr'}),
-            'zeta': dc_cp(
-                min_val=0, max_val=1e15, num_eq=1,
-                deriv=self.zeta_deriv, func=self.zeta_func,
-                latex=self.zeta_func_doc,
-                func_params={'zeta': 'zeta'}),
-            'D': dc_cp(min_val=1e-2, max_val=2, d=1e-4),
-            'L': dc_cp(min_val=1e-1, d=1e-3),
-            'ks': dc_cp(val=1e-4, min_val=1e-7, max_val=1e-3, d=1e-8),
-            'kA': dc_cp(min_val=0, d=1),
-            'kA_char': dc_cc(param='m'), 'Tamb': dc_cp(),
-            'dissipative': dc_simple(val=True),
-            'hydro_group': dc_gcp(
-                elements=['L', 'ks', 'D'], num_eq=1,
-                latex=self.hydro_group_func_doc,
-                func=self.hydro_group_func, deriv=self.hydro_group_deriv),
-            'kA_group': dc_gcp(
-                elements=['kA', 'Tamb'], num_eq=1,
-                latex=self.kA_group_func_doc,
-                func=self.kA_group_func, deriv=self.kA_group_deriv),
-            'kA_char_group': dc_gcp(
-                elements=['kA_char', 'Tamb'], num_eq=1,
-                latex=self.kA_char_group_func_doc,
-                func=self.kA_char_group_func, deriv=self.kA_char_group_deriv)
-        }
-
-    @staticmethod
-    def inlets():
-        return ['in1']
-
-    @staticmethod
-    def outlets():
-        return ['out1']
-
-    def comp_init(self, nw):
-        Component.comp_init(self, nw, num_eq=len(nw.fluids) + 1)
-
-        self.Tamb.val_SI = convert_to_SI('T', self.Tamb.val, nw.T_unit)
-
-    def energy_balance_func(self):
-        r"""
-        Equation for pressure drop calculation.
-
-        Returns
-        -------
-        residual : float
-            Residual value of equation:
-
-            .. math::
-
-                0 =\dot{m}_{in}\cdot\left( h_{out}-h_{in}\right) -\dot{Q}
-        """
-        return self.inl[0].m.val_SI * (
-            self.outl[0].h.val_SI - self.inl[0].h.val_SI) - self.Q.val
-
-    def energy_balance_func_doc(self, label):
-        r"""
-        Equation for pressure drop calculation.
-
-        Parameters
-        ----------
-        label : str
-            Label for equation.
-
-        Returns
-        -------
-        latex : str
-            LaTeX code of equations applied.
-        """
-        latex = (
-            r'0 = \dot{m}_\mathrm{in} \cdot \left(h_\mathrm{out} - '
-            r'h_\mathrm{in} \right) -\dot{Q}'
-        )
-        return generate_latex_eq(self, latex, label)
-
-    def energy_balance_deriv(self, increment_filter, k):
-        r"""
-        Calculate partial derivatives of energy balance.
-
-        Parameters
-        ----------
-        increment_filter : ndarray
-            Matrix for filtering non-changing variables.
-
-        k : int
-            Position of derivatives in Jacobian matrix (k-th equation).
-        """
-        self.jacobian[k, 0, 0] = (
-            self.outl[0].h.val_SI - self.inl[0].h.val_SI)
-        self.jacobian[k, 0, 2] = -self.inl[0].m.val_SI
-        self.jacobian[k, 1, 2] = self.inl[0].m.val_SI
-        # custom variable Q
-        if self.Q.is_var:
-            self.jacobian[k, 2 + self.Q.var_pos, 0] = -1
-
-    def hydro_group_func(self):
-        r"""
-        Equation for pressure drop calculation.
-
-        Returns
-        -------
-        residual : float
-            Residual value of corresponding equation:
-
-            - :py:meth:`tespy.components.heat_exchangers.simple.HeatExchangerSimple.darcy_func`
-            - :py:meth:`tespy.components.heat_exchangers.simple.HeatExchangerSimple.hazen_williams_func`
-        """
-        # hazen williams equation
-        if self.hydro_group.method == 'HW':
-            return self.hazen_williams_func()
-        # darcy friction factor
-        else:
-            return self.darcy_func()
-
-    def hydro_group_func_doc(self, label):
-        r"""
-        Equation for pressure drop calculation.
-
-        Parameters
-        ----------
-        label : str
-            Label for equation.
-
-        Returns
-        -------
-        latex : str
-            LaTeX code of equations applied.
-        """
-        # hazen williams equation
-        if self.hydro_group.method == 'HW':
-            return self.hazen_williams_func_doc(label)
-        # darcy friction factor
-        else:
-            return self.darcy_func_doc(label)
-
-    def hydro_group_deriv(self, increment_filter, k):
-        r"""
-        Calculate partial derivatives of hydro group (pressure drop).
-
-        Parameters
-        ----------
-        increment_filter : ndarray
-            Matrix for filtering non-changing variables.
-
-        k : int
-            Position of derivatives in Jacobian matrix (k-th equation).
-        """
-        # hazen williams equation
-        if self.hydro_group.method == 'HW':
-            func = self.hazen_williams_func
-        # darcy friction factor
+from tespy.tools import helpers as hlp
+from tespy.tools import logger
+from tespy.tools.global_vars import combustion_gases
+from tespy.tools.global_vars import err
+
+idx = pd.IndexSlice
+
+
+def categorize_fluids(conn):
+    fluid = hlp.single_fluid(conn.fluid.val)
+    if fluid is None:
+        cat = "non-combustion-gas"
+        for f, x in conn.fluid.val.items():
+            if x > err:
+                try:
+                    if hlp.fluidalias_in_list(f, combustion_gases):
+                        cat = "combustion-gas"
+                        break
+                except RuntimeError:
+                    # CoolProp cannot call aliases on incompressibles
+                    pass
+    else:
+        is_incompressible = False
+        try:
+            is_combustion_gas = hlp.fluidalias_in_list(fluid, combustion_gases)
+        except RuntimeError:
+            # CoolProp cannot call aliases on incompressibles
+            is_incompressible = True
+            is_combustion_gas = False
+        if is_combustion_gas:
+            cat = "combustion-gas"
+        elif is_incompressible:
+            cat = "incompressible"
         else:
-            func = self.darcy_func
-        if not increment_filter[0, 0]:
-            self.jacobian[k, 0, 0] = self.numeric_deriv(func, 'm', 0)
-        if not increment_filter[0, 1]:
-            self.jacobian[k, 0, 1] = self.numeric_deriv(func, 'p', 0)
-        if not increment_filter[0, 2]:
-            self.jacobian[k, 0, 2] = self.numeric_deriv(func, 'h', 0)
-        if not increment_filter[1, 1]:
-            self.jacobian[k, 1, 1] = self.numeric_deriv(func, 'p', 1)
-        if not increment_filter[1, 2]:
-            self.jacobian[k, 1, 2] = self.numeric_deriv(func, 'h', 1)
-        # custom variables of hydro group
-        for var in self.hydro_group.elements:
-            var = self.get_attr(var)
-            if var.is_var:
-                self.jacobian[k, 2 + var.var_pos, 0] = (
-                    self.numeric_deriv(func, self.vars[var], 2))
+            cat = "two-phase-fluid"
+    return cat
 
-    def darcy_func(self):
-        r"""
-        Equation for pressure drop calculation from darcy friction factor.
-
-        Returns
-        -------
-        residual : float
-            Residual value of equation.
-
-            .. math::
-
-                0 = p_{in} - p_{out} - \frac{8 \cdot |\dot{m}_{in}| \cdot
-                \dot{m}_{in} \cdot \frac{v_{in}+v_{out}}{2} \cdot L \cdot
-                \lambda\left(Re, ks, D\right)}{\pi^2 \cdot D^5}\\
-
-                Re = \frac{4 \cdot |\dot{m}_{in}|}{\pi \cdot D \cdot
-                \frac{\eta_{in}+\eta_{out}}{2}}\\
-                \eta: \text{dynamic viscosity}\\
-                v: \text{specific volume}\\
-                \lambda: \text{darcy friction factor}
-        """
-        i, o = self.inl[0].get_flow(), self.outl[0].get_flow()
-
-        if abs(i[0]) < 1e-4:
-            return i[1] - o[1]
 
-        visc_i = visc_mix_ph(i, T0=self.inl[0].T.val_SI)
-        visc_o = visc_mix_ph(o, T0=self.outl[0].T.val_SI)
-        v_i = v_mix_ph(i, T0=self.inl[0].T.val_SI)
-        v_o = v_mix_ph(o, T0=self.outl[0].T.val_SI)
+class ExergyAnalysis:
+    r"""Class for exergy analysis of TESPy models."""
+    exergy_cats = ["chemical", "physical", "massless"]
 
-        Re = 4 * abs(i[0]) / (np.pi * self.D.val * (visc_i + visc_o) / 2)
-
-        return ((i[1] - o[1]) - 8 * abs(i[0]) * i[0] * (v_i + v_o) / 2 *
-                self.L.val * dff(Re, self.ks.val, self.D.val) /
-                (np.pi ** 2 * self.D.val ** 5))
-
-    def darcy_func_doc(self, label):
+    def __init__(self, network, E_F, E_P, E_L=[], internal_busses=[]):
         r"""
-        Equation for pressure drop calculation from darcy friction factor.
-
         Parameters
         ----------
-        label : str
-            Label for equation.
-
-        Returns
-        -------
-        latex : str
-            LaTeX code of equations applied.
-        """
-        latex = (
-            r'\begin{split}' + '\n'
-            r'0 = &p_\mathrm{in}-p_\mathrm{out}-'
-            r'\frac{8\cdot|\dot{m}_\mathrm{in}| \cdot\dot{m}_\mathrm{in}'
-            r'\cdot \frac{v_\mathrm{in}+v_\mathrm{out}}{2} \cdot L \cdot'
-            r'\lambda\left(Re, ks, D\right)}{\pi^2 \cdot D^5}\\' + '\n'
-            r'Re =&\frac{4 \cdot |\dot{m}_\mathrm{in}|}{\pi \cdot D \cdot'
-            r'\frac{\eta_\mathrm{in}+\eta_\mathrm{out}}{2}}\\' + '\n'
-            r'\end{split}'
-        )
-        return generate_latex_eq(self, latex, label)
-
-    def hazen_williams_func(self):
-        r"""
-        Equation for pressure drop calculation from Hazen-Williams equation.
+        E_F : list
+            List containing busses which represent fuel exergy input of the
+            network, e.g. heat exchangers of the steam generator.
 
-        Returns
-        -------
-        residual : float
-            Residual value of equation.
+        E_P : list
+            List containing busses which represent exergy production of the
+            network, e.g. the motors and generators of a power plant.
 
-            .. math::
+        E_L : list
+            Optional: List containing busses which represent exergy loss
+            streams of the network to the ambient, e.g. flue gases of a gas
+            turbine.
 
-                0 = \left(p_{in} - p_{out} \right) \cdot \left(-1\right)^i -
-                \frac{10.67 \cdot |\dot{m}_{in}| ^ {1.852}
-                \cdot L}{ks^{1.852} \cdot D^{4.871}} \cdot g \cdot
-                \left(\frac{v_{in} + v_{out}}{2}\right)^{0.852}
-
-                i = \begin{cases}
-                0 & \dot{m}_{in} \geq 0\\
-                1 & \dot{m}_{in} < 0
-                \end{cases}
+        internal_busses : list
+            Optional: List containing internal busses that represent exergy
+            transfer within your network but neither exergy production or
+            exergy fuel, e.g. a steam turbine driven feed water pump. The
+            conversion factors of the bus are applied to calculate exergy
+            destruction which is allocated to the respective components.
 
         Note
         ----
-        Gravity :math:`g` is set to :math:`9.81 \frac{m}{s^2}`
-        """
-        i, o = self.inl[0].get_flow(), self.outl[0].get_flow()
-
-        if abs(i[0]) < 1e-4:
-            return i[1] - o[1]
-
-        v_i = v_mix_ph(i, T0=self.inl[0].T.val_SI)
-        v_o = v_mix_ph(o, T0=self.outl[0].T.val_SI)
+        The nomenclature of the variables used in the exergy analysis is
+        according to :cite:`Tsatsaronis2007`.
 
-        return ((i[1] - o[1]) * np.sign(i[0]) -
-                (10.67 * abs(i[0]) ** 1.852 * self.L.val /
-                 (self.ks.val ** 1.852 * self.D.val ** 4.871)) *
-                (9.81 * ((v_i + v_o) / 2) ** 0.852))
+        The analysis is carried out by the
+        :py:meth:`tespy.tools.analyses.ExergyAnalysis.analyse` method. Given
+        the ambient state (pressure and temperature), it will
+
+        - Calculate the values of physical exergy on all connections
+        - Calculate exergy balance for all components. The individual exergy
+          balance methods are documented in the API-documentation of the
+          respective components.
+
+          - Components for which no exergy balance has yet been implemented,
+            :code:`nan` (not defined) is assigned for fuel and product
+            exergy as well as exergy destruction and exergetic efficiency.
+          - Dissipative components do not have product exergy (:code:`nan`) per
+            definition.
+
+        - Calculate exergy balances for busses passed to ExergyAnalysis class
+          instance.
+        - Calculate network fuel exergy, product exergy as well as exergy loss
+          from data provided by the busses passed to the instance.
+        - Calculate network exergetic efficiency.
+        - Calculate exergy destruction ratios for components.
+
+          - :math:`y_\mathrm{D}` compare the rate of exergy destruction in a
+            component to the exergy rate of the fuel provided to the overall
+            system.
+          - :math:`y^*_\mathrm{D}` compare the component exergy destruction
+            rate to the total exergy destruction rate within the system.
 
-    def hazen_williams_func_doc(self, label):
-        r"""
-        Equation for pressure drop calculation from Hazen-Williams equation.
-
-        Parameters
-        ----------
-        label : str
-            Label for equation.
-
-        Returns
-        -------
-        latex : str
-            LaTeX code of equations applied.
-        """
-        latex = (
-            r'0 = \left(p_\mathrm{in} - p_\mathrm{out} \right) -'
-            r'\frac{10.67 \cdot |\dot{m}_\mathrm{in}| ^ {1.852}'
-            r'\cdot L}{ks^{1.852} \cdot D^{4.871}} \cdot g \cdot'
-            r'\left(\frac{v_\mathrm{in}+ v_\mathrm{out}}{2}\right)^{0.852}'
-        )
-        return generate_latex_eq(self, latex, label)
-
-    def kA_group_func(self):
-        r"""
-        Calculate heat transfer from heat transfer coefficient.
-
-        Returns
-        -------
-        residual : float
-            Residual value of equation.
-
-            .. math::
-
-                0 = \dot{m}_{in} \cdot \left( h_{out} - h_{in}\right) +
-                kA \cdot \Delta T_{log}
-
-                \Delta T_{log} = \begin{cases}
-                \frac{T_{in}-T_{out}}{\ln{\frac{T_{in}-T_{amb}}
-                {T_{out}-T_{amb}}}} & T_{in} > T_{out} \\
-                \frac{T_{out}-T_{in}}{\ln{\frac{T_{out}-T_{amb}}
-                {T_{in}-T_{amb}}}} & T_{in} < T_{out}\\
-                0 & T_{in} = T_{out}
-                \end{cases}
-
-                T_{amb}: \text{ambient temperature}
-        """
-        i, o = self.inl[0].get_flow(), self.outl[0].get_flow()
-
-        ttd_1 = T_mix_ph(i, T0=self.inl[0].T.val_SI) - self.Tamb.val_SI
-        ttd_2 = T_mix_ph(o, T0=self.outl[0].T.val_SI) - self.Tamb.val_SI
+        .. math::
 
-        # For numerical stability: If temperature differences have
-        # different sign use mean difference to avoid negative logarithm.
-        if (ttd_1 / ttd_2) < 0:
-            td_log = (ttd_2 + ttd_1) / 2
-        elif ttd_1 > ttd_2:
-            td_log = (ttd_1 - ttd_2) / np.log(ttd_1 / ttd_2)
-        elif ttd_1 < ttd_2:
-            td_log = (ttd_2 - ttd_1) / np.log(ttd_2 / ttd_1)
-        else:
-            td_log = 0
+            \begin{split}
+            \dot{E}_{\mathrm{D},comp} = \dot{E}_{\mathrm{F},comp} - \dot{E}_{\mathrm{P},comp}
+            \;& \\
+            \varepsilon_{\mathrm{comp}} =
+            \frac{\dot{E}_{\mathrm{P},comp}}{\dot{E}_{\mathrm{F},comp}} \;& \\
+            \dot{E}_{\mathrm{D}} = \sum_{comp} \dot{E}_{\mathrm{D},comp} \;&
+            \forall comp \in \text{ network components}\\
+            \dot{E}_{\mathrm{P}} = \sum_{comp} \dot{E}_{\mathrm{P},comp} \;&
+            \forall comp \in
+            \text{ components of busses in E\_P if 'base': 'component'}\\
+            \dot{E}_{\mathrm{P}} = \dot{E}_{\mathrm{P}} - \sum_{comp} \dot{E}_{\mathrm{F},comp}
+            \;& \forall comp \in
+            \text{ components of busses in E\_P if 'base': 'bus'}\\
+            \dot{E}_{\mathrm{F}} = \sum_{comp} \dot{E}_{\mathrm{F},comp} \;&
+            \forall comp \in
+            \text{ components of busses in E\_F if 'base': 'bus'}\\
+            \dot{E}_{\mathrm{F}} = \dot{E}_{\mathrm{F}} - \sum_{comp} \dot{E}_{\mathrm{P},comp}
+            \;& \forall comp \in
+            \text{ components of busses in E\_F if 'base': 'component'}\\
+            \dot{E}_{\mathrm{L}} = \sum_{comp} \dot{E}_{\mathrm{D},comp} \;&
+            \forall comp \in
+            \text{ sinks of network components if parameter exergy='loss'}
+            \end{split}
+
+        The exergy balance of the network must be closed, meaning fuel exergy
+        minus product exergy, exergy destruction and exergy losses must be
+        zero (:math:`\Delta \dot{E}_\text{max}=0.001`). If the balance is violated a
+        warning message is prompted.
 
-        return i[0] * (o[2] - i[2]) + self.kA.val * td_log
+        .. math::
 
-    def kA_group_func_doc(self, label):
-        r"""
-        Calculate heat transfer from heat transfer coefficient.
+            |\dot{E}_{\text{F}} - \dot{E}_{\text{P}} - \dot{E}_{\text{L}} - \dot{E}_{\text{D}}| \leq
+            \Delta \dot{E}_\text{max}\\
 
-        Parameters
-        ----------
-        label : str
-            Label for equation.
+            \varepsilon = \frac{\dot{E}_{\text{P}}}{\dot{E}_{\text{F}}}
 
-        Returns
-        -------
-        latex : str
-            LaTeX code of equations applied.
-        """
-        latex = (
-            r'\begin{split}' + '\n'
-            r'0=&\dot{m}_\mathrm{in}\cdot\left(h_\mathrm{out}-'
-            r'h_\mathrm{in}\right)+kA \cdot \Delta T_\mathrm{log}\\' + '\n'
-            r'\Delta T_\mathrm{log} = &\begin{cases}' + '\n'
-            r'\frac{T_\mathrm{in}-T_\mathrm{out}}{\ln{\frac{T_\mathrm{in}-'
-            r'T_\mathrm{amb}}{T_\mathrm{out}-T_\mathrm{amb}}}} &'
-            r' T_\mathrm{in} > T_\mathrm{out} \\' + '\n'
-            r'\frac{T_\mathrm{out}-T_\mathrm{in}}{\ln{\frac{'
-            r'T_\mathrm{out}-T_\mathrm{amb}}{T_\mathrm{in}-'
-            r'T_\mathrm{amb}}}} & T_\mathrm{in} < T_\mathrm{out}\\' + '\n'
-            r'0 & T_\mathrm{in} = T_\mathrm{out}' + '\n'
-            r'\end{cases}\\' + '\n'
-            r'T_\mathrm{amb} =& \text{ambient temperature}' + '\n'
-            r'\end{split}'
+            y_{\text{D},comp} =
+            \frac{\dot{E}_{\text{D},comp}}{\dot{E}_{\text{F}}}\\
+            y^*_{\text{D},comp} =
+            \frac{\dot{E}_{\text{D},comp}}{\dot{E}_{\text{D}}}
+
+        Example
+        -------
+        In this example a simple clausius rankine cycle is set up and an
+        exergy analysis is performed after simulation of the power plant.
+        Start by defining ambient state and genereral network setup.
+
+        >>> from tespy.components import (CycleCloser, SimpleHeatExchanger,
+        ... Merge, Splitter, Valve, Compressor, Pump, Turbine)
+        >>> from tespy.connections import Bus
+        >>> from tespy.connections import Connection
+        >>> from tespy.networks import Network
+        >>> from tespy.tools import ExergyAnalysis
+
+        >>> Tamb = 20
+        >>> pamb = 1
+        >>> fluids = ['water']
+        >>> nw = Network(fluids=fluids)
+        >>> nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg',
+        ... iterinfo=False)
+
+        In order to show all functionalities available we use a feed water pump
+        that is not driven electrically by a motor but instead internally by
+        an own steam turbine. Therefore we split up the live steam from the
+        steam generator and merge the streams after both steam turbines. For
+        simplicity the steam generator and the condenser are modeled as simple
+        heat exchangers.
+
+        >>> cycle_close = CycleCloser('cycle closer')
+        >>> splitter1 = Splitter('splitter 1')
+        >>> merge1 = Merge('merge 1')
+        >>> turb = Turbine('turbine')
+        >>> fwp_turb = Turbine('feed water pump turbine')
+        >>> condenser = SimpleHeatExchanger('condenser')
+        >>> fwp = Pump('pump')
+        >>> steam_generator = SimpleHeatExchanger('steam generator')
+
+        >>> fs_in = Connection(cycle_close, 'out1', splitter1, 'in1')
+        >>> fs_fwpt = Connection(splitter1, 'out1', fwp_turb, 'in1')
+        >>> fs_t = Connection(splitter1, 'out2', turb, 'in1')
+        >>> fwpt_ws = Connection(fwp_turb, 'out1', merge1, 'in1')
+        >>> t_ws = Connection(turb, 'out1', merge1, 'in2')
+        >>> ws = Connection(merge1, 'out1', condenser, 'in1')
+        >>> cond = Connection(condenser, 'out1', fwp, 'in1')
+        >>> fw = Connection(fwp, 'out1', steam_generator, 'in1')
+        >>> fs_out = Connection(steam_generator, 'out1', cycle_close, 'in1')
+        >>> nw.add_conns(fs_in, fs_fwpt, fs_t, fwpt_ws, t_ws, ws, cond,
+        ... fw, fs_out)
+
+        Next step is to set up the busses to later pass them according to the
+        convetions in the list below:
+
+        - E_F for fuel exergy
+        - E_P for product exergy
+        - internal_busses for internal energy transport
+        - E_L for exergy loss streams to the ambient (sources and sinks go
+          here, in case you use e.g. flue gases or air input)
+
+        The first bus is for output power, which is only represented by the
+        main steam turbine. The efficiency is set to 0.97. This bus will
+        represent the product exergy.
+
+        >>> power = Bus('power_output')
+        >>> power.add_comps({'comp': turb, 'char': 0.97})
+
+        The second bus is for driving the feed water pump. The total power of
+        this bus is specified to be 0 in order to make sure, the power genrated
+        by the secondary steam turbine is transferred to the feed water pump.
+        For mechanical efficiency we choose 0.985 for both components, but
+        we need to make sure, the :code:`'base'` of the feed water pump is
+        :code:`'bus'` as the energy from the turbine drives the feed water
+        pump.
+
+        >>> fwp_power = Bus('feed water pump power', P=0)
+        >>> fwp_power.add_comps(
+        ... {'comp': fwp_turb, 'char': 0.985},
+        ... {'comp': fwp, 'char': 0.985, 'base': 'bus'})
+
+        The fuel exergy is the exergy input into the network which is
+        represented by the heat input bus. Here again, as we have an energy
+        input from outside of the network, the :code:`'base'` keyword must be
+        specified to :code:`'bus'`.
+
+        >>> heat = Bus('heat_input')
+        >>> heat.add_comps({'comp': steam_generator, 'base': 'bus'})
+        >>> nw.add_busses(power, fwp_power, heat)
+
+        After setting up the busses, we specify the parameters for components
+        and connections and start the simulation.
+
+        >>> turb.set_attr(eta_s=0.9)
+        >>> fwp_turb.set_attr(eta_s=0.87)
+        >>> condenser.set_attr(pr=0.98)
+        >>> fwp.set_attr(eta_s=0.75)
+        >>> steam_generator.set_attr(pr=0.89)
+        >>> fs_in.set_attr(m=10, p=120, T=600, fluid={'water': 1})
+        >>> cond.set_attr(T=Tamb + 3, x=0)
+        >>> nw.solve('design')
+
+        To evaluate the exergy balance of the network, we create an instance of
+        class :py:class:`tespy.tools.analyses.ExergyAnalysis`
+        passing the network to analyse as well as the respective busses. To run
+        the analysis, the ambient state is passed subsequently. The results of
+        the analysis can be printed using the
+        :py:meth:`tespy.tools.analyses.ExergyAnalysis.print_results` method.
+        The exergy balance should be closed, if you set up your network
+        analysis correctly. If not, an error is prompted.
+
+        >>> ean = ExergyAnalysis(network=nw, E_F=[heat], E_P=[power],
+        ... internal_busses=[fwp_power])
+        >>> ean.analyse(pamb=pamb, Tamb=Tamb)
+        >>> abs(round(ean.network_data['E_F'] - ean.network_data['E_P'] -
+        ... ean.network_data['E_L'] - ean.network_data['E_D'], 3))
+        0.0
+        >>> ();ean.print_results();() # doctest: +ELLIPSIS
+        (...)
+
+        The exergy data of the passed busses, the network's components and
+        connections as well as the network itself are stored as dataframes and
+        therefore accessible for further investigation.
+
+        >>> busses = ean.bus_data
+        >>> components = ean.component_data
+        >>> connections = ean.connection_data
+        >>> network = ean.network_data
+
+        Additionally, if you defined component groups for your components, the
+        exergy data of these groups are accumulated and saved in an own
+        DataFrame. Please note, that the exergy destruction values of the
+        busses are allocated to the component groups in this case.
+
+        >>> groups = ean.group_data
+
+        Lastly, the tool offers an automatically generated data input for the
+        sankey plotting functionalities of the plotly library to create a
+        Grassmann diagram of your network. For more information on the usage
+        of the functionality look up the corresponding method documentation:
+        :py:meth:`tespy.tools.analyses.ExergyAnalysis.generate_plotly_sankey_input`.
+        The method returns a dictionary containting the links for the sankey
+        as well as a list of the nodes.
+
+        >>> links, nodes = ean.generate_plotly_sankey_input()
+        """
+        if len(E_F) == 0:
+            msg = ('Missing fuel exergy E_F of network.')
+            logger.error(msg)
+            raise hlp.TESPyNetworkError(msg)
+
+        if len(E_P) == 0:
+            msg = ('Missing product exergy E_P of network.')
+            logger.error(msg)
+            raise hlp.TESPyNetworkError(msg)
+
+        self.nw = network
+        self.E_F = E_F
+        self.E_P = E_P
+        self.E_L = E_L
+        self.internal_busses = internal_busses
+
+        bus_labels = [b.label for b in internal_busses + E_F + E_P + E_L]
+        key_exergy_labels = ['E_P', 'E_F', 'E_D', 'E_L']
+        self.reserved_fkt_groups = key_exergy_labels + bus_labels
+        if len(set(bus_labels).intersection(key_exergy_labels)) > 0:
+            msg = (
+                "None of your busses may have the label '"
+                + "', '".join(key_exergy_labels) + "' when performing the "
+                + "exergy analysis."
+            )
+            raise ValueError(msg)
+
+    def analyse(self, pamb, Tamb, Chem_Ex=None):
+        """Run the exergy analysis.
+
+        Parameters
+        ----------
+        pamb : float
+            Ambient pressure value for analysis, provide value in network's
+            pressure unit.
+
+        Tamb : float
+            Ambient temperature value for analysis, provide value in network's
+            temperature unit.
+        """
+        pamb_SI = hlp.convert_to_SI('p', pamb, self.nw.p_unit)
+        Tamb_SI = hlp.convert_to_SI('T', Tamb, self.nw.T_unit)
+
+        # reset data
+        self.component_data = pd.DataFrame(
+            columns=['E_F', 'E_P', 'E_D', 'epsilon', 'group'], dtype='float64'
         )
-        return generate_latex_eq(self, latex, label)
-
-    def kA_group_deriv(self, increment_filter, k):
-        r"""
-        Calculate partial derivatives of kA group.
-
-        Parameters
-        ----------
-        increment_filter : ndarray
-            Matrix for filtering non-changing variables.
-
-        k : int
-            Position of derivatives in Jacobian matrix (k-th equation).
-        """
-        f = self.kA_group_func
-        self.jacobian[k, 0, 0] = (
-            self.outl[0].h.val_SI - self.inl[0].h.val_SI)
-        if not increment_filter[0, 1]:
-            self.jacobian[k, 0, 1] = self.numeric_deriv(f, 'p', 0)
-        if not increment_filter[0, 2]:
-            self.jacobian[k, 0, 2] = self.numeric_deriv(f, 'h', 0)
-        if not increment_filter[1, 1]:
-            self.jacobian[k, 1, 1] = self.numeric_deriv(f, 'p', 1)
-        if not increment_filter[1, 2]:
-            self.jacobian[k, 1, 2] = self.numeric_deriv(f, 'h', 1)
-        if self.kA.is_var:
-            self.jacobian[k, 2 + self.kA.var_pos, 0] = (
-                self.numeric_deriv(f, self.vars[self.kA], 2))
 
-    def kA_char_group_func(self):
-        r"""
-        Calculate heat transfer from heat transfer coefficient characteristic.
-
-        Returns
-        -------
-        residual : float
-            Residual value of equation.
-
-            .. math::
-
-                0 = \dot{m}_{in} \cdot \left( h_{out} - h_{in}\right) +
-                kA_{design} \cdot f_{kA} \cdot \Delta T_{log}
-
-                \Delta T_{log} = \begin{cases}
-                \frac{T_{in}-T_{out}}{\ln{\frac{T_{in}-T_{amb}}
-                {T_{out}-T_{amb}}}} & T_{in} > T_{out} \\
-                \frac{T_{out}-T_{in}}{\ln{\frac{T_{out}-T_{amb}}
-                {T_{in}-T_{amb}}}} & T_{in} < T_{out}\\
-                0 & T_{in} = T_{out}
-                \end{cases}
-
-                f_{kA} = \frac{2}{1 + \frac{1}{f\left( expr\right)}}
-
-                T_{amb}: \text{ambient temperature}
-
-        Note
-        ----
-        For standard function of f\ :subscript:`kA` \ see module
-        :py:mod:`tespy.data`.
-        """
-        p = self.kA_char.param
-        expr = self.get_char_expr(p, **self.kA_char.char_params)
-        i, o = self.inl[0].get_flow(), self.outl[0].get_flow()
-
-        # For numerical stability: If temperature differences have
-        # different sign use mean difference to avoid negative logarithm.
-
-        ttd_1 = T_mix_ph(i, T0=self.inl[0].T.val_SI) - self.Tamb.val_SI
-        ttd_2 = T_mix_ph(o, T0=self.outl[0].T.val_SI) - self.Tamb.val_SI
-
-        if (ttd_1 / ttd_2) < 0:
-            td_log = (ttd_2 + ttd_1) / 2
-        elif ttd_1 > ttd_2:
-            td_log = (ttd_1 - ttd_2) / np.log(ttd_1 / ttd_2)
-        elif ttd_1 < ttd_2:
-            td_log = (ttd_2 - ttd_1) / np.log(ttd_2 / ttd_1)
-        else:
-            td_log = 0
-
-        fkA = 2 / (1 + 1 / self.kA_char.char_func.evaluate(expr))
-
-        return i[0] * (o[2] - i[2]) + self.kA.design * fkA * td_log
-
-    def kA_char_group_func_doc(self, label):
-        r"""
-        Calculate heat transfer from heat transfer coefficient characteristic.
-
-        Parameters
-        ----------
-        label : str
-            Label for equation.
-
-        Returns
-        -------
-        latex : str
-            LaTeX code of equations applied.
-        """
-        latex = (
-            r'\begin{split}' + '\n'
-            r'0=&\dot{m}_\mathrm{in}\cdot\left(h_\mathrm{out}-'
-            r'h_\mathrm{in}\right)+kA_\mathrm{design} \cdot f_\mathrm{kA}'
-            r' \cdot \Delta T_\mathrm{log}\\' + '\n'
-            r'\Delta T_\mathrm{log} = &\begin{cases}' + '\n'
-            r'\frac{T_\mathrm{in}-T_\mathrm{out}}{\ln{\frac{T_\mathrm{in}-'
-            r'T_\mathrm{amb}}{T_\mathrm{out}-T_\mathrm{amb}}}} &'
-            r' T_\mathrm{in} > T_\mathrm{out} \\' + '\n'
-            r'\frac{T_\mathrm{out}-T_\mathrm{in}}{\ln{\frac{'
-            r'T_\mathrm{out}-T_\mathrm{amb}}{T_\mathrm{in}-'
-            r'T_\mathrm{amb}}}} & T_\mathrm{in} < T_\mathrm{out}\\' + '\n'
-            r'0 & T_\mathrm{in} = T_\mathrm{out}' + '\n'
-            r'\end{cases}\\' + '\n'
-            r'f_{kA}=&\frac{2}{1 + \frac{1}{f\left(X\right)}}\\' + '\n'
-            r'T_\mathrm{amb} =& \text{ambient temperature}' + '\n'
-            r'\end{split}'
+        self.bus_data = self.component_data.copy()
+        self.bus_data['base'] = np.nan
+        conn_exergy_data_cols = ['e_PH', 'e_T', 'e_M', 'E_PH', 'E_T', 'E_M']
+
+        if Chem_Ex is not None:
+            conn_exergy_data_cols += ['e_CH', 'E_CH']
+
+        self.connection_data = pd.DataFrame(
+            columns=conn_exergy_data_cols,
+            dtype='float64'
         )
-        return generate_latex_eq(self, latex, label)
-
-    def kA_char_group_deriv(self, increment_filter, k):
-        r"""
-        Calculate partial derivatives of kA characteristics.
-
-        Parameters
-        ----------
-        increment_filter : ndarray
-            Matrix for filtering non-changing variables.
-
-        k : int
-            Position of derivatives in Jacobian matrix (k-th equation).
-        """
-        f = self.kA_char_group_func
-        if not increment_filter[0, 0]:
-            self.jacobian[k, 0, 0] = self.numeric_deriv(f, 'm', 0)
-        if not increment_filter[0, 1]:
-            self.jacobian[k, 0, 1] = self.numeric_deriv(f, 'p', 0)
-        if not increment_filter[0, 2]:
-            self.jacobian[k, 0, 2] = self.numeric_deriv(f, 'h', 0)
-        if not increment_filter[1, 1]:
-            self.jacobian[k, 1, 1] = self.numeric_deriv(f, 'p', 1)
-        if not increment_filter[1, 2]:
-            self.jacobian[k, 1, 2] = self.numeric_deriv(f, 'h', 1)
-
-    def bus_func(self, bus):
-        r"""
-        Calculate the value of the bus function.
-
-        Parameters
-        ----------
-        bus : tespy.connections.bus.Bus
-            TESPy bus object.
-
-        Returns
-        -------
-        val : float
-            Value of energy transfer :math:`\dot{E}`. This value is passed to
-            :py:meth:`tespy.components.component.Component.calc_bus_value`
-            for value manipulation according to the specified characteristic
-            line of the bus.
-
-            .. math::
-
-                \dot{E} = \dot{m}_{in} \cdot \left( h_{out} - h_{in} \right)
-        """
-        return self.inl[0].m.val_SI * (
-            self.outl[0].h.val_SI - self.inl[0].h.val_SI)
-
-    def bus_func_doc(self, bus):
-        r"""
-        Return LaTeX string of the bus function.
-
-        Parameters
-        ----------
-        bus : tespy.connections.bus.Bus
-            TESPy bus object.
-
-        Returns
-        -------
-        latex : str
-            LaTeX string of bus function.
-        """
-        return (
-            r'\dot{m}_\mathrm{in} \cdot \left(h_\mathrm{out} - '
-            r'h_\mathrm{in} \right)')
-
-    def bus_deriv(self, bus):
-        r"""
-        Calculate partial derivatives of the bus function.
-
-        Parameters
-        ----------
-        bus : tespy.connections.bus.Bus
-            TESPy bus object.
-
-        Returns
-        -------
-        deriv : ndarray
-            Matrix of partial derivatives.
-        """
-        deriv = np.zeros((1, 2, self.num_nw_vars))
-        f = self.calc_bus_value
-        deriv[0, 0, 0] = self.numeric_deriv(f, 'm', 0, bus=bus)
-        deriv[0, 0, 2] = self.numeric_deriv(f, 'h', 0, bus=bus)
-        deriv[0, 1, 2] = self.numeric_deriv(f, 'h', 1, bus=bus)
-        return deriv
-
-    def initialise_source(self, c, key):
-        r"""
-        Return a starting value for pressure and enthalpy the outlets.
-
-        Parameters
-        ----------
-        c : tespy.connections.connection.Connection
-            Connection to perform initialisation on.
-
-        key : str
-            Fluid property to retrieve.
 
-        Returns
-        -------
-        val : float
-            Starting value for pressure/enthalpy in SI units.
+        self.network_data = pd.Series(
+            index=['E_F', 'E_P', 'E_D', 'E_L'], dtype='float64'
+        )
+        self.network_data[:] = 0
 
-            .. math::
+        # physical exergy of connections
+        for conn in self.nw.conns['object']:
+            conn.get_physical_exergy(pamb_SI, Tamb_SI)
+            conn.get_chemical_exergy(pamb_SI, Tamb_SI, Chem_Ex)
+            conn_exergy_data = [
+                conn.ex_physical, conn.ex_therm, conn.ex_mech,
+                conn.Ex_physical, conn.Ex_therm, conn.Ex_mech
+            ]
+            if Chem_Ex is not None:
+                conn_exergy_data += [conn.ex_chemical, conn.Ex_chemical]
+
+            self.connection_data.loc[conn.label] = conn_exergy_data
+
+        # todo: berprfen der sankey data + massless exergy
+        self.sankey_data = {}
+        sankey_columns_dtypes = {
+            'chemical': float,
+            'physical': float,
+            'massless': float
+        }
+        for label in self.reserved_fkt_groups:
+            self.sankey_data[label] = pd.DataFrame(
+                columns=sankey_columns_dtypes.keys(),
+                index=pd.MultiIndex(
+                    levels=[[], []],
+                    names=["target_group", "category"],
+                    codes=[[], []]
+                )
+            ).astype(sankey_columns_dtypes)
+
+        # exergy balance of components
+        for cp in self.nw.comps['object']:
+            # save component information
+            cp.exergy_balance(Tamb_SI)
+            if not hasattr(cp, 'fkt_group'):
+                cp.fkt_group = cp.label
+            self.component_data.loc[cp.label] = [
+                cp.E_F, cp.E_P, cp.E_D, cp.epsilon, cp.fkt_group
+            ]
+
+            if cp.fkt_group in self.reserved_fkt_groups:
+                msg = (
+                    'The labels ' + ', '.join(self.reserved_fkt_groups) + ' '
+                    'cannot be used by components (if no group was assigned) '
+                    'or component groups in the exergy analysis. Found '
+                    'component/group with name ' + cp.fkt_group + '.'
+                )
+                raise ValueError(msg)
+            elif cp.fkt_group not in self.sankey_data:
+                self.sankey_data[cp.fkt_group] = pd.DataFrame(
+                    columns=sankey_columns_dtypes.keys(),
+                    index=pd.MultiIndex(
+                        levels=[[], []],
+                        names=["target_group", "category"],
+                        codes=[[], []]
+                    )
+                ).astype(sankey_columns_dtypes)
+
+            self.evaluate_busses(cp)
+
+        # create a table that includes exergy destruction attributed to the
+        # components
+        bus_based = self.bus_data[self.bus_data['base'] == 'bus'].index
+        component_based = self.bus_data[
+            self.bus_data['base'] == 'component'
+        ].index
+
+        # add aggregated components with respective buses data
+        self.aggregation_data = self.component_data.copy()
+        # E_D is sum of both E_D
+        self.aggregation_data.loc[self.bus_data.index, 'E_D'] = (
+            self.component_data.loc[self.bus_data.index, 'E_D'] +
+            self.bus_data['E_D']
+        )
+        # E_F for bus based components is higher by E_D of bus
+        self.aggregation_data.loc[bus_based, 'E_F'] += (
+            self.bus_data.loc[bus_based, 'E_D']
+        )
+        # E_P of component based components is lower by E_D of bus
+        self.aggregation_data.loc[component_based, 'E_P'] -= (
+            self.bus_data.loc[component_based, 'E_D']
+        )
 
-                val = \begin{cases}
-                \begin{cases}
-                1 \cdot 10^5 \; \frac{\text{J}}{\text{kg}} & \dot{Q} < 0\\
-                3 \cdot 10^5 \; \frac{\text{J}}{\text{kg}} & \dot{Q} = 0\\
-                5 \cdot 10^5 \; \frac{\text{J}}{\text{kg}} & \dot{Q} > 0
-                \end{cases} & \text{key = 'h'}\\
-                \; \; \; \; 10^5 \text{Pa} & \text{key = 'p'}
-                \end{cases}
+        # calculate network results
+        self.network_data.loc['E_D'] = (
+            self.component_data['E_D'].sum() + self.bus_data['E_D'].sum())
+        self.network_data.loc['E_F'] = abs(self.network_data.loc['E_F'])
+        self.network_data.loc['E_P'] = abs(self.network_data.loc['E_P'])
+        self.network_data.loc['epsilon'] = (
+            self.network_data.loc['E_P'] / self.network_data.loc['E_F']
+        )
 
-        """
-        if key == 'p':
-            return 1e5
-        elif key == 'h':
-            if self.Q.val < 0 and self.Q.is_set:
-                return 1e5
-            elif self.Q.val > 0 and self.Q.is_set:
-                return 5e5
-            else:
-                return 3e5
+        # calculate exergy destruction ratios for components/busses
+        E_F = self.network_data.loc['E_F']
+        E_D = self.network_data.loc['E_D']
+
+        for d in [self.component_data, self.bus_data, self.aggregation_data]:
+            d['y_Dk'] = d['E_D'] / E_F
+            d['y*_Dk'] = d['E_D'] / E_D
+            d['epsilon'] = d['E_P'] / d['E_F']
+
+        residual = abs(
+            self.network_data.loc['E_F'] - self.network_data.loc['E_P'] -
+            self.network_data.loc['E_D'] - self.network_data.loc['E_L']
+        )
 
-    def initialise_target(self, c, key):
-        r"""
-        Return a starting value for pressure and enthalpy the inlets.
+        if residual >= err ** 0.5:
+            msg = (
+                'The exergy balance of your network is not closed (residual '
+                'value is ' + str(round(residual, 6)) + ', but should be '
+                'smaller than ' + str(err ** 0.5) + '), you should check the '
+                'component and network exergy data and check, if network is '
+                'properly setup for the exergy analysis.')
+            logger.error(msg)
+
+        self.create_group_data()
+
+    def evaluate_busses(self, cp):
+        """Evaluate the exergy balances of busses.
 
         Parameters
         ----------
-        c : tespy.connections.connection.Connection
-            Connection to perform initialisation on.
-
-        key : str
-            Fluid property to retrieve.
-
-        Returns
-        -------
-        val : float
-            Starting value for pressure/enthalpy in SI units.
-
-            .. math::
-
-                val = \begin{cases}
-                1 \cdot 10^5 & \text{key = 'p'}\\
-                \begin{cases}
-                5 \cdot 10^5 & \dot{Q} < 0\\
-                3 \cdot 10^5 & \dot{Q} = 0\\
-                1 \cdot 10^5 & \dot{Q} > 0
-                \end{cases} & \text{key = 'h'}\\
-                \end{cases}
-        """
-        if key == 'p':
-            return 1e5
-        elif key == 'h':
-            if self.Q.val < 0 and self.Q.is_set:
-                return 5e5
-            elif self.Q.val > 0 and self.Q.is_set:
-                return 1e5
-            else:
-                return 3e5
-
-    def calc_parameters(self):
-        r"""Postprocessing parameter calculation."""
-        i = self.inl[0].get_flow()
-        o = self.outl[0].get_flow()
-
-        self.Q.val = i[0] * (o[2] - i[2])
-        self.pr.val = o[1] / i[1]
-        self.zeta.val = ((i[1] - o[1]) * np.pi ** 2 / (
-            4 * i[0] ** 2 * (self.inl[0].vol.val_SI + self.outl[0].vol.val_SI)
-            ))
-
-        if self.Tamb.is_set:
-            ttd_1 = self.inl[0].T.val_SI - self.Tamb.val_SI
-            ttd_2 = self.outl[0].T.val_SI - self.Tamb.val_SI
-
-            if ttd_1 > ttd_2:
-                td_log = (ttd_1 - ttd_2) / np.log(ttd_1 / ttd_2)
-            elif ttd_1 < ttd_2:
-                td_log = (ttd_2 - ttd_1) / np.log(ttd_2 / ttd_1)
-            else:
-                td_log = np.nan
-
-            self.kA.val = abs(i[0] * (o[2] - i[2]) / td_log)
-            self.kA.is_result = True
-        else:
-            self.kA.is_result = False
-
-    def entropy_balance(self):
-        r"""
-        Calculate entropy balance of a simple heat exchanger.
+        cp : tespy.components.component.Component
+            Component to analyse the bus exergy balance of.
+        """
+        cp_on_num_busses = 0
+        for b in self.E_F + self.E_P + self.internal_busses + self.E_L:
+            if cp in b.comps.index:
+                if cp_on_num_busses > 0:
+                    msg = (
+                        'The component ' + cp.label + ' is on multiple '
+                        'busses in the exergy analysis. Make sure that no '
+                        'component is connected to more than one of the '
+                        'busses passed to the exergy_analysis method.')
+                    logger.error(msg)
+                    raise hlp.TESPyNetworkError(msg)
+                # todo: E_bus als dict mit den versch. werten
+                if b.comps.loc[cp, 'base'] == 'bus':
+                    E_bus = sum(e for e in cp.E_bus.values() if e)
+                    self.bus_data.loc[cp.label, 'E_P'] = E_bus
+                    bus_efficiency = cp.calc_bus_efficiency(b)
+                    E_F = E_bus / bus_efficiency
+                    self.bus_data.loc[cp.label, 'E_F'] = E_F
+
+                    if b in self.E_F:
+                        self.network_data.loc['E_F'] += E_F
+                    elif b in self.E_P:
+                        self.network_data.loc['E_P'] -= E_F
+                    elif b in self.E_L:
+                        self.network_data.loc['E_L'] -= E_F
+
+                    for key, value in cp.E_bus.items():
+                        if value == 0:
+                            continue
+
+                        if key != "massless":
+                            # this should be a source
+                            category = categorize_fluids(cp.outl[0])
+                        else:
+                            category = "work"
 
-        The allocation of the entropy streams due to heat exchanged and due to
-        irreversibility is performed by solving for T:
+                        if (cp.fkt_group, category) not in self.sankey_data[b.label].index:
+                            self.sankey_data[b.label].loc[(cp.fkt_group, category), :] = 0
 
-        .. math::
-
-            h_\mathrm{out} - h_\mathrm{in} = \int_\mathrm{out}^\mathrm{in}
-            v \cdot dp - \int_\mathrm{out}^\mathrm{in} T \cdot ds
-
-        As solving :math:`\int_\mathrm{out}^\mathrm{in} v \cdot dp` for non
-        isobaric processes would require perfect process knowledge (the path)
-        on how specific volume and pressure change throught the component, the
-        heat transfer is splitted into three separate virtual processes:
-
-        - in->in*: decrease pressure to
-          :math:`p_\mathrm{in*}=p_\mathrm{in}\cdot\sqrt{\frac{p_\mathrm{out}}{p_\mathrm{in}}}`
-          without changing enthalpy.
-        - in*->out* transfer heat without changing pressure.
-          :math:`h_\mathrm{out*}-h_\mathrm{in*}=h_\mathrm{out}-h_\mathrm{in}`
-        - out*->out decrease pressure to outlet pressure :math:`p_\mathrm{out}`
-          without changing enthalpy.
-
-        Note
-        ----
-        The entropy balance makes the follwing parameter available:
-
-        .. math::
-
-            \text{S\_Q}=\dot{m} \cdot \left(s_\mathrm{out*}-s_\mathrm{in*}
-            \right)\\
-            \text{S\_irr}=\dot{m} \cdot \left(s_\mathrm{out}-s_\mathrm{in}
-            \right) - \text{S\_Q}\\
-            \text{T\_mQ}=\frac{\dot{Q}}{\text{S\_Q}}
-        """
-        i = self.inl[0].get_flow()
-        o = self.outl[0].get_flow()
-
-        p1_star = i[1] * (o[1] / i[1]) ** 0.5
-        s1_star = s_mix_ph([0, p1_star, i[2], i[3]], T0=self.inl[0].T.val_SI)
-        s2_star = s_mix_ph([0, p1_star, o[2], o[3]], T0=self.outl[0].T.val_SI)
-        self.S_Q = i[0] * (s2_star - s1_star)
-        self.S_irr = i[0] * (
-            self.outl[0].s.val_SI - self.inl[0].s.val_SI) - self.S_Q
-        self.T_mQ = (o[2] - i[2]) / (s2_star - s1_star)
-
-    def exergy_balance(self, T0):
-        r"""
-        Calculate exergy balance of a simple heat exchanger.
-
-        The exergy of heat is calculated by allocation of thermal and
-        mechanical share of exergy in the physical exergy. Depending on the
-        temperature levels at the inlet and outlet of the heat exchanger as
-        well as the direction of heat transfer (input or output) fuel and
-        product exergy are calculated as follows.
-
-        Parameters
-        ----------
-        T0 : float
-            Ambient temperature T0 / K.
-
-        Note
-        ----
-        If the fluid transfers heat to the ambient, you can specify
-        :code:`mysimpleheatexchanger.set_attr(dissipative=False)` if you do
-        NOT want the exergy production nan (only applicable in case
-        :math:`\dot{Q}<0`).
-
-        .. math ::
-
-            \dot{E}_\mathrm{P} =
-            \begin{cases}
-            \begin{cases}
-            \begin{cases}
-            \text{not defined (nan)} & \text{if dissipative}\\
-            \dot{E}_\mathrm{in}^\mathrm{T} - \dot{E}_\mathrm{out}^\mathrm{T} &
-            \text{else}\\
-            \end{cases}
-            & T_\mathrm{in}, T_\mathrm{out} \geq T_0\\
-            \dot{E}_\mathrm{out}^\mathrm{T}
-            & T_\mathrm{in} \geq T_0 > T_\mathrm{out}\\
-            \dot{E}_\mathrm{out}^\mathrm{T} - \dot{E}_\mathrm{in}^\mathrm{T}
-            & T_0 \geq T_\mathrm{in}, T_\mathrm{out}\\
-            \end{cases} & \dot{Q} < 0\\
-
-            \begin{cases}
-            \dot{E}_\mathrm{out}^\mathrm{PH} - \dot{E}_\mathrm{in}^\mathrm{PH}
-            & T_\mathrm{in}, T_\mathrm{out} \geq T_0\\
-            \dot{E}_\mathrm{in}^\mathrm{T} + \dot{E}_\mathrm{out}^\mathrm{T}
-            & T_\mathrm{out} > T_0 \geq T_\mathrm{in}\\
-            \dot{E}_\mathrm{in}^\mathrm{T} - \dot{E}_\mathrm{out}^\mathrm{T} +
-            \dot{E}_\mathrm{out}^\mathrm{M} - \dot{E}_\mathrm{in}^\mathrm{M} +
-            & T_0 \geq T_\mathrm{in}, T_\mathrm{out}\\
-            \end{cases} & \dot{Q} > 0\\
-            \end{cases}
-
-            \dot{E}_\mathrm{F} =
-            \begin{cases}
-            \begin{cases}
-            \dot{E}_\mathrm{in}^\mathrm{PH} - \dot{E}_\mathrm{out}^\mathrm{PH}
-            & T_\mathrm{in}, T_\mathrm{out} \geq T_0\\
-            \dot{E}_\mathrm{in}^\mathrm{T} + \dot{E}_\mathrm{in}^\mathrm{M} +
-            \dot{E}_\mathrm{out}^\mathrm{T} - \dot{E}_\mathrm{out}^\mathrm{M}
-            & T_\mathrm{in} \geq T_0 > T_\mathrm{out}\\
-            \dot{E}_\mathrm{out}^\mathrm{T} - \dot{E}_\mathrm{in}^\mathrm{T} +
-            \dot{E}_\mathrm{in}^\mathrm{M} - \dot{E}_\mathrm{out}^\mathrm{M} +
-            & T_0 \geq T_\mathrm{in}, T_\mathrm{out}\\
-            \end{cases} & \dot{Q} < 0\\
-
-            \begin{cases}
-            \dot{E}_\mathrm{out}^\mathrm{T} - \dot{E}_\mathrm{in}^\mathrm{T}
-            & T_\mathrm{in}, T_\mathrm{out} \geq T_0\\
-            \dot{E}_\mathrm{in}^\mathrm{T} + \dot{E}_\mathrm{in}^\mathrm{M} -
-            \dot{E}_\mathrm{out}^\mathrm{M}
-            & T_\mathrm{out} > T_0 \geq T_\mathrm{in}\\
-            \dot{E}_\mathrm{in}^\mathrm{T}-\dot{E}_\mathrm{out}^\mathrm{T}
-            & T_0 \geq T_\mathrm{in}, T_\mathrm{out}\\
-            \end{cases} & \dot{Q} > 0\\
-            \end{cases}
-
-            \dot{E}_\mathrm{bus} =
-            \begin{cases}
-            \begin{cases}
-            \dot{E}_\mathrm{P} & \text{other cases}\\
-            \dot{E}_\mathrm{in}^\mathrm{T}
-            & T_\mathrm{in} \geq T_0 > T_\mathrm{out}\\
-            \end{cases} & \dot{Q} < 0\\
-            \dot{E}_\mathrm{F} & \dot{Q} > 0\\
-            \end{cases}
-        """
-        if self.Q.val < 0:
-            if self.inl[0].T.val_SI >= T0 and self.outl[0].T.val_SI >= T0:
-                if self.dissipative.val:
-                    self.E_P = np.nan
+                        self.sankey_data[b.label].loc[(cp.fkt_group, category), key] += value / bus_efficiency
                 else:
-                    self.E_P = self.inl[0].Ex_therm - self.outl[0].Ex_therm
-                self.E_F = self.inl[0].Ex_physical - self.outl[0].Ex_physical
-                self.E_bus = self.E_P
-            elif self.inl[0].T.val_SI >= T0 and self.outl[0].T.val_SI < T0:
-                self.E_P = self.outl[0].Ex_therm
-                self.E_F = self.inl[0].Ex_therm + self.outl[0].Ex_therm + (
-                    self.inl[0].Ex_mech - self.outl[0].Ex_mech)
-                self.E_bus = self.inl[0].Ex_therm + self.outl[0].Ex_therm
-            elif self.inl[0].T.val_SI <= T0 and self.outl[0].T.val_SI <= T0:
-                self.E_P = self.outl[0].Ex_therm - self.inl[0].Ex_therm
-                self.E_F = self.outl[0].Ex_therm - self.outl[0].Ex_therm + (
-                    self.inl[0].Ex_mech - self.outl[0].Ex_mech)
-                self.E_bus = self.E_P
-            else:
-                msg = ('Exergy balance of simple heat exchangers, where '
-                       'outlet temperature is higher than inlet temperature '
-                       'with heat extracted is not implmented.')
-                logging.warning(msg)
-                self.E_P = np.nan
-                self.E_F = np.nan
-                self.E_bus = np.nan
-        elif self.Q.val > 0:
-            if self.inl[0].T.val_SI >= T0 and self.outl[0].T.val_SI >= T0:
-                self.E_P = self.outl[0].Ex_physical - self.inl[0].Ex_physical
-                self.E_F = self.outl[0].Ex_therm - self.inl[0].Ex_therm
-                self.E_bus = self.E_F
-            elif self.inl[0].T.val_SI <= T0 and self.outl[0].T.val_SI > T0:
-                self.E_P = self.outl[0].Ex_therm + self.inl[0].Ex_therm
-                self.E_F = self.inl[0].Ex_therm + (
-                    self.inl[0].Ex_mech - self.outl[0].Ex_mech)
-                self.E_bus = self.inl[0].Ex_therm
-            elif self.inl[0].T.val_SI < T0 and self.outl[0].T.val_SI < T0:
-                self.E_P = self.inl[0].Ex_therm - self.outl[0].Ex_therm + (
-                    self.outl[0].Ex_mech - self.inl[0].Ex_mech)
-                self.E_F = self.inl[0].Ex_therm - self.outl[0].Ex_therm
-                self.E_bus = self.E_F
-            else:
-                msg = ('Exergy balance of simple heat exchangers, where '
-                       'inlet temperature is higher than outlet temperature '
-                       'with heat injected is not implmented.')
-                logging.warning(msg)
-                self.E_P = np.nan
-                self.E_F = np.nan
-                self.E_bus = self.E_F
-        else:
-            # this is basically the exergy balance of a valve
-            self.E_P = np.nan
-            self.E_F = self.inl[0].Ex_physical - self.outl[0].Ex_physical
-            self.E_bus = np.nan
+                    E_bus = sum(e for e in cp.E_bus.values() if e)
+                    bus_efficiency = cp.calc_bus_efficiency(b)
+                    E_P = E_bus * bus_efficiency
+                    self.bus_data.loc[cp.label, 'E_P'] = E_P
+                    self.bus_data.loc[cp.label, 'E_F'] = E_bus
+
+                    if b in self.E_F:
+                        self.network_data.loc['E_F'] -= E_P
+                    elif b in self.E_P:
+                        self.network_data.loc['E_P'] += E_P
+                    elif b in self.E_L:
+                        self.network_data.loc['E_L'] += E_P
+
+                    for key, value in cp.E_bus.items():
+                        if value == 0:
+                            continue
+
+                        if key != "massless":
+                            # this should be a sink
+                            category = categorize_fluids(cp.inl[0])
+                        else:
+                            category = "work"
+
+                        if (b.label, category) not in self.sankey_data[cp.fkt_group].index:
+                            self.sankey_data[cp.fkt_group].loc[(b.label, category), :] = 0
+
+                        self.sankey_data[cp.fkt_group].loc[(b.label, category), key] += value * bus_efficiency
+
+                self.bus_data.loc[cp.label, 'base'] = b.comps.loc[cp, 'base']
+                self.bus_data.loc[cp.label, 'group'] = cp.fkt_group
+
+                cp_on_num_busses += 1
+
+        self.bus_data['E_D'] = self.bus_data['E_F'] - self.bus_data['E_P']
+
+    def create_group_data(self):
+        """Collect the component group exergy data."""
+        for group in self.sankey_data.keys():
+            E_D = self.aggregation_data[
+                self.aggregation_data['group'] == group
+            ]['E_D'].sum()
+            self.sankey_data[group].loc[('E_D', "E_D"), :] = [0., 0., E_D]
+        # establish connections for fuel exergy via bus balance
+        for b in self.E_F:
+            input_value = self.calculate_group_input_value(b.label)
+            self.sankey_data['E_F'].loc[(b.label, "E_F"), self.exergy_cats] = (
+                self.sankey_data[b.label].loc[:, self.exergy_cats].sum()
+                - input_value.sum()
+            )
+
+        # establish connections for product exergy via bus balance
+        for b in self.E_P:
+            input_value = self.calculate_group_input_value(b.label)
+            self.sankey_data[b.label].loc[('E_P', "E_P"), self.exergy_cats] = (
+                input_value.sum()
+                - self.sankey_data[b.label].loc[:, self.exergy_cats].sum()
+            )
+
+        # establish connections for exergy loss via bus balance
+        for b in self.E_L:
+            input_value = self.calculate_group_input_value(b.label)
+            self.sankey_data[b.label].loc[('E_L', 'E_L'), self.exergy_cats] = (
+                input_value.sum()
+                - self.sankey_data[b.label].loc[:, self.exergy_cats].sum()
+            )
+
+        for fkt_group, data in self.sankey_data.items():
+            mask = self.component_data['group'] == fkt_group
+            comps = self.component_data.loc[mask].index
+            for comp in comps:
+                comp_obj = self.nw.get_comp(comp)
+                sources = self.nw.conns[self.nw.conns['source'] == comp_obj]
+                for conn in sources['object']:
+                    if conn.target.label not in comps:
+                        target_group = self.component_data.loc[conn.target.label, 'group']
+                        target_value_chemical = (
+                            conn.Ex_chemical
+                            if hasattr(conn, "Ex_chemical") else 0.
+                        )
+                        target_value_physical = conn.Ex_physical
+                        cat = categorize_fluids(conn)
+                        if (target_group, cat) in data.index:
+                            self.sankey_data[fkt_group].loc[
+                                (target_group, cat), 'physical'] += target_value_physical
+                            self.sankey_data[fkt_group].loc[
+                                (target_group, cat), 'chemical'] += target_value_chemical
+                        else:
+                            self.sankey_data[fkt_group].loc[(target_group, cat), :] = [
+                                target_value_chemical, target_value_physical, 0
+                            ]
+
+        # create overview of component groups
+        self.group_data = pd.DataFrame(
+            columns=['E_in', 'E_out', 'E_D'], dtype='float64'
+        )
 
-        if np.isnan(self.E_P):
-            self.E_D = self.E_F
+        for fkt_group in self.component_data['group'].unique():
+            self.group_data.loc[fkt_group, 'E_in'] = (
+                self.calculate_group_input_value(fkt_group).sum().sum()
+            )
+            self.group_data.loc[fkt_group, 'E_D'] = (
+                self.sankey_data[fkt_group].loc[idx['E_D', :], self.exergy_cats].sum().sum()
+            )
+
+        # calculate missing values
+        self.group_data['E_out'] = (
+            self.group_data['E_in'] - self.group_data['E_D'])
+        self.group_data['y_Dk'] = (
+            self.group_data['E_D'] / self.network_data.loc['E_F'])
+        self.group_data['y*_Dk'] = (
+            self.group_data['E_D'] / self.network_data.loc['E_D'])
+
+        # ToDo: Transform this into a test
+        # assert self.group_data['E_D'].sum() == self.network_data["E_D"]
+
+        return
+
+    def calculate_group_input_value(self, group_label):
+        """Calculate the total exergy input of a component group."""
+        value = pd.DataFrame(
+            columns=self.exergy_cats, index=[0], data=[[0., 0., 0.]]
+        )
+        for fkt_group, data in self.sankey_data.items():
+            if group_label in data.index:
+                value += data.loc[idx[group_label, :], self.exergy_cats].values
+        return value
+
+    def single_group_input(self, group_label, group_data):
+        """Calculate the total exergy input of a component group."""
+        inputs = []
+        for fkt_group, data in group_data.items():
+            if group_label in data.index.get_level_values("target_group") and fkt_group != group_label:
+                inputs += [fkt_group]
+
+        return inputs
+
+    def remove_transit_groups(self, group_data):
+        """Remove transit only component groups from sankey display.
+
+        Method is recursively called if a group was removed from display to
+        catch cases, where multiple groups are attached in line without
+        any streams leaving the line.
+
+        Parameters
+        ----------
+        group_data : dict
+            Dictionary containing the modified component group data.
+        """
+        for fkt_group in group_data.copy().keys():
+            if fkt_group in self.reserved_fkt_groups:
+                continue
+            source_groups = self.single_group_input(fkt_group, group_data)
+            if len(source_groups) == 1 and len(group_data[fkt_group].index.get_level_values("target_group").unique()) == 1:
+
+                source_group = source_groups[0]
+
+                group_data[source_group] = group_data[source_group].add(group_data[fkt_group], fill_value=0)
+                to_drop = group_data[source_group].index.get_level_values("target_group") == fkt_group
+                group_data[source_group] = group_data[source_group].loc[~to_drop]
+                del group_data[fkt_group]
+                # recursive call in case multiple components are attached in
+                # a line without any conversion
+                self.remove_transit_groups(group_data)
+                # exit to stop further iterations inside the groups
+                return
+            # remove groups without any connection
+            elif len(source_groups) == 0 and len(group_data[fkt_group]) == 0:
+                del group_data[fkt_group]
+
+    def generate_plotly_sankey_input(
+            self, node_order=[], colors={}, display_thresold=1e-3,
+            disaggregate_flows=False):
+        """Generate input data for sankey plots.
+
+        Only exergy flow above the display threshold is included. All
+        component groups with transit only (one input and one output) are cut
+        out of the display.
+
+        Parameters
+        ----------
+        node_order : list
+            Order for the nodes in the sankey diagram (optional).
+            In case no order is passed, a generic order will be used.
+
+        colors : dict
+            Dictionary containing a color for every stream type (optional).
+            Stream type is the key, the color is the corresponding value.
+            Stream types are:
+
+            - :code:`E_F`, :code:`E_P`, :code:`E_L`, :code:`E_D`
+            - names of the pure fluids of the tespy Network
+            - :code:`mix` (used in case of any gas mixture)
+            - labels of internal busses
+
+        display_threshold : float
+            Minimum value of flows to be displayed in the diagram, defaults to
+            1e-3.
+
+        disaggregate_flows : boolean
+            Separate every flow by chemical, physical and massless exergy,
+            defaults to False.
+
+        Returns
+        -------
+        tuple
+            Tuple containing the links and node_order for the plotly sankey
+            diagram.
+        """
+        group_data = self.sankey_data.copy()
+        cols = self.exergy_cats
+        for fkt_group, data in self.sankey_data.items():
+            mask = data.loc[:, cols].abs().sum(axis=1) >= display_thresold
+            group_data[fkt_group] = group_data[fkt_group].loc[mask]
+
+        self.remove_transit_groups(group_data)
+
+        if len(node_order) == 0:
+            node_order = (
+                ['E_F'] + [b.label for b in self.E_F] +
+                [fkt_group for fkt_group in self.group_data.index] +
+                [b.label for b in self.internal_busses + self.E_P + self.E_L] +
+                ['E_P', 'E_L', 'E_D']
+            )
         else:
-            self.E_D = self.E_F - self.E_P
-        self.epsilon = self.E_P / self.E_F
-
-    def get_plotting_data(self):
-        """Generate a dictionary containing FluProDia plotting information.
+            missing = []
+            for node in group_data.keys():
+                if node not in node_order:
+                    missing += [node]
+
+            if len(missing) > 0:
+                msg = (
+                    'The list of nodes passed is missing the following '
+                    'nodes: "' + '", "'.join(missing) + '".')
+                logger.error(msg)
+                raise ValueError(msg)
+
+        colordict = {
+            "E_F": "rgba(242, 142, 43, 0.90)",
+            "E_P": "rgba(118, 183, 178, 0.90)",
+            "E_D": "rgba(176, 122, 161, 0.90)",
+            "E_L": "rgba(156, 117, 95, 0.90)",
+            "combustion-gas": "rgba(237, 201, 72, 0.90)",
+            "non-combustion-gas": "rgba(186, 176, 172, 0.90)",
+            "two-phase-fluid": "rgba(89, 161, 79, 0.90)",
+            "incompressible": "rgba(255, 157, 167, 0.90)",
+            "work": "rgba(78, 121, 167, 0.90)",
+            "heat": "rgba(225, 87, 89, 0.90)",
+            np.nan: "rgba(100, 100, 100, 1.00)"
+        }
+        colordict.update(colors)
 
-        Returns
-        -------
-        data : dict
-            A nested dictionary containing the keywords required by the
-            :code:`calc_individual_isoline` method of the
-            :code:`FluidPropertyDiagram` class. First level keys are the
-            connection index ('in1' -> 'out1', therefore :code:`1` etc.).
-        """
-        return {
-            1: {
-                'isoline_property': 'p',
-                'isoline_value': self.inl[0].p.val,
-                'isoline_value_end': self.outl[0].p.val,
-                'starting_point_property': 's',
-                'starting_point_value': self.inl[0].s.val,
-                'ending_point_property': 's',
-                'ending_point_value': self.outl[0].s.val
-            }
+        links = {
+            'source': [],
+            'target': [],
+            'value': [],
+            'color': []
         }
+        for fkt_group, data in group_data.items():
+            source_id = node_order.index(fkt_group)
+            for target in data.index:
+                for col in cols:
+                    # how to aggregate here?
+                    if data.loc[target, col] > 0.:
+                        links['source'] += [source_id]
+                        links['target'] += [node_order.index(target[0])]
+                        links['value'] += [data.loc[target, col]]
+                        links['color'].append(colordict[target[1]])
+
+        return links, node_order
+
+    def print_results(
+            self, sort_desc=True,
+            busses=True, components=True, connections=True, groups=True,
+            network=True, aggregation=True):
+        r"""Print the results of the exergy analysis to prompt.
+
+        - The results are sorted beginning with the component having the
+          biggest exergy destruction by default.
+        - Components with an exergy destruction smaller than 1000 W is not
+          printed to prompt by default.
+
+        Parameters
+        ----------
+        sort_des : boolean
+            Sort the component results descending by exergy destruction.
+
+        busses : boolean
+            Print bus results, default value :code:`True`.
+
+        components : boolean
+            Print component results, default value :code:`True`.
+
+        connections : boolean
+            Print connection results, default value :code:`True`.
+
+        network : boolean
+            Print network results, default value :code:`True`.
+
+        aggregation : boolean
+            Print aggregated component results, default value :code:`True`.
+        """
+        if connections:
+            print('##### RESULTS: Connection specific physical exergy and ' +
+                  'chemical exergy #####')
+            print(tabulate(
+                self.connection_data, headers='keys',
+                tablefmt='psql', floatfmt='.3e'))
+
+        if components:
+            df = self.component_data.copy()
+            df = df.loc[:, df.columns != 'group']
+            if sort_desc:
+                df.sort_values(by=['E_D'], ascending=False, inplace=True)
+
+            print('##### RESULTS: Component exergy analysis #####')
+            print(tabulate(
+                df, headers='keys', tablefmt='psql', floatfmt='.3e'))
+
+        if busses:
+            df = self.bus_data.copy()
+            df = df.loc[:, (df.columns != 'group') & (df.columns != 'base')]
+            if sort_desc:
+                df.sort_values(by=['E_D'], ascending=False, inplace=True)
+
+            print('##### RESULTS: Bus exergy analysis #####')
+            print(tabulate(
+                df, headers='keys', tablefmt='psql', floatfmt='.3e'))
+
+        if aggregation:
+            df = self.aggregation_data.copy()
+            df = df.loc[:, df.columns != 'group']
+            if sort_desc:
+                df.sort_values(by=['E_D'], ascending=False, inplace=True)
+
+            print('##### RESULTS: Aggregation of components and busses #####')
+            print(tabulate(
+                df, headers='keys', tablefmt='psql', floatfmt='.3e'))
+
+        if network:
+            print('##### RESULTS: Network exergy analysis #####')
+            print(tabulate(
+                self.network_data.to_frame().transpose(),
+                headers='keys', tablefmt='psql', floatfmt='.3e',
+                showindex=False))
+
+        if groups:
+            df = self.group_data.copy()
+            if sort_desc:
+                df.sort_values(by=['E_D'], ascending=False, inplace=True)
+
+            print('##### RESULTS: Functional groups exergy flows #####')
+            print(tabulate(
+                df, headers='keys', tablefmt='psql', floatfmt='.3e'))
```

### Comparing `TESPy-0.6.2/src/tespy/components/heat_exchangers/solar_collector.py` & `TESPy-0.6.3/src/tespy/components/heat_exchangers/solar_collector.py`

 * *Files 1% similar despite different names*

```diff
@@ -9,37 +9,37 @@
 tespy/components/heat_exchangers/solar_collector.py
 
 SPDX-License-Identifier: MIT
 """
 
 import numpy as np
 
-from tespy.components.heat_exchangers.simple import HeatExchangerSimple
+from tespy.components.heat_exchangers.simple import SimpleHeatExchanger
 from tespy.tools.data_containers import ComponentProperties as dc_cp
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
 from tespy.tools.data_containers import GroupedComponentProperties as dc_gcp
+from tespy.tools.data_containers import SimpleDataContainer as dc_simple
 from tespy.tools.document_models import generate_latex_eq
 from tespy.tools.fluid_properties import T_mix_ph
 
 
-class SolarCollector(HeatExchangerSimple):
+class SolarCollector(SimpleHeatExchanger):
     r"""
     The solar collector calculates heat output from irradiance.
 
     **Mandatory Equations**
 
     - :py:meth:`tespy.components.component.Component.fluid_func`
     - :py:meth:`tespy.components.component.Component.mass_flow_func`
 
     **Optional Equations**
 
     - :py:meth:`tespy.components.component.Component.pr_func`
     - :py:meth:`tespy.components.component.Component.zeta_func`
-    - :py:meth:`tespy.components.heat_exchangers.simple.HeatExchangerSimple.energy_balance_func`
-    - :py:meth:`tespy.components.heat_exchangers.simple.HeatExchangerSimple.hydro_group_func`
+    - :py:meth:`tespy.components.heat_exchangers.simple.SimpleHeatExchanger.energy_balance_func`
+    - :py:meth:`tespy.components.heat_exchangers.simple.SimpleHeatExchanger.hydro_group_func`
     - :py:meth:`tespy.components.heat_exchangers.solar_collector.SolarCollector.energy_group_func`
 
     Inlets/Outlets
 
     - in1
     - out1
```

### Comparing `TESPy-0.6.2/src/tespy/components/nodes/droplet_separator.py` & `TESPy-0.6.3/src/tespy/components/nodes/droplet_separator.py`

 * *Files 0% similar despite different names*

```diff
@@ -361,48 +361,52 @@
         """
         self.jacobian[k, self.num_i, 1] = dh_mix_dpQ(self.outl[0].get_flow(), 0)
         self.jacobian[k, self.num_i, 2] = -1
         self.jacobian[k + 1, self.num_i + 1, 1] = (
             dh_mix_dpQ(self.outl[1].get_flow(), 1))
         self.jacobian[k + 1, self.num_i + 1, 2] = -1
 
-    def propagate_fluid_to_target(self, inconn, start):
+    def propagate_fluid_to_target(self, inconn, start, entry_point=False):
         r"""
         Propagate the fluids towards connection's target in recursion.
 
         Parameters
         ----------
         inconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
+        if not entry_point and inconn == start:
+            return
         for outconn in self.outl:
             for fluid, x in inconn.fluid.val.items():
                 if (outconn.fluid.val_set[fluid] is False and
                         outconn.good_starting_values is False):
                     outconn.fluid.val[fluid] = x
 
             outconn.target.propagate_fluid_to_target(outconn, start)
 
-    def propagate_fluid_to_source(self, outconn, start):
+    def propagate_fluid_to_source(self, outconn, start, entry_point=False):
         r"""
         Propagate the fluids towards connection's source in recursion.
 
         Parameters
         ----------
         outconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
+        if not entry_point and outconn == start:
+            return
         inconn = self.inl[0]
         for fluid, x in outconn.fluid.val.items():
             if (inconn.fluid.val_set[fluid] is False and
                     inconn.good_starting_values is False):
                 inconn.fluid.val[fluid] = x
 
         inconn.source.propagate_fluid_to_source(inconn, start)
```

### Comparing `TESPy-0.6.2/src/tespy/components/nodes/drum.py` & `TESPy-0.6.3/src/tespy/components/nodes/drum.py`

 * *Files 4% similar despite different names*

```diff
@@ -166,14 +166,18 @@
     def inlets():
         return ['in1', 'in2']
 
     @staticmethod
     def outlets():
         return ['out1', 'out2']
 
+    def preprocess(self, nw, num_eq=0):
+        super().preprocess(nw, num_eq)
+        self._propagation_start = False
+
     @staticmethod
     def initialise_source(c, key):
         r"""
         Return a starting value for pressure and enthalpy at outlet.
 
         Parameters
         ----------
@@ -234,59 +238,69 @@
             return 10e5
         elif key == 'h':
             if c.target_id == 'in1':
                 return h_mix_pQ(c.get_flow(), 0)
             else:
                 return h_mix_pQ(c.get_flow(), 0.7)
 
-    def propagate_fluid_to_target(self, inconn, start):
+    def propagate_fluid_to_target(self, inconn, start, entry_point=False):
         r"""
         Propagate the fluids towards connection's target in recursion.
 
         Parameters
         ----------
         inconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
-        if self != start:
-            start = self
-            for outconn in self.outl:
-                for fluid, x in inconn.fluid.val.items():
-                    if (outconn.fluid.val_set[fluid] is False and
-                            outconn.good_starting_values is False):
-                        outconn.fluid.val[fluid] = x
+        if (not entry_point and inconn == start) or self._propagation_start:
+            return
+
+        self._propagation_start = True
+
+        for outconn in self.outl:
+            for fluid, x in inconn.fluid.val.items():
+                if (outconn.fluid.val_set[fluid] is False and
+                        outconn.good_starting_values is False):
+                    outconn.fluid.val[fluid] = x
+
+            outconn.target.propagate_fluid_to_target(outconn, start)
 
-                outconn.target.propagate_fluid_to_target(outconn, start)
+        self._propagation_start = False
 
-    def propagate_fluid_to_source(self, outconn, start):
+    def propagate_fluid_to_source(self, outconn, start, entry_point=False):
         r"""
         Propagate the fluids towards connection's source in recursion.
 
         Parameters
         ----------
         outconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
-        if self != start:
-            start = self
-            for inconn in self.inl:
-                for fluid, x in outconn.fluid.val.items():
-                    if (inconn.fluid.val_set[fluid] is False and
-                            inconn.good_starting_values is False):
-                        inconn.fluid.val[fluid] = x
+        if (not entry_point and outconn == start) or self._propagation_start:
+            return
+
+        self._propagation_start = True
+
+        for inconn in self.inl:
+            for fluid, x in outconn.fluid.val.items():
+                if (inconn.fluid.val_set[fluid] is False and
+                        inconn.good_starting_values is False):
+                    inconn.fluid.val[fluid] = x
+
+            inconn.source.propagate_fluid_to_source(inconn, start)
 
-                inconn.source.propagate_fluid_to_source(inconn, start)
+        self._propagation_start = False
 
     def exergy_balance(self, T0):
         r"""
         Calculate exergy balance of a merge.
 
         Parameters
         ----------
@@ -301,15 +315,17 @@
 
             \dot{E}_\mathrm{P} = \sum \dot{E}_{\mathrm{out,}j}^\mathrm{PH}\\
             \dot{E}_\mathrm{F} = \sum \dot{E}_{\mathrm{in,}i}^\mathrm{PH}
         """
         self.E_P = self.outl[0].Ex_physical + self.outl[1].Ex_physical
         self.E_F = self.inl[0].Ex_physical + self.inl[1].Ex_physical
 
-        self.E_bus = np.nan
+        self.E_bus = {
+            "chemical": np.nan, "physical": np.nan, "massless": np.nan
+        }
         self.E_D = self.E_F - self.E_P
         self.epsilon = self.E_P / self.E_F
 
     def get_plotting_data(self):
         """
         Generate a dictionary containing FluProDia plotting information.
```

### Comparing `TESPy-0.6.2/src/tespy/components/nodes/merge.py` & `TESPy-0.6.3/src/tespy/components/nodes/merge.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 
 SPDX-License-Identifier: MIT
 """
 
 import numpy as np
 
 from tespy.components.nodes.base import NodeBase
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
+from tespy.tools.data_containers import SimpleDataContainer as dc_simple
 from tespy.tools.document_models import generate_latex_eq
 from tespy.tools.fluid_properties import s_mix_pT
 from tespy.tools.helpers import num_fluids
 
 
 class Merge(NodeBase):
     r"""
@@ -315,51 +315,52 @@
         if any(num_fl.values()) and not all(num_fl.values()):
             for conn, num in num_fl.items():
                 if num == 1:
                     ls += [conn]
 
             for c in ls:
                 for fluid in self.nw_fluids:
-                    for o in self.outl:
-                        if not o.fluid.val_set[fluid]:
-                            o.fluid.val[fluid] = c.fluid.val[fluid]
+                    if not self.outl[0].fluid.val_set[fluid]:
+                        self.outl[0].fluid.val[fluid] = c.fluid.val[fluid]
                     for i in self.inl:
                         if not i.fluid.val_set[fluid]:
                             i.fluid.val[fluid] = c.fluid.val[fluid]
-            for o in self.outl:
-                o.target.propagate_fluid_to_target(o, o.target)
+            self.outl[0].target.propagate_fluid_to_target(o, o, entry_point=True)
 
-    def propagate_fluid_to_target(self, inconn, start):
+    def propagate_fluid_to_target(self, inconn, start, entry_point=False):
         r"""
         Fluid propagation stops here.
 
         Parameters
         ----------
         inconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
         return
 
-    def propagate_fluid_to_source(self, outconn, start):
+    def propagate_fluid_to_source(self, outconn, start, entry_point=False):
         r"""
         Propagate the fluids towards connection's source in recursion.
 
         Parameters
         ----------
         outconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
+        if not entry_point and outconn == start:
+            return
+
         for inconn in self.inl:
             for fluid, x in outconn.fluid.val.items():
                 if (not inconn.fluid.val_set[fluid] and
                         not inconn.good_starting_values):
                     inconn.fluid.val[fluid] = x
 
             inconn.source.propagate_fluid_to_source(inconn, start)
@@ -487,15 +488,17 @@
                     else:
                         self.E_P += i.m.val_SI * (
                             self.outl[0].ex_physical - i.ex_physical)
                 else:
                     self.E_F += i.m.val_SI * (
                         i.ex_physical - self.outl[0].ex_physical)
 
-        self.E_bus = np.nan
+        self.E_bus = {
+            "chemical": np.nan, "physical": np.nan, "massless": np.nan
+        }
         self.E_D = self.E_F - self.E_P
         self.epsilon = self.E_P / self.E_F
 
     def get_plotting_data(self):
         """Generate a dictionary containing FluProDia plotting information.
 
         Returns
```

### Comparing `TESPy-0.6.2/src/tespy/components/nodes/separator.py` & `TESPy-0.6.3/src/tespy/components/nodes/separator.py`

 * *Files 3% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 
 SPDX-License-Identifier: MIT
 """
 
 import numpy as np
 
 from tespy.components.nodes.base import NodeBase
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
+from tespy.tools.data_containers import SimpleDataContainer as dc_simple
 from tespy.tools.document_models import generate_latex_eq
 from tespy.tools.fluid_properties import T_mix_ph
 from tespy.tools.fluid_properties import dT_mix_dph
 from tespy.tools.fluid_properties import dT_mix_pdh
 from tespy.tools.fluid_properties import dT_mix_ph_dfluid
 
 
@@ -312,30 +312,30 @@
             self.jacobian[k, 0, 3:] = dT_dfluid_in
             self.jacobian[k, j + 1, 1] = -dT_mix_dph(o)
             self.jacobian[k, j + 1, 2] = -dT_mix_pdh(o)
             self.jacobian[k, j + 1, 3:] = -np.array(dT_mix_ph_dfluid(o))
             j += 1
             k += 1
 
-    def propagate_fluid_to_target(self, inconn, start):
+    def propagate_fluid_to_target(self, inconn, start, entry_point=False):
         r"""
         Fluid propagation stops here.
 
         Parameters
         ----------
         inconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
         return
 
-    def propagate_fluid_to_source(self, outconn, start):
+    def propagate_fluid_to_source(self, outconn, start, entry_point=False):
         r"""
         Propagate the fluids towards connection's source in recursion.
 
         Parameters
         ----------
         outconn : tespy.connections.connection.Connection
             Connection to initialise.
```

### Comparing `TESPy-0.6.2/src/tespy/components/nodes/splitter.py` & `TESPy-0.6.3/src/tespy/components/nodes/splitter.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,15 @@
 
 SPDX-License-Identifier: MIT
 """
 
 import numpy as np
 
 from tespy.components.nodes.base import NodeBase
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
+from tespy.tools.data_containers import SimpleDataContainer as dc_simple
 from tespy.tools.document_models import generate_latex_eq
 
 
 class Splitter(NodeBase):
     r"""
     Split up a mass flow in parts of identical enthalpy and fluid composition.
 
@@ -156,14 +156,18 @@
     def outlets(self):
         if self.num_out.is_set:
             return ['out' + str(i + 1) for i in range(self.num_out.val)]
         else:
             self.set_attr(num_out=2)
             return self.outlets()
 
+    def preprocess(self, nw, num_eq=0):
+        super().preprocess(nw, num_eq)
+        self._propagation_start = False
+
     def fluid_func(self):
         r"""
         Calculate the vector of residual values for fluid balance equations.
 
         Returns
         -------
         residual : list
@@ -267,48 +271,57 @@
         k = 0
         for o in self.outl:
             deriv[k, 0, 2] = 1
             deriv[k, k + 1, 2] = -1
             k += 1
         return deriv
 
-    def propagate_fluid_to_target(self, inconn, start):
+    def propagate_fluid_to_target(self, inconn, start, entry_point=False):
         r"""
         Propagate the fluids towards connection's target in recursion.
 
         Parameters
         ----------
         inconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
+        if not entry_point and inconn == start:
+            return
         for outconn in self.outl:
             for fluid, x in inconn.fluid.val.items():
-                if (outconn.fluid.val_set[fluid] is False and
-                        outconn.good_starting_values is False):
+                if (not outconn.fluid.val_set[fluid] and
+                        not outconn.good_starting_values):
                     outconn.fluid.val[fluid] = x
 
             outconn.target.propagate_fluid_to_target(outconn, start)
 
-    def propagate_fluid_to_source(self, outconn, start):
+    def propagate_fluid_to_source(self, outconn, start, entry_point=False):
         r"""
         Propagate the fluids towards connection's source in recursion.
 
         Parameters
         ----------
         outconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
+        if (not entry_point and outconn == start) or self._propagation_start:
+            return
+
+        self._propagation_start = True
+
         inconn = self.inl[0]
         for fluid, x in outconn.fluid.val.items():
             if (inconn.fluid.val_set[fluid] is False and
                     inconn.good_starting_values is False):
                 inconn.fluid.val[fluid] = x
 
         inconn.source.propagate_fluid_to_source(inconn, start)
+
+        self._propagation_start = False
```

### Comparing `TESPy-0.6.2/src/tespy/components/piping/pipe.py` & `TESPy-0.6.3/src/tespy/components/piping/pipe.py`

 * *Files 7% similar despite different names*

```diff
@@ -6,34 +6,34 @@
 This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
 by the contributors recorded in the version control history of the file,
 available from its original location tespy/components/piping/pipe.py
 
 SPDX-License-Identifier: MIT
 """
 
-from tespy.components.heat_exchangers.simple import HeatExchangerSimple
+from tespy.components.heat_exchangers.simple import SimpleHeatExchanger
 
 
-class Pipe(HeatExchangerSimple):
+class Pipe(SimpleHeatExchanger):
     r"""
-    The Pipe is a subclass of a HeatExchangerSimple.
+    The Pipe is a subclass of a SimpleHeatExchanger.
 
     **Mandatory Equations**
 
     - :py:meth:`tespy.components.component.Component.fluid_func`
     - :py:meth:`tespy.components.component.Component.mass_flow_func`
 
     **Optional Equations**
 
     - :py:meth:`tespy.components.component.Component.pr_func`
     - :py:meth:`tespy.components.component.Component.zeta_func`
-    - :py:meth:`tespy.components.heat_exchangers.simple.HeatExchangerSimple.energy_balance_func`
-    - :py:meth:`tespy.components.heat_exchangers.simple.HeatExchangerSimple.hydro_group_func`
-    - :py:meth:`tespy.components.heat_exchangers.simple.HeatExchangerSimple.kA_group_func`
-    - :py:meth:`tespy.components.heat_exchangers.simple.HeatExchangerSimple.kA_char_group_func`
+    - :py:meth:`tespy.components.heat_exchangers.simple.SimpleHeatExchanger.energy_balance_func`
+    - :py:meth:`tespy.components.heat_exchangers.simple.SimpleHeatExchanger.hydro_group_func`
+    - :py:meth:`tespy.components.heat_exchangers.simple.SimpleHeatExchanger.kA_group_func`
+    - :py:meth:`tespy.components.heat_exchangers.simple.SimpleHeatExchanger.kA_char_group_func`
 
     Inlets/Outlets
 
     - in1
     - out1
 
     Image
```

### Comparing `TESPy-0.6.2/src/tespy/components/piping/valve.py` & `TESPy-0.6.3/src/tespy/components/piping/valve.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,19 +6,18 @@
 This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
 by the contributors recorded in the version control history of the file,
 available from its original location tespy/components/piping.py
 
 SPDX-License-Identifier: MIT
 """
 
-import logging
-
 import numpy as np
 
 from tespy.components.component import Component
+from tespy.tools import logger
 from tespy.tools.data_containers import ComponentCharacteristics as dc_cc
 from tespy.tools.data_containers import ComponentProperties as dc_cp
 from tespy.tools.document_models import generate_latex_eq
 
 
 class Valve(Component):
     r"""
@@ -193,15 +192,15 @@
                 0=p_\mathrm{in}-p_\mathrm{out}-f\left( expr \right)
         """
         p = self.dp_char.param
         expr = self.get_char_expr(p, **self.dp_char.char_params)
         if not expr:
             msg = ('Please choose a valid parameter, you want to link the '
                    'pressure drop to at component ' + self.label + '.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         return (
             self.inl[0].p.val_SI - self.outl[0].p.val_SI -
             self.dp_char.char_func.evaluate(expr))
 
     def dp_char_func_doc(self, label):
@@ -219,15 +218,15 @@
             LaTeX code of equations applied.
         """
         p = self.dp_char.param
         expr = self.get_char_expr_doc(p, **self.dp_char.char_params)
         if not expr:
             msg = ('Please choose a valid parameter, you want to link the '
                    'pressure drop to at component ' + self.label + '.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         latex = (
             r'0=p_\mathrm{in}-p_\mathrm{out}-f\left(' + expr +
             r'\right)')
         return generate_latex_eq(self, latex, label)
 
@@ -381,19 +380,21 @@
                 self.inl[0].Ex_mech - self.outl[0].Ex_mech)
         elif self.inl[0].T.val_SI <= T0 and self.outl[0].T.val_SI <= T0:
             self.E_P = self.outl[0].Ex_therm - self.inl[0].Ex_therm
             self.E_F = self.inl[0].Ex_mech - self.outl[0].Ex_mech
         else:
             msg = ('Exergy balance of a valve, where outlet temperature is '
                    'larger than inlet temperature is not implmented.')
-            logging.warning(msg)
+            logger.warning(msg)
             self.E_P = np.nan
             self.E_F = np.nan
 
-        self.E_bus = np.nan
+        self.E_bus = {
+            "chemical": np.nan, "physical": np.nan, "massless": np.nan
+        }
         if np.isnan(self.E_P):
             self.E_D = self.E_F
         else:
             self.E_D = self.E_F - self.E_P
         self.epsilon = self.E_P / self.E_F
 
     def get_plotting_data(self):
```

### Comparing `TESPy-0.6.2/src/tespy/components/reactors/fuel_cell.py` & `TESPy-0.6.3/src/tespy/components/reactors/fuel_cell.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,13 +1,26 @@
-import logging
+# -*- coding: utf-8
+
+"""Module of class FuelCell.
+
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location
+tespy/components/reactors/fuel_cell.py
+
+SPDX-License-Identifier: MIT
+"""
+
 
 import CoolProp.CoolProp as CP
 import numpy as np
 
 from tespy.components.component import Component
+from tespy.tools import logger
 from tespy.tools.data_containers import ComponentProperties as dc_cp
 from tespy.tools.document_models import generate_latex_eq
 from tespy.tools.fluid_properties import h_mix_pT
 from tespy.tools.global_vars import molar_masses
 from tespy.tools.helpers import TESPyComponentError
 
 
@@ -203,22 +216,22 @@
         return ['in1', 'in2', 'in3']
 
     def outlets(self):
         return ['out1', 'out2']
 
 # %% Equations and derivatives
 
-    def comp_init(self, nw):
+    def preprocess(self, nw):
 
         if not self.P.is_set:
             self.set_attr(P='var')
             msg = ('The power output of a fuel cell must be set! '
                    'We are adding the power output of component ' +
                    self.label + ' as custom variable of the system.')
-            logging.info(msg)
+            logger.info(msg)
 
         for fluid in ['H2', 'H2O', 'O2']:
             try:
                 setattr(
                     self, fluid, [x for x in nw.fluids if x in [
                         a.replace(' ', '') for a in
                         CP.get_aliases(fluid.upper())
@@ -227,20 +240,20 @@
                 msg = (
                     'The component ' + self.label + ' (class ' +
                     self.__class__.__name__ + ') requires that the fluid '
                     '[fluid] is in the network\'s list of fluids.')
                 aliases = ', '.join(CP.get_aliases(fluid.upper()))
                 msg = msg.replace(
                     '[fluid]', fluid.upper() + ' (aliases: ' + aliases + ')')
-                logging.error(msg)
+                logger.error(msg)
                 raise TESPyComponentError(msg)
 
         self.e0 = self.calc_e0()
 
-        Component.comp_init(self, nw)
+        super().preprocess(nw)
 
     def calc_e0(self):
         r"""
         Calculate the specific energy output of the fuel cell.
 
         Returns
         -------
@@ -907,50 +920,55 @@
         if key == 'p':
             return 5e5
         elif key == 'h':
             flow = c.get_flow()
             T = 50 + 273.15
             return h_mix_pT(flow, T)
 
-    def propagate_fluid_to_target(self, inconn, start):
+    def propagate_fluid_to_target(self, inconn, start, entry_point=False):
         r"""
         Propagate the fluids towards connection's target in recursion.
 
         Parameters
         ----------
         inconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
+        if not entry_point and inconn == start:
+            return
         if inconn == self.inl[0]:
             outconn = self.outl[0]
 
             for fluid, x in inconn.fluid.val.items():
                 if (outconn.fluid.val_set[fluid] is False and
                         outconn.good_starting_values is False):
                     outconn.fluid.val[fluid] = x
 
             outconn.target.propagate_fluid_to_target(outconn, start)
 
-    def propagate_fluid_to_source(self, outconn, start):
+    def propagate_fluid_to_source(self, outconn, start, entry_point=False):
         r"""
         Propagate the fluids towards connection's source in recursion.
 
         Parameters
         ----------
         outconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
+        if not entry_point and outconn == start:
+            return
+
         if outconn == self.outl[0]:
             inconn = self.inl[0]
 
             for fluid, x in outconn.fluid.val.items():
                 if (inconn.fluid.val_set[fluid] is False and
                         inconn.good_starting_values is False):
                     inconn.fluid.val[fluid] = x
```

### Comparing `TESPy-0.6.2/src/tespy/components/reactors/water_electrolyzer.py` & `TESPy-0.6.3/src/tespy/components/reactors/water_electrolyzer.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,20 +7,19 @@
 by the contributors recorded in the version control history of the file,
 available from its original location
 tespy/components/reactors/water_electrolyzer.py
 
 SPDX-License-Identifier: MIT
 """
 
-import logging
-
 import CoolProp.CoolProp as CP
 import numpy as np
 
 from tespy.components.component import Component
+from tespy.tools import logger
 from tespy.tools.data_containers import ComponentCharacteristics as dc_cc
 from tespy.tools.data_containers import ComponentProperties as dc_cp
 from tespy.tools.document_models import generate_latex_eq
 from tespy.tools.fluid_properties import T_mix_ph
 from tespy.tools.fluid_properties import dT_mix_dph
 from tespy.tools.fluid_properties import dT_mix_pdh
 from tespy.tools.fluid_properties import h_mix_pT
@@ -257,22 +256,22 @@
     def inlets():
         return ['in1', 'in2']
 
     @staticmethod
     def outlets():
         return ['out1', 'out2', 'out3']
 
-    def comp_init(self, nw):
+    def preprocess(self, nw):
 
         if not self.P.is_set:
             self.set_attr(P='var')
             msg = ('The power input of a water electrolyzer must be set! '
                    'We are adding the power input of component ' +
                    self.label + ' as custom variable of the system.')
-            logging.info(msg)
+            logger.info(msg)
 
         for fluid in ['o2', 'h2o', 'h2']:
             try:
                 setattr(
                     self, fluid, [x for x in nw.fluids if x in [
                         a.replace(' ', '') for a in
                         CP.get_aliases(fluid.upper())
@@ -281,20 +280,20 @@
                 msg = (
                     'The component ' + self.label + ' (class ' +
                     self.__class__.__name__ + ') requires that the fluid '
                     '[fluid] is in the network\'s list of fluids.')
                 aliases = ', '.join(CP.get_aliases(fluid.upper()))
                 msg = msg.replace(
                     '[fluid]', fluid.upper() + ' (aliases: ' + aliases + ')')
-                logging.error(msg)
+                logger.error(msg)
                 raise TESPyComponentError(msg)
 
         self.e0 = self.calc_e0()
 
-        Component.comp_init(self, nw)
+        super().preprocess(nw)
 
     def calc_e0(self):
         r"""
         Calculate the minimum specific energy required for electrolysis.
 
         Returns
         -------
@@ -642,15 +641,15 @@
                 f\left(expr \right)}
         """
         p = self.eta_char.param
         expr = self.get_char_expr(p, **self.eta_char.char_params)
         if not expr:
             msg = ('Please choose a valid parameter, you want to link the '
                    'efficiency to at component ' + self.label + '.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         return (
             self.P.val - self.outl[2].m.val_SI * self.e0 /
             (self.eta.design * self.eta_char.char_func.evaluate(expr)))
 
     def eta_char_func_doc(self, label):
@@ -668,15 +667,15 @@
             LaTeX code of equations applied.
         """
         p = self.eta_char.param
         expr = self.get_char_expr_doc(p, **self.eta_char.char_params)
         if not expr:
             msg = ('Please choose a valid parameter, you want to link the '
                    'efficiency to at component ' + self.label + '.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         latex = (
             r'0=P-\dot{m}_\mathrm{H_2,out,3}\cdot\frac{e_0}'
             r'{\eta_\mathrm{design}\cdot f\left(X\right)}')
         return generate_latex_eq(self, latex, label)
 
@@ -1057,15 +1056,15 @@
         # missing/invalid bus parameter
 
         else:
             msg = ('The parameter ' + str(bus['param']) + ' is not a valid '
                    'parameter for a component of type ' + self.component() +
                    '. Please specify a bus parameter (P/Q) for component ' +
                    self.label + '.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         return val
 
     def bus_func_doc(self, bus):
         r"""
         Return LaTeX string of the bus function.
@@ -1138,15 +1137,15 @@
         # missing/invalid bus parameter
 
         else:
             msg = ('The parameter ' + str(b['param']) + ' is not a valid '
                    'parameter for a component of type ' + self.component() +
                    '. Please specify a bus parameter (P/Q) for component ' +
                    self.label + '.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         return deriv
 
     def initialise_fluids(self):
         """Set values to pure fluid on water inlet and gas outlets."""
         self.outl[1].fluid.val[self.o2] = 1
@@ -1215,50 +1214,55 @@
         if key == 'p':
             return 5e5
         elif key == 'h':
             flow = c.get_flow()
             T = 20 + 273.15
             return h_mix_pT(flow, T)
 
-    def propagate_fluid_to_target(self, inconn, start):
+    def propagate_fluid_to_target(self, inconn, start, entry_point=False):
         r"""
         Propagate the fluids towards connection's target in recursion.
 
         Parameters
         ----------
         inconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
+        if not entry_point and inconn == start:
+            return
         if inconn == self.inl[0]:
             outconn = self.outl[0]
 
             for fluid, x in inconn.fluid.val.items():
                 if (outconn.fluid.val_set[fluid] is False and
                         outconn.good_starting_values is False):
                     outconn.fluid.val[fluid] = x
 
             outconn.target.propagate_fluid_to_target(outconn, start)
 
-    def propagate_fluid_to_source(self, outconn, start):
+    def propagate_fluid_to_source(self, outconn, start, entry_point=False):
         r"""
         Propagate the fluids towards connection's source in recursion.
 
         Parameters
         ----------
         outconn : tespy.connections.connection.Connection
             Connection to initialise.
 
         start : tespy.components.component.Component
             This component is the fluid propagation starting point.
             The starting component is saved to prevent infinite looping.
         """
+        if not entry_point and outconn == start:
+            return
+
         if outconn == self.outl[0]:
             inconn = self.inl[0]
 
             for fluid, x in outconn.fluid.val.items():
                 if (inconn.fluid.val_set[fluid] is False and
                         inconn.good_starting_values is False):
                     inconn.fluid.val[fluid] = x
@@ -1274,7 +1278,19 @@
         self.eta.val = self.e0 / self.e.val
 
         i = self.inl[0].get_flow()
         o = self.outl[0].get_flow()
         self.zeta.val = ((i[1] - o[1]) * np.pi ** 2 / (
             4 * i[0] ** 2 * (self.inl[0].vol.val_SI + self.outl[0].vol.val_SI)
             ))
+
+    def exergy_balance(self, T0):
+        self.E_P = (
+            self.outl[1].Ex_chemical + self.outl[2].Ex_chemical
+            - self.inl[1].Ex_chemical + self.outl[0].Ex_physical
+            + self.inl[0].Ex_physical
+        )
+        self.E_F = self.P.val
+
+        self.E_D = self.E_F - self.E_P
+        self.epsilon = self.E_P/self.E_F
+        self.E_bus = self.P.val
```

### Comparing `TESPy-0.6.2/src/tespy/components/subsystem.py` & `TESPy-0.6.3/src/tespy/components/subsystem.py`

 * *Files 16% similar despite different names*

```diff
@@ -1,89 +1,89 @@
-# -*- coding: utf-8
-
-"""Module for custom component groups.
-
-It is possible to create subsystems of component groups in tespy. The subsystem
-class is the base class for custom subsystems.
-
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location tespy/components/subsystems.py
-
-SPDX-License-Identifier: MIT
-"""
-
-import logging
-
-# %%
-
-
-class Subsystem:
-    r"""
-    Class Subsystem is the base class of all TESPy subsystems.
-
-    Parameters
-    ----------
-    label : str
-        The label of the subsystem.
-
-    Example
-    -------
-    Basic example for a setting up a Subsystem object. This example does not
-    run a TESPy calculation!
-
-    >>> from tespy.components import Subsystem
-    >>> mysub = Subsystem('mySubsystem')
-    >>> type(mysub)
-    <class 'tespy.components.subsystem.Subsystem'>
-    >>> mysub.get_attr('label')
-    'mySubsystem'
-    """
-
-    def __init__(self, label):
-
-        if not isinstance(label, str):
-            msg = 'Subsystem label must be of type str!'
-            logging.error(msg)
-            raise ValueError(msg)
-
-        elif len([x for x in [';', ', ', '.'] if x in label]) > 0:
-            msg = 'Can\'t use ' + str([';', ', ', '.']) + ' in label.'
-            logging.error(msg)
-            raise ValueError(msg)
-        else:
-            self.label = label
-
-        self.comps = {}
-        self.conns = {}
-        self.create_comps()
-        self.create_conns()
-
-    def get_attr(self, key):
-        r"""
-        Get the value of a subsystem's attribute.
-
-        Parameters
-        ----------
-        key : str
-            The attribute you want to retrieve.
-
-        Returns
-        -------
-        out :
-            Value of specified attribute.
-        """
-        if key in self.__dict__:
-            return self.__dict__[key]
-        else:
-            msg = 'Subsystem ' + self.label + ' has no attribute ' + key + '.'
-            logging.error(msg)
-            raise KeyError(msg)
-
-    def create_comps(self):
-        """Create the subsystem's components."""
-        return
-
-    def create_conns(self):
-        """Create the subsystem's connections."""
-        return
+# -*- coding: utf-8
+
+"""Module for custom component groups.
+
+It is possible to create subsystems of component groups in tespy. The subsystem
+class is the base class for custom subsystems.
+
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location tespy/components/subsystems.py
+
+SPDX-License-Identifier: MIT
+"""
+
+from tespy.tools import logger
+
+# %%
+
+
+class Subsystem:
+    r"""
+    Class Subsystem is the base class of all TESPy subsystems.
+
+    Parameters
+    ----------
+    label : str
+        The label of the subsystem.
+
+    Example
+    -------
+    Basic example for a setting up a Subsystem object. This example does not
+    run a TESPy calculation!
+
+    >>> from tespy.components import Subsystem
+    >>> mysub = Subsystem('mySubsystem')
+    >>> type(mysub)
+    <class 'tespy.components.subsystem.Subsystem'>
+    >>> mysub.get_attr('label')
+    'mySubsystem'
+    """
+
+    def __init__(self, label):
+
+        if not isinstance(label, str):
+            msg = 'Subsystem label must be of type str!'
+            logger.error(msg)
+            raise ValueError(msg)
+
+        elif len([x for x in [';', ', ', '.'] if x in label]) > 0:
+            msg = 'Can\'t use ' + str([';', ', ', '.']) + ' in label.'
+            logger.error(msg)
+            raise ValueError(msg)
+        else:
+            self.label = label
+
+        self.comps = {}
+        self.conns = {}
+        self.create_comps()
+        self.create_conns()
+
+    def get_attr(self, key):
+        r"""
+        Get the value of a subsystem's attribute.
+
+        Parameters
+        ----------
+        key : str
+            The attribute you want to retrieve.
+
+        Returns
+        -------
+        out :
+            Value of specified attribute.
+        """
+        if key in self.__dict__:
+            return self.__dict__[key]
+        else:
+            msg = 'Subsystem ' + self.label + ' has no attribute ' + key + '.'
+            logger.error(msg)
+            raise KeyError(msg)
+
+    def create_comps(self):
+        """Create the subsystem's components."""
+        return
+
+    def create_conns(self):
+        """Create the subsystem's connections."""
+        return
```

### Comparing `TESPy-0.6.2/src/tespy/components/turbomachinery/base.py` & `TESPy-0.6.3/src/tespy/components/turbomachinery/base.py`

 * *Ordering differences only*

 * *Files 16% similar despite different names*

```diff
@@ -1,262 +1,262 @@
-# -*- coding: utf-8
-
-"""Module of class Turbomachine.
-
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location
-tespy/components/turbomachinery/base.py
-
-SPDX-License-Identifier: MIT
-"""
-
-import numpy as np
-
-from tespy.components.component import Component
-from tespy.tools.data_containers import ComponentProperties as dc_cp
-from tespy.tools.document_models import generate_latex_eq
-
-
-class Turbomachine(Component):
-    r"""
-    Parent class for compressor, pump and turbine.
-
-    **Mandatory Equations**
-
-    - :py:meth:`tespy.components.component.Component.fluid_func`
-    - :py:meth:`tespy.components.component.Component.mass_flow_func`
-
-    **Optional Equations**
-
-    - :py:meth:`tespy.components.component.Component.pr_func`
-    - :py:meth:`tespy.components.turbomachinery.base.base.energy_balance_func`
-
-    Inlets/Outlets
-
-    - in1
-    - out1
-
-    Parameters
-    ----------
-    label : str
-        The label of the component.
-
-    design : list
-        List containing design parameters (stated as String).
-
-    offdesign : list
-        List containing offdesign parameters (stated as String).
-
-    design_path : str
-        Path to the components design case.
-
-    local_offdesign : boolean
-        Treat this component in offdesign mode in a design calculation.
-
-    local_design : boolean
-        Treat this component in design mode in an offdesign calculation.
-
-    char_warnings : boolean
-        Ignore warnings on default characteristics usage for this component.
-
-    printout : boolean
-        Include this component in the network's results printout.
-
-    P : float, dict
-        Power, :math:`P/\text{W}`
-
-    pr : float, dict, :code:`"var"`
-        Outlet to inlet pressure ratio, :math:`pr/1`
-
-    Example
-    -------
-    For an example please refer to:
-
-    - :class:`tespy.components.turbomachinery.compressor.Compressor`
-    - :class:`tespy.components.turbomachinery.pump.Pump`
-    - :class:`tespy.components.turbomachinery.turbine.Turbine`
-    """
-
-    @staticmethod
-    def component():
-        return 'turbomachine'
-
-    def get_variables(self):
-        return {
-            'P': dc_cp(
-                deriv=self.energy_balance_deriv, num_eq=1,
-                func=self.energy_balance_func,
-                latex=self.energy_balance_func_doc),
-            'pr': dc_cp(
-                deriv=self.pr_deriv, num_eq=1,
-                func=self.pr_func, func_params={'pr': 'pr'},
-                latex=self.pr_func_doc)
-        }
-
-    @staticmethod
-    def inlets():
-        return ['in1']
-
-    @staticmethod
-    def outlets():
-        return ['out1']
-
-    def energy_balance_func(self):
-        r"""
-        Calculate energy balance of a turbomachine.
-
-        Returns
-        -------
-        residual : float
-            Residual value of turbomachine energy balance
-
-            .. math::
-
-                0=\dot{m}_{in}\cdot\left(h_{out}-h_{in}\right)-P
-        """
-        return self.inl[0].m.val_SI * (
-            self.outl[0].h.val_SI - self.inl[0].h.val_SI) - self.P.val
-
-    def energy_balance_func_doc(self, label):
-        r"""
-        Calculate energy balance of a turbomachine.
-
-        Parameters
-        ----------
-        label : str
-            Label for equation.
-
-        Returns
-        -------
-        latex : str
-            LaTeX code of equations applied.
-        """
-        latex = (
-            r'0=\dot{m}_\mathrm{in}\cdot\left(h_\mathrm{out}-h_\mathrm{in}'
-            r'\right)-P')
-        return generate_latex_eq(self, latex, label)
-
-    def energy_balance_deriv(self, increment_filter, k):
-        r"""
-        Calculate partial derivatives of energy balance of a turbomachine.
-
-        Parameters
-        ----------
-        increment_filter : ndarray
-            Matrix for filtering non-changing variables.
-
-        k : int
-            Position of derivatives in Jacobian matrix (k-th equation).
-        """
-        self.jacobian[k, 0, 0] = self.outl[0].h.val_SI - self.inl[0].h.val_SI
-        self.jacobian[k, 0, 2] = -self.inl[0].m.val_SI
-        self.jacobian[k, 1, 2] = self.inl[0].m.val_SI
-
-    def bus_func(self, bus):
-        r"""
-        Calculate the value of the bus function.
-
-        Parameters
-        ----------
-        bus : tespy.connections.bus.Bus
-            TESPy bus object.
-
-        Returns
-        -------
-        residual : float
-            Value of energy transfer :math:`\dot{E}`. This value is passed to
-            :py:meth:`tespy.components.component.Component.calc_bus_value`
-            for value manipulation according to the specified characteristic
-            line of the bus.
-
-            .. math::
-
-                \dot{E} = \dot{m}_{in} \cdot \left(h_{out} - h_{in} \right)
-        """
-        return self.inl[0].m.val_SI * (
-            self.outl[0].h.val_SI - self.inl[0].h.val_SI)
-
-    def bus_func_doc(self, bus):
-        r"""
-        Return LaTeX string of the bus function.
-
-        Parameters
-        ----------
-        bus : tespy.connections.bus.Bus
-            TESPy bus object.
-
-        Returns
-        -------
-        latex : str
-            LaTeX string of bus function.
-        """
-        return (
-            r'\dot{m}_\mathrm{in} \cdot \left(h_\mathrm{out} - '
-            r'h_\mathrm{in} \right)')
-
-    def bus_deriv(self, bus):
-        r"""
-        Calculate partial derivatives of the bus function.
-
-        Parameters
-        ----------
-        bus : tespy.connections.bus.Bus
-            TESPy bus object.
-
-        Returns
-        -------
-        deriv : ndarray
-            Matrix of partial derivatives.
-        """
-        deriv = np.zeros((1, 2, self.num_nw_vars))
-        f = self.calc_bus_value
-        deriv[0, 0, 0] = self.numeric_deriv(f, 'm', 0, bus=bus)
-        deriv[0, 0, 2] = self.numeric_deriv(f, 'h', 0, bus=bus)
-        deriv[0, 1, 2] = self.numeric_deriv(f, 'h', 1, bus=bus)
-        return deriv
-
-    def calc_parameters(self):
-        r"""Postprocessing parameter calculation."""
-        self.P.val = self.inl[0].m.val_SI * (
-            self.outl[0].h.val_SI - self.inl[0].h.val_SI)
-        self.pr.val = self.outl[0].p.val_SI / self.inl[0].p.val_SI
-
-    def entropy_balance(self):
-        r"""
-        Calculate entropy balance of turbomachine.
-
-        Note
-        ----
-        The entropy balance makes the follwing parameter available:
-
-        .. math::
-
-            \text{S\_irr}=\dot{m} \cdot \left(s_\mathrm{out}-s_\mathrm{in}
-            \right)\\
-        """
-        self.S_irr = self.inl[0].m.val_SI * (
-            self.outl[0].s.val_SI - self.inl[0].s.val_SI)
-
-    def get_plotting_data(self):
-        """Generate a dictionary containing FluProDia plotting information.
-
-        Returns
-        -------
-        data : dict
-            A nested dictionary containing the keywords required by the
-            :code:`calc_individual_isoline` method of the
-            :code:`FluidPropertyDiagram` class. First level keys are the
-            connection index ('in1' -> 'out1', therefore :code:`1` etc.).
-        """
-        return {
-            1: {
-                'isoline_property': 's',
-                'isoline_value': self.inl[0].s.val,
-                'isoline_value_end': self.outl[0].s.val,
-                'starting_point_property': 'v',
-                'starting_point_value': self.inl[0].vol.val,
-                'ending_point_property': 'v',
-                'ending_point_value': self.outl[0].vol.val
-            }
-        }
+# -*- coding: utf-8
+
+"""Module of class Turbomachine.
+
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location
+tespy/components/turbomachinery/base.py
+
+SPDX-License-Identifier: MIT
+"""
+
+import numpy as np
+
+from tespy.components.component import Component
+from tespy.tools.data_containers import ComponentProperties as dc_cp
+from tespy.tools.document_models import generate_latex_eq
+
+
+class Turbomachine(Component):
+    r"""
+    Parent class for compressor, pump and turbine.
+
+    **Mandatory Equations**
+
+    - :py:meth:`tespy.components.component.Component.fluid_func`
+    - :py:meth:`tespy.components.component.Component.mass_flow_func`
+
+    **Optional Equations**
+
+    - :py:meth:`tespy.components.component.Component.pr_func`
+    - :py:meth:`tespy.components.turbomachinery.base.base.energy_balance_func`
+
+    Inlets/Outlets
+
+    - in1
+    - out1
+
+    Parameters
+    ----------
+    label : str
+        The label of the component.
+
+    design : list
+        List containing design parameters (stated as String).
+
+    offdesign : list
+        List containing offdesign parameters (stated as String).
+
+    design_path : str
+        Path to the components design case.
+
+    local_offdesign : boolean
+        Treat this component in offdesign mode in a design calculation.
+
+    local_design : boolean
+        Treat this component in design mode in an offdesign calculation.
+
+    char_warnings : boolean
+        Ignore warnings on default characteristics usage for this component.
+
+    printout : boolean
+        Include this component in the network's results printout.
+
+    P : float, dict
+        Power, :math:`P/\text{W}`
+
+    pr : float, dict, :code:`"var"`
+        Outlet to inlet pressure ratio, :math:`pr/1`
+
+    Example
+    -------
+    For an example please refer to:
+
+    - :class:`tespy.components.turbomachinery.compressor.Compressor`
+    - :class:`tespy.components.turbomachinery.pump.Pump`
+    - :class:`tespy.components.turbomachinery.turbine.Turbine`
+    """
+
+    @staticmethod
+    def component():
+        return 'turbomachine'
+
+    def get_variables(self):
+        return {
+            'P': dc_cp(
+                deriv=self.energy_balance_deriv, num_eq=1,
+                func=self.energy_balance_func,
+                latex=self.energy_balance_func_doc),
+            'pr': dc_cp(
+                deriv=self.pr_deriv, num_eq=1,
+                func=self.pr_func, func_params={'pr': 'pr'},
+                latex=self.pr_func_doc)
+        }
+
+    @staticmethod
+    def inlets():
+        return ['in1']
+
+    @staticmethod
+    def outlets():
+        return ['out1']
+
+    def energy_balance_func(self):
+        r"""
+        Calculate energy balance of a turbomachine.
+
+        Returns
+        -------
+        residual : float
+            Residual value of turbomachine energy balance
+
+            .. math::
+
+                0=\dot{m}_{in}\cdot\left(h_{out}-h_{in}\right)-P
+        """
+        return self.inl[0].m.val_SI * (
+            self.outl[0].h.val_SI - self.inl[0].h.val_SI) - self.P.val
+
+    def energy_balance_func_doc(self, label):
+        r"""
+        Calculate energy balance of a turbomachine.
+
+        Parameters
+        ----------
+        label : str
+            Label for equation.
+
+        Returns
+        -------
+        latex : str
+            LaTeX code of equations applied.
+        """
+        latex = (
+            r'0=\dot{m}_\mathrm{in}\cdot\left(h_\mathrm{out}-h_\mathrm{in}'
+            r'\right)-P')
+        return generate_latex_eq(self, latex, label)
+
+    def energy_balance_deriv(self, increment_filter, k):
+        r"""
+        Calculate partial derivatives of energy balance of a turbomachine.
+
+        Parameters
+        ----------
+        increment_filter : ndarray
+            Matrix for filtering non-changing variables.
+
+        k : int
+            Position of derivatives in Jacobian matrix (k-th equation).
+        """
+        self.jacobian[k, 0, 0] = self.outl[0].h.val_SI - self.inl[0].h.val_SI
+        self.jacobian[k, 0, 2] = -self.inl[0].m.val_SI
+        self.jacobian[k, 1, 2] = self.inl[0].m.val_SI
+
+    def bus_func(self, bus):
+        r"""
+        Calculate the value of the bus function.
+
+        Parameters
+        ----------
+        bus : tespy.connections.bus.Bus
+            TESPy bus object.
+
+        Returns
+        -------
+        residual : float
+            Value of energy transfer :math:`\dot{E}`. This value is passed to
+            :py:meth:`tespy.components.component.Component.calc_bus_value`
+            for value manipulation according to the specified characteristic
+            line of the bus.
+
+            .. math::
+
+                \dot{E} = \dot{m}_{in} \cdot \left(h_{out} - h_{in} \right)
+        """
+        return self.inl[0].m.val_SI * (
+            self.outl[0].h.val_SI - self.inl[0].h.val_SI)
+
+    def bus_func_doc(self, bus):
+        r"""
+        Return LaTeX string of the bus function.
+
+        Parameters
+        ----------
+        bus : tespy.connections.bus.Bus
+            TESPy bus object.
+
+        Returns
+        -------
+        latex : str
+            LaTeX string of bus function.
+        """
+        return (
+            r'\dot{m}_\mathrm{in} \cdot \left(h_\mathrm{out} - '
+            r'h_\mathrm{in} \right)')
+
+    def bus_deriv(self, bus):
+        r"""
+        Calculate partial derivatives of the bus function.
+
+        Parameters
+        ----------
+        bus : tespy.connections.bus.Bus
+            TESPy bus object.
+
+        Returns
+        -------
+        deriv : ndarray
+            Matrix of partial derivatives.
+        """
+        deriv = np.zeros((1, 2, self.num_nw_vars))
+        f = self.calc_bus_value
+        deriv[0, 0, 0] = self.numeric_deriv(f, 'm', 0, bus=bus)
+        deriv[0, 0, 2] = self.numeric_deriv(f, 'h', 0, bus=bus)
+        deriv[0, 1, 2] = self.numeric_deriv(f, 'h', 1, bus=bus)
+        return deriv
+
+    def calc_parameters(self):
+        r"""Postprocessing parameter calculation."""
+        self.P.val = self.inl[0].m.val_SI * (
+            self.outl[0].h.val_SI - self.inl[0].h.val_SI)
+        self.pr.val = self.outl[0].p.val_SI / self.inl[0].p.val_SI
+
+    def entropy_balance(self):
+        r"""
+        Calculate entropy balance of turbomachine.
+
+        Note
+        ----
+        The entropy balance makes the follwing parameter available:
+
+        .. math::
+
+            \text{S\_irr}=\dot{m} \cdot \left(s_\mathrm{out}-s_\mathrm{in}
+            \right)\\
+        """
+        self.S_irr = self.inl[0].m.val_SI * (
+            self.outl[0].s.val_SI - self.inl[0].s.val_SI)
+
+    def get_plotting_data(self):
+        """Generate a dictionary containing FluProDia plotting information.
+
+        Returns
+        -------
+        data : dict
+            A nested dictionary containing the keywords required by the
+            :code:`calc_individual_isoline` method of the
+            :code:`FluidPropertyDiagram` class. First level keys are the
+            connection index ('in1' -> 'out1', therefore :code:`1` etc.).
+        """
+        return {
+            1: {
+                'isoline_property': 's',
+                'isoline_value': self.inl[0].s.val,
+                'isoline_value_end': self.outl[0].s.val,
+                'starting_point_property': 'v',
+                'starting_point_value': self.inl[0].vol.val,
+                'ending_point_property': 'v',
+                'ending_point_value': self.outl[0].vol.val
+            }
+        }
```

### Comparing `TESPy-0.6.2/src/tespy/components/turbomachinery/compressor.py` & `TESPy-0.6.3/src/tespy/components/turbomachinery/compressor.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,20 +7,18 @@
 by the contributors recorded in the version control history of the file,
 available from its original location
 tespy/components/turbomachinery/compressor.py
 
 SPDX-License-Identifier: MIT
 """
 
-import logging
-
 import numpy as np
 
-from tespy.components.component import Component
 from tespy.components.turbomachinery.base import Turbomachine
+from tespy.tools import logger
 from tespy.tools.data_containers import ComponentCharacteristicMaps as dc_cm
 from tespy.tools.data_containers import ComponentCharacteristics as dc_cc
 from tespy.tools.data_containers import ComponentProperties as dc_cp
 from tespy.tools.data_containers import GroupedComponentProperties as dc_gcp
 from tespy.tools.document_models import generate_latex_eq
 from tespy.tools.fluid_properties import T_mix_ph
 from tespy.tools.fluid_properties import isentropic
@@ -266,15 +264,15 @@
                 \cdot f\left( expr \right) -\left( h_{out,s} - h_{in} \right)
         """
         p = self.eta_s_char.param
         expr = self.get_char_expr(p, **self.eta_s_char.char_params)
         if not expr:
             msg = ('Please choose a valid parameter, you want to link the '
                    'isentropic efficiency to at component ' + self.label + '.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         i = self.inl[0]
         o = self.outl[0]
         return (
             self.eta_s.design * self.eta_s_char.char_func.evaluate(expr) *
             (o.h.val_SI - i.h.val_SI) - (isentropic(
@@ -613,25 +611,25 @@
         if key == 'p':
             return 1e5
         elif key == 'h':
             return 4e5
 
     def calc_parameters(self):
         r"""Postprocessing parameter calculation."""
-        Turbomachine.calc_parameters(self)
+        super().calc_parameters()
 
         self.eta_s.val = (
             (isentropic(
                 self.inl[0].get_flow(), self.outl[0].get_flow(),
                 T0=self.inl[0].T.val_SI) - self.inl[0].h.val_SI) /
             (self.outl[0].h.val_SI - self.inl[0].h.val_SI))
 
     def check_parameter_bounds(self):
         r"""Check parameter value limits."""
-        Component.check_parameter_bounds(self)
+        super().check_parameter_bounds()
 
         for data in [self.char_map_pr, self.char_map_eta_s]:
             if data.is_set:
                 x = np.sqrt(self.inl[0].T.design / self.inl[0].T.val_SI)
                 y = (self.inl[0].m.val_SI * self.inl[0].p.design) / (
                     self.inl[0].m.design * self.inl[0].p.val_SI * x)
                 yarr = data.char_func.get_domain_errors_x(x, self.label)
@@ -683,14 +681,16 @@
         elif self.inl[0].T.val_SI <= T0 and self.outl[0].T.val_SI <= T0:
             self.E_P = self.outl[0].Ex_mech - self.inl[0].Ex_mech
             self.E_F = self.P.val + (
                 self.inl[0].Ex_therm - self.outl[0].Ex_therm)
         else:
             msg = ('Exergy balance of a compressor, where outlet temperature '
                    'is smaller than inlet temperature is not implmented.')
-            logging.warning(msg)
+            logger.warning(msg)
             self.E_P = np.nan
             self.E_F = np.nan
 
-        self.E_bus = self.P.val
+        self.E_bus = {
+            "chemical": 0, "physical": 0, "massless": self.P.val
+        }
         self.E_D = self.E_F - self.E_P
         self.epsilon = self.E_P / self.E_F
```

### Comparing `TESPy-0.6.2/src/tespy/components/turbomachinery/pump.py` & `TESPy-0.6.3/src/tespy/components/turbomachinery/pump.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,19 +6,18 @@
 This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
 by the contributors recorded in the version control history of the file,
 available from its original location tespy/components/turbomachinery/pump.py
 
 SPDX-License-Identifier: MIT
 """
 
-import logging
-
 import numpy as np
 
 from tespy.components.turbomachinery.base import Turbomachine
+from tespy.tools import logger
 from tespy.tools.data_containers import ComponentCharacteristics as dc_cc
 from tespy.tools.data_containers import ComponentProperties as dc_cp
 from tespy.tools.document_models import generate_latex_eq
 from tespy.tools.fluid_properties import isentropic
 from tespy.tools.fluid_properties import v_mix_ph
 
 
@@ -265,15 +264,15 @@
                 \cdot f\left( expr \right) -\left( h_{out,s} - h_{in} \right)
         """
         p = self.eta_s_char.param
         expr = self.get_char_expr(p, **self.eta_s_char.char_params)
         if not expr:
             msg = ('Please choose a valid parameter, you want to link the '
                    'isentropic efficiency to at component ' + self.label + '.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         i = self.inl[0]
         o = self.outl[0]
         return (
             (o.h.val_SI - i.h.val_SI) * self.eta_s.design *
             self.eta_s_char.char_func.evaluate(expr) - (isentropic(
@@ -474,15 +473,15 @@
         if key == 'p':
             return 1e5
         elif key == 'h':
             return 2.9e5
 
     def calc_parameters(self):
         r"""Postprocessing parameter calculation."""
-        Turbomachine.calc_parameters(self)
+        super().calc_parameters()
 
         self.eta_s.val = (
             (isentropic(
                 self.inl[0].get_flow(), self.outl[0].get_flow(),
                 T0=self.inl[0].T.val_SI) - self.inl[0].h.val_SI) /
             (self.outl[0].h.val_SI - self.inl[0].h.val_SI))
 
@@ -531,14 +530,16 @@
         elif self.inl[0].T.val_SI <= T0 and self.outl[0].T.val_SI <= T0:
             self.E_P = self.outl[0].Ex_mech - self.inl[0].Ex_mech
             self.E_F = self.P.val + (
                 self.inl[0].Ex_therm - self.outl[0].Ex_therm)
         else:
             msg = ('Exergy balance of a pump, where outlet temperature is '
                    'smaller than inlet temperature is not implmented.')
-            logging.warning(msg)
+            logger.warning(msg)
             self.E_P = np.nan
             self.E_F = np.nan
 
-        self.E_bus = self.P.val
+        self.E_bus = {
+            "chemical": 0, "physical": 0, "massless": self.P.val
+        }
         self.E_D = self.E_F - self.E_P
         self.epsilon = self.E_P / self.E_F
```

### Comparing `TESPy-0.6.2/src/tespy/components/turbomachinery/turbine.py` & `TESPy-0.6.3/src/tespy/components/turbomachinery/turbine.py`

 * *Files 1% similar despite different names*

```diff
@@ -6,22 +6,22 @@
 This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
 by the contributors recorded in the version control history of the file,
 available from its original location tespy/components/turbomachinery/turbine.py
 
 SPDX-License-Identifier: MIT
 """
 
-import logging
 
 import numpy as np
 
 from tespy.components.turbomachinery.base import Turbomachine
+from tespy.tools import logger
 from tespy.tools.data_containers import ComponentCharacteristics as dc_cc
 from tespy.tools.data_containers import ComponentProperties as dc_cp
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
+from tespy.tools.data_containers import SimpleDataContainer as dc_simple
 from tespy.tools.document_models import generate_latex_eq
 from tespy.tools.fluid_properties import isentropic
 from tespy.tools.fluid_properties import v_mix_ph
 
 
 class Turbine(Turbomachine):
     r"""
@@ -323,15 +323,15 @@
                 \left(h_\mathrm{out,s}-h_\mathrm{in}\right)
         """
         p = self.eta_s_char.param
         expr = self.get_char_expr(p)
         if not expr:
             msg = ('Please choose a valid parameter, you want to link the '
                    'isentropic efficiency to at component ' + self.label + '.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         i = self.inl[0]
         o = self.outl[0]
         return (
             -(o.h.val_SI - i.h.val_SI) + self.eta_s.design *
             self.eta_s_char.char_func.evaluate(expr) * (isentropic(
@@ -467,15 +467,15 @@
         if key == 'p':
             return 2.5e6
         elif key == 'h':
             return 2e6
 
     def calc_parameters(self):
         r"""Postprocessing parameter calculation."""
-        Turbomachine.calc_parameters(self)
+        super().calc_parameters()
 
         self.eta_s.val = (
             (self.outl[0].h.val_SI - self.inl[0].h.val_SI) / (
                 isentropic(
                     self.inl[0].get_flow(), self.outl[0].get_flow(),
                     T0=self.inl[0].T.val_SI) - self.inl[0].h.val_SI))
 
@@ -524,14 +524,14 @@
         elif self.inl[0].T.val_SI <= T0 and self.outl[0].T.val_SI <= T0:
             self.E_P = -self.P.val + (
                 self.outl[0].Ex_therm - self.inl[0].Ex_therm)
             self.E_F = self.inl[0].Ex_mech - self.outl[0].Ex_mech
         else:
             msg = ('Exergy balance of a turbine, where outlet temperature is '
                    'larger than inlet temperature is not implmented.')
-            logging.warning(msg)
+            logger.warning(msg)
             self.E_P = np.nan
             self.E_F = np.nan
 
-        self.E_bus = -self.P.val
+        self.E_bus = {"chemical": 0, "physical": 0, "massless": -self.P.val}
         self.E_D = self.E_F - self.E_P
         self.epsilon = self.E_P / self.E_F
```

### Comparing `TESPy-0.6.2/src/tespy/connections/bus.py` & `TESPy-0.6.3/src/tespy/connections/bus.py`

 * *Files 3% similar despite different names*

```diff
@@ -6,25 +6,21 @@
 This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
 by the contributors recorded in the version control history of the file,
 available from its original location tespy/connections/bus.py
 
 SPDX-License-Identifier: MIT
 """
 
-import logging
-
 import numpy as np
 import pandas as pd
 
 from tespy.components.component import Component
+from tespy.tools import logger
 from tespy.tools.characteristics import CharLine
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
-
-# pass the warning messages to the logger
-logging.captureWarnings(True)
+from tespy.tools.data_containers import SimpleDataContainer as dc_simple
 
 
 class Bus:
     r"""
     A bus is used to connect different energy flows.
 
     Parameters
@@ -191,15 +187,15 @@
         self.P = dc_simple(val=np.nan, is_set=False)
         self.char = CharLine(x=np.array([0, 3]), y=np.array([1, 1]))
         self.printout = True
 
         self.set_attr(**kwargs)
 
         msg = 'Created bus ' + self.label + '.'
-        logging.debug(msg)
+        logger.debug(msg)
 
     def set_attr(self, **kwargs):
         r"""
         Set, reset or unset attributes of a bus object.
 
         Parameters
         ----------
@@ -230,29 +226,29 @@
                         self.P.set_attr(is_set=False)
                     else:
                         self.P.set_attr(val=kwargs[key], is_set=True)
                 elif kwargs[key] is None:
                     self.P.set_attr(is_set=False)
                 else:
                     msg = ('Keyword argument ' + key + ' must be numeric.')
-                    logging.error(msg)
+                    logger.error(msg)
                     raise TypeError(msg)
 
             elif key == 'printout':
                 if not isinstance(kwargs[key], bool):
                     msg = ('Please provide the ' + key + ' as boolean.')
-                    logging.error(msg)
+                    logger.error(msg)
                     raise TypeError(msg)
                 else:
                     self.__dict__.update({key: kwargs[key]})
 
             # invalid keyword
             else:
                 msg = 'A bus has no attribute ' + key + '.'
-                logging.error(msg)
+                logger.error(msg)
                 raise KeyError(msg)
 
     def get_attr(self, key):
         r"""
         Get the value of a busses attribute.
 
         Parameters
@@ -265,15 +261,15 @@
         out :
             Specified attribute.
         """
         if key in self.__dict__:
             return self.__dict__[key]
         else:
             msg = 'Bus ' + self.label + ' has no attribute ' + key + '.'
-            logging.error(msg)
+            logger.error(msg)
             raise KeyError(msg)
 
     def add_comps(self, *args):
         r"""
         Add components to a bus.
 
         Parameters
@@ -331,30 +327,30 @@
                     comp = c['comp']
                     # default values
                     if isinstance(comp, Component):
                         self.comps.loc[comp] = [
                             None, np.nan, self.char, np.nan, 'component']
                     else:
                         msg = 'Keyword "comp" must hold a TESPy component.'
-                        logging.error(msg)
+                        logger.error(msg)
                         raise TypeError(msg)
                 else:
                     msg = 'You must provide the component "comp".'
-                    logging.error(msg)
+                    logger.error(msg)
                     raise TypeError(msg)
 
                 for k, v in c.items():
                     if k == 'param':
                         if isinstance(v, str) or v is None:
                             self.comps.loc[comp, 'param'] = v
                         else:
                             msg = (
                                 'The bus parameter selection must be a '
                                 'string (at bus ' + self.label + ').')
-                            logging.error(msg)
+                            logger.error(msg)
                             raise TypeError(msg)
 
                     elif k == 'char':
                         try:
                             float(v)
                             is_numeric = True
                         except (TypeError, ValueError):
@@ -366,43 +362,43 @@
                             y = np.array([1, 1]) * v
                             self.comps.loc[comp, 'char'] = (
                                     CharLine(x=x, y=y))
                         else:
                             msg = (
                                 'Char must be a number or a TESPy '
                                 'characteristics char line.')
-                            logging.error(msg)
+                            logger.error(msg)
                             raise TypeError(msg)
 
                     elif k == 'P_ref':
                         try:
                             float(v)
                             is_numeric = True
                         except (TypeError, ValueError):
                             is_numeric = False
                         if v is None or is_numeric:
                             self.comps.loc[comp, 'P_ref'] = v
                         else:
                             msg = 'Reference value must be numeric.'
-                            logging.error(msg)
+                            logger.error(msg)
                             raise TypeError(msg)
 
                     elif k == 'base':
                         if v in ['bus', 'component']:
                             self.comps.loc[comp, 'base'] = v
                         else:
                             msg = (
                                 'The base value must be "bus" or "component".')
-                            logging.error(msg)
+                            logger.error(msg)
                             raise ValueError(msg)
 
             else:
                 msg = (
                     'Provide arguments as dictionaries. See the documentation '
                     'of bus.add_comps() for more information.')
-                logging.error(msg)
+                logger.error(msg)
                 raise TypeError(msg)
 
             msg = (
                 'Added component ' + comp.label + ' to bus ' +
                 self.label + '.')
-            logging.debug(msg)
+            logger.debug(msg)
```

### Comparing `TESPy-0.6.2/src/tespy/connections/connection.py` & `TESPy-0.6.3/src/tespy/connections/connection.py`

 * *Files 4% similar despite different names*

```diff
@@ -1,33 +1,28 @@
 # -*- coding: utf-8
-
 """Module of class Connection and class Ref.
 
 
 This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
 by the contributors recorded in the version control history of the file,
 available from its original location tespy/connections/connection.py
 
 SPDX-License-Identifier: MIT
 """
 
-import logging
-
 import numpy as np
 
 from tespy.components.component import Component
 from tespy.tools import fluid_properties as fp
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
+from tespy.tools import logger
 from tespy.tools.data_containers import FluidComposition as dc_flu
 from tespy.tools.data_containers import FluidProperties as dc_prop
+from tespy.tools.data_containers import SimpleDataContainer as dc_simple
 from tespy.tools.helpers import TESPyConnectionError
 
-# pass the warning messages to the logger
-logging.captureWarnings(True)
-
 
 class Connection:
     r"""
     Class connection is the container for fluid properties between components.
 
     Parameters
     ----------
@@ -215,49 +210,49 @@
                  label=None, **kwargs):
 
         # check input parameters
         if not (isinstance(comp1, Component) and
                 isinstance(comp2, Component)):
             msg = ('Error creating connection. Check if comp1, comp2 are of '
                    'type component.')
-            logging.error(msg)
+            logger.error(msg)
             raise TypeError(msg)
 
         if comp1 == comp2:
             msg = ('Error creating connection. Cannot connect component ' +
                    comp1.label + ' to itself.')
-            logging.error(msg)
+            logger.error(msg)
             raise TESPyConnectionError(msg)
 
         if outlet_id not in comp1.outlets():
             msg = ('Error creating connection. Specified oulet_id (' +
                    outlet_id + ') is not valid for component ' +
                    comp1.component() + '. Valid ids are: ' +
                    str(comp1.outlets()) + '.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         if inlet_id not in comp2.inlets():
             msg = (
                 'Error creating connection. Specified inlet_id (' + inlet_id +
                 ') is not valid for component ' + comp2.component() +
                 '. Valid ids are: ' + str(comp2.inlets()) + '.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         if label is None:
             self.label = (
                 comp1.label + ':' + outlet_id + '_' +
                 comp2.label + ':' + inlet_id)
         else:
             self.label = label
 
         if not isinstance(self.label, str):
             msg = 'Please provide the label as string.'
-            logging.error(msg)
+            logger.error(msg)
             raise TypeError(msg)
 
         # set specified values
         self.source = comp1
         self.source_id = outlet_id
         self.target = comp2
         self.target_id = inlet_id
@@ -276,15 +271,15 @@
         self.variables0 = [x + '0' for x in self.variables.keys()]
         self.__dict__.update(self.variables)
         self.set_attr(**kwargs)
 
         msg = (
             'Created connection ' + self.source.label + ' (' + self.source_id +
             ') -> ' + self.target.label + ' (' + self.target_id + ').')
-        logging.debug(msg)
+        logger.debug(msg)
 
     def set_attr(self, **kwargs):
         r"""
         Set, reset or unset attributes of a connection.
 
         Parameters
         ----------
@@ -369,15 +364,15 @@
           iterations in order to meet the state requirement.
         """
         # set specified values
         for key in kwargs:
             if key == 'label':
                 # bad datatype
                 msg = 'Label can only be specified on instance creation.'
-                logging.error(msg)
+                logger.error(msg)
                 raise TESPyConnectionError(msg)
             elif key in self.variables or key in self.variables0:
                 # fluid specification
                 try:
                     float(kwargs[key])
                     is_numeric = True
                 except (TypeError, ValueError):
@@ -394,36 +389,36 @@
                                 val_set={f: True for f in kwargs[key].keys()})
 
                     else:
                         # bad datatype
                         msg = (
                             'Datatype for fluid vector specification must be '
                             'dict.')
-                        logging.error(msg)
+                        logger.error(msg)
                         raise TypeError(msg)
 
                 elif key == 'state':
                     if kwargs[key] in ['l', 'g']:
                         self.state.set_attr(val=kwargs[key], is_set=True)
                     elif kwargs[key] is None:
                         self.state.set_attr(is_set=False)
                     elif is_numeric:
                         if np.isnan(kwargs[key]):
                             self.get_attr(key).set_attr(is_set=False)
                         else:
                             msg = (
                                 'To unset the state specification either use '
                                 'np.nan or None.')
-                            logging.error(msg)
+                            logger.error(msg)
                             raise ValueError(msg)
                     else:
                         msg = (
                             'Keyword argument "state" must either be '
                             '"l" or "g" or be None or np.nan.')
-                        logging.error(msg)
+                        logger.error(msg)
                         raise TypeError(msg)
 
                 elif kwargs[key] is None:
                     self.get_attr(key).set_attr(val_set=False)
                     self.get_attr(key).set_attr(ref_set=False)
 
                 elif is_numeric:
@@ -444,81 +439,81 @@
                 # reference object
                 elif isinstance(kwargs[key], Ref):
                     if key in ['x', 'Td_bp']:
                         msg = (
                             'References for vapor mass fraction and '
                             'subcooling/superheating are not implemented.'
                         )
-                        logging.error(msg)
+                        logger.error(msg)
                         raise NotImplementedError(msg)
                     else:
                         self.get_attr(key).set_attr(ref=kwargs[key])
                         self.get_attr(key).set_attr(ref_set=True)
 
                 # invalid datatype for keyword
                 else:
                     msg = 'Bad datatype for keyword argument ' + key + '.'
-                    logging.error(msg)
+                    logger.error(msg)
                     raise TypeError(msg)
 
             # fluid balance
             elif key == 'fluid_balance':
                 if isinstance(kwargs[key], bool):
                     self.get_attr('fluid').set_attr(balance=kwargs[key])
                 else:
                     msg = (
                         'Datatype for keyword argument fluid_balance must be '
                         'boolean.')
-                    logging.error(msg)
+                    logger.error(msg)
                     raise TypeError(msg)
 
             # design/offdesign parameter list
             elif key == 'design' or key == 'offdesign':
                 if not isinstance(kwargs[key], list):
                     msg = 'Please provide the ' + key + ' parameters as list!'
-                    logging.error(msg)
+                    logger.error(msg)
                     raise TypeError(msg)
                 elif set(kwargs[key]).issubset(self.variables.keys()):
                     self.__dict__.update({key: kwargs[key]})
                 else:
                     params = ', '.join(self.variables.keys())
                     msg = (
                         'Available parameters for (off-)design specification '
                         'are: ' + params + '.')
-                    logging.error(msg)
+                    logger.error(msg)
                     raise ValueError(msg)
 
             # design path
             elif key == 'design_path':
                 if isinstance(kwargs[key], str):
                     self.__dict__.update({key: kwargs[key]})
                 elif np.isnan(kwargs[key]):
                     self.design_path = None
                 else:
                     msg = (
                         'Please provide the design_path parameter as string '
                         'or as nan.')
-                    logging.error(msg)
+                    logger.error(msg)
                     raise TypeError(msg)
 
                 self.new_design = True
 
             # other boolean keywords
             elif key in ['printout', 'local_design', 'local_offdesign']:
                 if not isinstance(kwargs[key], bool):
                     msg = ('Please provide the ' + key + ' as boolean.')
-                    logging.error(msg)
+                    logger.error(msg)
                     raise TypeError(msg)
                 else:
                     self.__dict__.update({key: kwargs[key]})
 
             # invalid keyword
             else:
                 msg = 'Connection has no attribute ' + key + '.'
-                logging.error(msg)
+                logger.error(msg)
                 raise KeyError(msg)
 
     def get_attr(self, key):
         r"""
         Get the value of a connection's attribute.
 
         Parameters
@@ -531,15 +526,15 @@
         out :
             Specified attribute.
         """
         if key in self.__dict__:
             return self.__dict__[key]
         else:
             msg = 'Connection has no attribute \"' + key + '\".'
-            logging.error(msg)
+            logger.error(msg)
             raise KeyError(msg)
 
     @staticmethod
     def attr():
         r"""
         Return available attributes of a connection.
 
@@ -563,15 +558,14 @@
             List of mass flow and fluid property information.
         """
         return [self.m.val_SI, self.p.val_SI, self.h.val_SI, self.fluid.val]
 
     def get_physical_exergy(self, p0, T0):
         r"""
         Get the value of a connection's specific physical exergy.
-        Calcute physical exergy of connection
 
         Parameters
         ----------
         p0 : float
             Ambient pressure p0 / Pa.
 
         T0 : float
@@ -589,18 +583,47 @@
         self.ex_therm, self.ex_mech = fp.calc_physical_exergy(self, p0, T0)
         self.Ex_therm = self.ex_therm * self.m.val_SI
         self.Ex_mech = self.ex_mech * self.m.val_SI
 
         self.ex_physical = self.ex_therm + self.ex_mech
         self.Ex_physical = self.m.val_SI * self.ex_physical
 
+    def get_chemical_exergy(self, p0, T0, Chem_Ex):
+        r"""
+        Get the value of a connection's specific chemical exergy.
+
+        Parameters
+        ----------
+        p0 : float
+            Ambient pressure p0 / Pa.
+
+        T0 : float
+            Ambient temperature T0 / K.
+
+        Chem_Ex : dict
+            Lookup table for standard specific chemical exergy.
+
+        Note
+        ----
+            .. math::
+
+                E^\mathrm{CH} = \dot{m} \cdot e^\mathrm{CH}
+        """
+        if Chem_Ex is None:
+            self.ex_chemical = 0
+        else:
+            self.ex_chemical = fp.calc_chemical_exergy(self, p0, T0, Chem_Ex)
+
+        self.Ex_chemical = self.m.val_SI * self.ex_chemical
+
 
 class Ref:
     r"""
-    A bus is used to connect different energy flows.
+    A reference object is used to reference (unknown) properties of connections
+    to other connections.
 
     For example, reference the mass flow of one connection :math:`\dot{m}` to
     another mass flow :math:`\dot{m}_{ref}`:
 
     .. math::
 
         \dot{m} = \dot{m}_\mathrm{ref} \cdot \mathrm{factor} + \mathrm{delta}
@@ -617,37 +640,37 @@
         Delta to add after multiplication.
     """
 
     def __init__(self, ref_obj, factor, delta):
 
         if not isinstance(ref_obj, Connection):
             msg = 'First parameter must be object of type connection.'
-            logging.error(msg)
+            logger.error(msg)
             raise TypeError(msg)
 
         if not (isinstance(factor, int) or isinstance(factor, float)):
             msg = 'Second parameter must be of type int or float.'
-            logging.error(msg)
+            logger.error(msg)
             raise TypeError(msg)
 
         if not (isinstance(delta, int) or isinstance(delta, float)):
             msg = 'Thrid parameter must be of type int or float.'
-            logging.error(msg)
+            logger.error(msg)
             raise TypeError(msg)
 
         self.obj = ref_obj
         self.factor = factor
         self.delta = delta
         self.delta_SI = None
 
         msg = ('Created reference object with factor ' + str(self.factor) +
                ' and delta ' + str(self.delta) + ' referring to connection ' +
                ref_obj.source.label + ' (' + ref_obj.source_id + ') -> ' +
                ref_obj.target.label + ' (' + ref_obj.target_id + ').')
-        logging.debug(msg)
+        logger.debug(msg)
 
     def get_attr(self, key):
         r"""
         Get the value of a reference attribute.
 
         Parameters
         ----------
@@ -659,9 +682,9 @@
         out :
             Specified attribute.
         """
         if key in self.__dict__:
             return self.__dict__[key]
         else:
             msg = 'Reference has no attribute \"' + key + '\".'
-            logging.error(msg)
+            logger.error(msg)
             raise KeyError(msg)
```

### Comparing `TESPy-0.6.2/src/tespy/data/char_lines.json` & `TESPy-0.6.3/src/tespy/data/char_lines.json`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/src/tespy/data/char_maps.json` & `TESPy-0.6.3/src/tespy/data/char_maps.json`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/src/tespy/networks/network.py` & `TESPy-0.6.3/src/tespy/networks/network.py`

 * *Files 4% similar despite different names*

```diff
@@ -11,33 +11,33 @@
 by the contributors recorded in the version control history of the file,
 available from its original location tespy/networks/networks.py
 
 SPDX-License-Identifier: MIT
 """
 import ast
 import json
-import logging
 import os
 from collections import OrderedDict
 from time import time
 
 import numpy as np
 import pandas as pd
 from numpy.linalg import norm
 from tabulate import tabulate
 
 from tespy import connections as con
 from tespy.tools import fluid_properties as fp
 from tespy.tools import helpers as hlp
+from tespy.tools import logger
 from tespy.tools.data_containers import ComponentCharacteristicMaps as dc_cm
 from tespy.tools.data_containers import ComponentCharacteristics as dc_cc
 from tespy.tools.data_containers import ComponentProperties as dc_cp
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
 from tespy.tools.data_containers import GroupedComponentCharacteristics as dc_gcc
 from tespy.tools.data_containers import GroupedComponentProperties as dc_gcp
+from tespy.tools.data_containers import SimpleDataContainer as dc_simple
 from tespy.tools.global_vars import err
 from tespy.tools.global_vars import fluid_property_data as fpd
 
 # Only require cupy if Cuda shall be used
 try:
     import cupy as cu
 except ModuleNotFoundError:
@@ -158,15 +158,15 @@
 
         # fluid list and constants
         if isinstance(fluids, list):
             self.fluids = sorted(fluids)
         else:
             msg = ('Please provide a list containing the network\'s fluids on '
                    'creation.')
-            logging.error(msg)
+            logger.error(msg)
             raise TypeError(msg)
 
         self.set_defaults()
         self.set_fluid_back_ends(memorise_fluid_properties)
         self.set_attr(**kwargs)
 
     def set_defaults(self):
@@ -196,29 +196,29 @@
         msg = 'Default unit specifications:\n'
         for prop, data in fpd.items():
             # standard unit set
             self.__dict__.update({prop + '_unit': data['SI_unit']})
             msg += data['text'] + ': ' + data['SI_unit'] + '\n'
 
         # don't need the last newline
-        logging.debug(msg[:-1])
+        logger.debug(msg[:-1])
 
         # generic value range
         self.m_range_SI = np.array([-1e12, 1e12])
         self.p_range_SI = np.array([2e2, 300e5])
         self.h_range_SI = np.array([1e3, 7e6])
 
         for prop in ['m', 'p', 'h']:
             limits = self.get_attr(prop + '_range_SI')
             msg = (
                 'Default ' + fpd[prop]['text'] + ' limits\n'
                 'min: ' + str(limits[0]) + ' ' +
                 self.get_attr(prop + '_unit') + '\n'
                 'max: ' + str(limits[1]) + ' ' + self.get_attr(prop + '_unit'))
-            logging.debug(msg)
+            logger.debug(msg)
 
     def set_fluid_back_ends(self, memorise_fluid_properties):
         """Set the fluid back ends."""
         # this must be ordered as the fluid property memorisation calls
         # the mass fractions of the different fluids as keys in a given order.
         self.fluids_backends = OrderedDict()
 
@@ -236,15 +236,15 @@
             self.fluids_backends[fluid] = backend
             self.fluids[i] = fluid
 
             msg += fluid + ', '
             i += 1
 
         msg = msg[:-2] + '.'
-        logging.debug(msg)
+        logger.debug(msg)
 
         # initialise fluid property memorisation function for this network
         fp.Memorise.add_fluids(self.fluids_backends, memorise_fluid_properties)
 
         # set up results dataframe for connections
         cols = (
             ['m', 'p', 'h', 'T', 'v', 'vol', 's', 'x', 'Td_bp']
@@ -309,60 +309,60 @@
             unit = prop + '_unit'
             if unit in kwargs:
                 if kwargs[unit] in fpd[prop]['units']:
                     self.__dict__.update({unit: kwargs[unit]})
                     msg = (
                         'Setting ' + fpd[prop]['text'] +
                         ' unit: ' + kwargs[unit] + '.')
-                    logging.debug(msg)
+                    logger.debug(msg)
                 else:
                     keys = ', '.join(fpd[prop]['units'].keys())
                     msg = (
                         'Allowed units for ' +
                         fpd[prop]['text'] + ' are: ' + keys)
-                    logging.error(msg)
+                    logger.error(msg)
                     raise ValueError(msg)
 
         for prop in ['m', 'p', 'h']:
             if prop + '_range' in kwargs:
                 if isinstance(kwargs[prop + '_range'], list):
                     self.__dict__.update(
                         {prop + '_range_SI': hlp.convert_to_SI(
                             prop, np.array(kwargs[prop + '_range']),
                             self.get_attr(prop + '_unit'))})
                 else:
                     msg = (
                         'Specify the value range as list: [' + prop +
                         '_min, ' + prop + '_max]')
-                    logging.error(msg)
+                    logger.error(msg)
                     raise TypeError(msg)
 
                 limits = self.get_attr(prop + '_range_SI')
                 msg = (
                     'Setting ' + fpd[prop]['text'] +
                     ' limits\nmin: ' + str(limits[0]) + ' ' +
-                    self.get_attr(prop + '_unit') + '\n'
+                    fpd[prop]['SI_unit'] + '\n'
                     'max: ' + str(limits[1]) + ' ' +
-                    self.get_attr(prop + '_unit'))
-                logging.debug(msg)
+                    fpd[prop]['SI_unit'])
+                logger.debug(msg)
 
         # update non SI value ranges
         for prop in ['m', 'p', 'h']:
             self.__dict__.update({
                 prop + '_range': hlp.convert_from_SI(
                     prop, self.get_attr(prop + '_range_SI'),
                     self.get_attr(prop + '_unit')
                 )
             })
 
         self.iterinfo = kwargs.get('iterinfo', self.iterinfo)
 
         if not isinstance(self.iterinfo, bool):
             msg = ('Network parameter iterinfo must be True or False!')
-            logging.error(msg)
+            logger.error(msg)
             raise TypeError(msg)
 
     def get_attr(self, key):
         r"""
         Get the value of a network attribute.
 
         Parameters
@@ -375,15 +375,15 @@
         out :
             Specified attribute.
         """
         if key in self.__dict__:
             return self.__dict__[key]
         else:
             msg = 'Network has no attribute \"' + str(key) + '\".'
-            logging.error(msg)
+            logger.error(msg)
             raise KeyError(msg)
 
     def add_subsys(self, *args):
         r"""
         Add one or more subsystems to the network.
 
         Parameters
@@ -410,15 +410,15 @@
         c : tespy.connections.connection.Connection
             Connection object with specified label, None if no Connection of
             the network has this label.
         """
         try:
             return self.conns.loc[label, 'object']
         except KeyError:
-            logging.warning('Connection with label ' + label + ' not found.')
+            logger.warning('Connection with label %s not found.', label)
             return None
 
     def get_comp(self, label):
         r"""
         Get Component via label.
 
         Parameters
@@ -431,15 +431,15 @@
         c : tespy.components.component.Component
             Component object with specified label, None if no Component of
             the network has this label.
         """
         try:
             return self.comps.loc[label, 'object']
         except KeyError:
-            logging.warning('Component with label ' + label + ' not found.')
+            logger.warning('Component with label %s not found.', label)
             return None
 
     def add_conns(self, *args):
         r"""
         Add one or more connections to the network.
 
         Parameters
@@ -448,53 +448,53 @@
             The connection to be added to the network, connections objects ci
             :code:`add_conns(c1, c2, c3, ...)`.
         """
         for c in args:
             if not isinstance(c, con.Connection):
                 msg = ('Must provide tespy.connections.connection.Connection '
                        'objects as parameters.')
-                logging.error(msg)
+                logger.error(msg)
                 raise TypeError(msg)
 
             elif c.label in self.conns.index:
                 msg = (
                     'There is already a connection with the label ' +
                     c.label + '. The connection labels must be unique!')
-                logging.error(msg)
+                logger.error(msg)
                 raise ValueError(msg)
 
             c.good_starting_values = False
 
             self.conns.loc[c.label] = [
                 c, c.source, c.source_id, c.target, c.target_id]
 
             self.results['Connection'].loc[c.label] = np.nan
 
             msg = 'Added connection ' + c.label + ' to network.'
-            logging.debug(msg)
+            logger.debug(msg)
             # set status "checked" to false, if connection is added to network.
             self.checked = False
         self._add_comps(*args)
 
     def del_conns(self, *args):
         """
         Remove one or more connections from the network.
 
         Parameters
         ----------
         c : tespy.connections.connection.Connection
             The connection to be removed from the network, connections objects
             ci :code:`del_conns(c1, c2, c3, ...)`.
         """
-        comps = list(set([cp for c in args for cp in [c.source, c.target]]))
+        comps = list({cp for c in args for cp in [c.source, c.target]})
         for c in args:
             self.conns.drop(c.label, inplace=True)
             self.results['Connection'].drop(c.label, inplace=True)
             msg = ('Deleted connection ' + c.label + ' from network.')
-            logging.debug(msg)
+            logger.debug(msg)
 
         self._del_comps(comps)
 
         # set status "checked" to false, if connection is deleted from network.
         self.checked = False
 
     def check_conns(self):
@@ -510,15 +510,15 @@
             targets = ", ".join(targets)
 
             msg = (
                 f"The source \"{c.source.label}\" ({c.source_id}) is attached "
                 f"to more than one component on the target side: {targets}. "
                 "Please check your network configuration."
             )
-            logging.error(msg)
+            logger.error(msg)
             raise hlp.TESPyNetworkError(msg)
 
         dub = self.conns.loc[
             self.conns.duplicated(['target', 'target_id'])
         ]
         for c in dub['object']:
             sources = []
@@ -529,29 +529,29 @@
                 sources += [f"\"{conns.source.label}\" ({conns.source_id})"]
             sources = ", ".join(sources)
             msg = (
                 f"The target \"{c.target.label}\" ({c.target_id}) is attached "
                 f"to more than one component on the source side: {sources}. "
                 "Please check your network configuration."
             )
-            logging.error(msg)
+            logger.error(msg)
             raise hlp.TESPyNetworkError(msg)
 
     def _add_comps(self, *args):
         r"""
         Add to network's component DataFrame from added connections.
 
         Parameters
         ----------
         c : tespy.connections.connection.Connection
             The connections, which have been added to the network. The
             components are extracted from these information.
         """
         # get unique components in new connections
-        comps = list(set([cp for c in args for cp in [c.source, c.target]]))
+        comps = list({cp for c in args for cp in [c.source, c.target]})
         # add to the dataframe of components
         for comp in comps:
             if comp.label in self.comps.index:
                 if self.comps.loc[comp.label, 'object'] == comp:
                     continue
                 else:
                     comp_type = comp.__class__.__name__
@@ -586,15 +586,15 @@
         for comp in comps:
             if (
                 comp not in self.conns["source"].values and
                 comp not in self.conns["target"].values
             ):
                 self.comps.drop(comp.label, inplace=True)
                 msg = f"Deleted component {comp.label} from network."
-                logging.debug(msg)
+                logger.debug(msg)
 
     def add_ude(self, *args):
         r"""
         Add a user defined function to the network.
 
         Parameters
         ----------
@@ -602,43 +602,43 @@
             The objects to be added to the network, UserDefinedEquation objects
             ci :code:`del_conns(c1, c2, c3, ...)`.
         """
         for c in args:
             if not isinstance(c, hlp.UserDefinedEquation):
                 msg = ('Must provide tespy.connections.connection.Connection '
                        'objects as parameters.')
-                logging.error(msg)
+                logger.error(msg)
                 raise TypeError(msg)
 
             elif c.label in self.user_defined_eq:
                 msg = (
                     'There is already a UserDefinedEquation with the label ' +
                     c.label + '. The UserDefinedEquation labels must be '
                     'unique within a network')
-                logging.error(msg)
+                logger.error(msg)
                 raise ValueError(msg)
 
             self.user_defined_eq[c.label] = c
             msg = 'Added UserDefinedEquation ' + c.label + ' to network.'
-            logging.debug(msg)
+            logger.debug(msg)
 
     def del_ude(self, *args):
         """
         Remove a user defined function from the network.
 
         Parameters
         ----------
         c : tespy.tools.helpers.UserDefinedEquation
             The objects to be added deleted from the network,
             UserDefinedEquation objects ci :code:`del_conns(c1, c2, c3, ...)`.
         """
         for c in args:
             del self.user_defined_eq[c.label]
             msg = 'Deleted UserDefinedEquation ' + c.label + ' from network.'
-            logging.debug(msg)
+            logger.debug(msg)
 
     def add_busses(self, *args):
         r"""
         Add one or more busses to the network.
 
         Parameters
         ----------
@@ -646,15 +646,15 @@
             The bus to be added to the network, bus objects bi
             :code:`add_busses(b1, b2, b3, ...)`.
         """
         for b in args:
             if self.check_busses(b):
                 self.busses[b.label] = b
                 msg = f"Added bus {b.label} to network."
-                logging.debug(msg)
+                logger.debug(msg)
 
                 self.results[b.label] = pd.DataFrame(
                     columns=[
                         'component value', 'bus value', 'efficiency',
                         'design value'
                     ],
                     dtype='float64')
@@ -669,62 +669,67 @@
             The bus to be removed from the network, bus objects bi
             :code:`add_busses(b1, b2, b3, ...)`.
         """
         for b in args:
             if b in self.busses.values():
                 del self.busses[b.label]
                 msg = f"Deleted bus {b.label} from network."
-                logging.debug(msg)
+                logger.debug(msg)
 
                 del self.results[b.label]
 
+    def _convergence_check(self):
+        """Check convergence status of a simulation."""
+        msg = 'Calculation did not converge!'
+        assert (not self.lin_dep) and self.converged, msg
+
     def check_busses(self, b):
         r"""
         Checksthe busses to be added for type, duplicates and identical labels.
 
         Parameters
         ----------
         b : tespy.connections.bus.Bus
             The bus to be checked.
         """
         if isinstance(b, con.Bus):
             if len(self.busses) > 0:
                 if b in self.busses.values():
                     msg = f"The network contains the bus {b.label} already."
-                    logging.error(msg)
+                    logger.error(msg)
                     raise hlp.TESPyNetworkError(msg)
                 elif b.label in self.busses:
                     msg = f"The network already has a bus labeld {b.label}."
-                    logging.error(msg)
+                    logger.error(msg)
                     raise hlp.TESPyNetworkError(msg)
                 else:
                     return True
             else:
                 return True
         else:
             msg = 'Only objects of type bus are allowed in *args.'
-            logging.error(msg)
+            logger.error(msg)
             raise TypeError(msg)
 
     def check_network(self):
         r"""Check if components are connected properly within the network."""
         if len(self.conns) == 0:
             msg = (
                 'No connections have been added to the network, please make '
                 'sure to add your connections with the .add_conns() method.'
             )
-            logging.error(msg)
+            logger.error(msg)
             raise hlp.TESPyNetworkError(msg)
 
         if len(self.fluids) == 0:
             msg = (
                 'Network has no fluids, please specify a list with fluids on '
                 'network creation.'
             )
-            logging.error(msg)
+            logger.error(msg)
             raise hlp.TESPyNetworkError(msg)
 
         self.check_conns()
         self.init_components()
         # count number of incoming and outgoing connections and compare to
         # expected values
         for comp in self.comps['object']:
@@ -734,32 +739,32 @@
             if num_o != comp.num_o:
                 msg = (
                     f"The component {comp.label} is missing "
                     f"{comp.num_o - num_o} outgoing connections. Make sure "
                     "all outlets are connected and all connections have been "
                     "added to the network."
                 )
-                logging.error(msg)
+                logger.error(msg)
                 # raise an error in case network check is unsuccesful
                 raise hlp.TESPyNetworkError(msg)
             elif num_i != comp.num_i:
                 msg = (
                     f"The component {comp.label} is missing "
                     f"{comp.num_i - num_i} incoming connections. Make sure "
                     "all inlets are connected and all connections have been "
                     "added to the network."
                 )
-                logging.error(msg)
+                logger.error(msg)
                 # raise an error in case network check is unsuccesful
                 raise hlp.TESPyNetworkError(msg)
 
         # network checked
         self.checked = True
         msg = 'Networkcheck successful.'
-        logging.info(msg)
+        logger.info(msg)
 
     def init_components(self):
         r"""Set up necessary component information."""
         for comp in self.comps["object"]:
             # get incoming and outgoing connections of a component
             sources = self.conns[self.conns['source'] == comp]
             sources = sources['source_id'].sort_values().index.tolist()
@@ -825,15 +830,15 @@
 
         if self.mode == 'offdesign':
             self.redesign = True
             if self.design_path is None:
                 # must provide design_path
                 msg = ('Please provide "design_path" for every offdesign '
                        'calculation.')
-                logging.error(msg)
+                logger.error(msg)
                 raise hlp.TESPyNetworkError(msg)
 
             # load design case
             if self.new_design:
                 self.init_offdesign_params()
 
             self.init_offdesign()
@@ -845,15 +850,15 @@
             # for offdesign cases good starting values should be available
             self.init_fluids()
 
         # generic fluid property initialisation
         self.init_properties()
 
         msg = 'Network initialised.'
-        logging.info(msg)
+        logger.info(msg)
 
     def init_set_properties(self):
         """Specification of SI values for user set values."""
         # fluid property values
         for c in self.conns['object']:
             # set all specifications to False
             self.specifications['Connection'].loc[c.label] = False
@@ -927,15 +932,15 @@
                     c.fluid.val[fluid] = 0
                     c.fluid.val0[fluid] = 0
                     c.fluid.val_set[fluid] = False
 
         msg = (
             'Updated fluid property SI values and fluid mass fraction for '
             'user specified connection parameters.')
-        logging.debug(msg)
+        logger.debug(msg)
 
     def init_design(self):
         r"""
         Initialise a design calculation.
 
         Offdesign parameters are unset, design parameters are set. If
         :code:`local_offdesign` is :code:`True` for connections or components,
@@ -949,15 +954,15 @@
             # local_offdesign activated from their respective design path
             if c.local_offdesign:
                 if c.design_path is None:
                     msg = (
                         'The parameter local_offdesign is True for the '
                         'connection ' + c.label + ', an individual '
                         'design_path must be specified in this case!')
-                    logging.error(msg)
+                    logger.error(msg)
                     raise hlp.TESPyNetworkError(msg)
 
                 # unset design parameters
                 for var in c.design:
                     c.get_attr(var).val_set = False
                 # set offdesign parameters
                 for var in c.offdesign:
@@ -965,15 +970,15 @@
 
                 # read design point information
                 df = self.init_read_connections(c.design_path)
                 msg = (
                     'Reading individual design point information for '
                     'connection ' + c.label + ' from path ' + c.design_path +
                     'connections.')
-                logging.debug(msg)
+                logger.debug(msg)
 
                 # write data to connections
                 self.init_conn_design_params(c, df)
 
             else:
                 # unset all design values
                 c.m.design = np.nan
@@ -1036,15 +1041,15 @@
                         cp.get_attr(var).val = cp.get_attr(var).design
                         switched = True
                         msg += var + ', '
 
                 if switched:
                     msg = (msg[:-2] + ' to design value at component ' +
                            cp.label + '.')
-                    logging.debug(msg)
+                    logger.debug(msg)
 
                 cp.new_design = False
 
             else:
                 # switch connections to design mode
                 if self.redesign:
                     for var in cp.design:
@@ -1052,15 +1057,15 @@
 
                     for var in cp.offdesign:
                         cp.get_attr(var).is_set = False
 
                 cp.set_parameters(self.mode, series)
 
             # component initialisation
-            cp.comp_init(self)
+            cp.preprocess(self)
             ct = cp.__class__.__name__
             for spec in self.specifications[ct].keys():
                 if len(cp.get_attr(self.specifications['lookup'][spec])) > 0:
                     self.specifications[ct][spec].loc[cp.label] = (
                         cp.get_attr(self.specifications['lookup'][spec]))
 
             # count number of component equations and variables
@@ -1094,15 +1099,15 @@
         # iter through unique types of components (class names)
         for c in df_comps['comp_type'].unique():
             path = hlp.modify_path_os(
                 self.design_path + '/components/' + c + '.csv')
             msg = (
                 'Reading design point information for components of type '
                 + c + ' from path ' + path + '.')
-            logging.debug(msg)
+            logger.debug(msg)
 
             # read data
             df = pd.read_csv(
                 path, sep=';', decimal='.', converters={
                     'busses': ast.literal_eval,
                     'bus_P_ref': ast.literal_eval})
             df.set_index('label', inplace=True)
@@ -1123,44 +1128,44 @@
                 else:
                     data = df.loc[comp.label]
 
                 # write data to components
                 self.init_comp_design_params(comp, data)
 
         msg = 'Done reading design point information for components.'
-        logging.debug(msg)
+        logger.debug(msg)
 
         # read connection design point information
         df = self.init_read_connections(self.design_path)
         msg = (
             'Reading design point information for connections from path ' +
             self.design_path + '/connections.csv.')
-        logging.debug(msg)
+        logger.debug(msg)
 
         # iter through connections
         for c in self.conns['object']:
 
             # read data of connections with individual design_path
             if c.design_path is not None:
                 df_c = self.init_read_connections(c.design_path)
                 msg = (
                     'Reading individual design point information for '
                     'connection ' + c.label + ' from path ' + c.design_path +
                     '/connections.csv.')
-                logging.debug(msg)
+                logger.debug(msg)
 
                 # write data
                 self.init_conn_design_params(c, df_c)
 
             else:
                 # write data
                 self.init_conn_design_params(c, df)
 
         msg = 'Done reading design point information for connections.'
-        logging.debug(msg)
+        logger.debug(msg)
 
     def init_comp_design_params(self, component, data):
         r"""
         Write design point information to components.
 
         Parameters
         ----------
@@ -1204,23 +1209,23 @@
             conn_id = conn.index[0]
             for var in ['m', 'p', 'h', 'v', 'x', 'T', 'Td_bp']:
                 c.get_attr(var).design = hlp.convert_to_SI(
                     var, df.loc[conn_id, var], df.loc[conn_id, var + '_unit'])
             c.vol.design = c.v.design / c.m.design
             for fluid in self.fluids:
                 c.fluid.design[fluid] = df.loc[conn_id, fluid]
-        except IndexError:
+        except IndexError as iex:
             # no matches in the connections of the network and the design files
             msg = (
-                'Could not find connection ' + c.label + ' in design case. '
+                'Could not find connection %s in design case. '
                 'Please, make sure no connections have been modified or '
                 'components have been relabeled for your offdesign '
                 'calculation.')
-            logging.error(msg)
-            raise hlp.TESPyNetworkError(msg)
+            logger.exception(msg, c.label)
+            raise hlp.TESPyNetworkError(msg) from iex
 
     def init_offdesign(self):
         r"""
         Switch components and connections from design to offdesign mode.
 
         Note
         ----
@@ -1250,15 +1255,15 @@
                 for var in c.offdesign:
                     c.get_attr(var).val_set = True
                     c.get_attr(var).val_SI = c.get_attr(var).design
 
                 c.new_design = False
 
         msg = 'Switched connections from design to offdesign.'
-        logging.debug(msg)
+        logger.debug(msg)
 
         for cp in self.comps['object']:
             if not cp.local_design:
                 # unset variables provided in .design attribute
                 for var in cp.design:
                     cp.get_attr(var).is_set = False
 
@@ -1275,30 +1280,30 @@
                         cp.get_attr(var).val = cp.get_attr(var).design
                         switched = True
                         msg += var + ', '
 
                 if switched:
                     msg = (msg[:-2] + ' to design value at component ' +
                            cp.label + '.')
-                    logging.debug(msg)
+                    logger.debug(msg)
 
             # start component initialisation
-            cp.comp_init(self)
+            cp.preprocess(self)
             ct = cp.__class__.__name__
             for spec in self.specifications[ct].keys():
                 if len(cp.get_attr(self.specifications['lookup'][spec])) > 0:
                     self.specifications[ct][spec].loc[cp.label] = (
                         cp.get_attr(self.specifications['lookup'][spec]))
 
             cp.new_design = False
             self.num_comp_vars += cp.num_vars
             self.num_comp_eq += cp.num_eq
 
         msg = 'Switched components from design to offdesign.'
-        logging.debug(msg)
+        logger.debug(msg)
 
         # count bus equations and reindex bus dictionary
         for b in self.busses.values():
             self.busses[b.label] = b
             self.num_bus_eq += b.P.is_set * 1
 
     def init_fluids(self):
@@ -1318,26 +1323,30 @@
         # stop fluid propagation for single fluid networks
         if len(self.fluids) == 1:
             return
 
         # fluid propagation from set values
         for c in self.conns['object']:
             if any(c.fluid.val_set.values()):
-                c.target.propagate_fluid_to_target(c, c.target)
-                c.source.propagate_fluid_to_source(c, c.source)
+                c.target.propagate_fluid_to_target(c, c, entry_point=True)
+                c.source.propagate_fluid_to_source(c, c, entry_point=True)
+
+        # To save resources:
+        # find empty fluid data and propagate from connections with data that
+        # are interfaced directly to those connections by a component
             if any(c.fluid.val0.values()):
-                c.target.propagate_fluid_to_target(c, c.target)
-                c.source.propagate_fluid_to_source(c, c.source)
+                c.target.propagate_fluid_to_target(c, c, entry_point=True)
+                c.source.propagate_fluid_to_source(c, c, entry_point=True)
 
-        # fluid starting value generation for components
+        # fluid starting value generation based on components
         for cp in self.comps['object']:
             cp.initialise_fluids()
 
         msg = 'Fluid initialisation done.'
-        logging.debug(msg)
+        logger.debug(msg)
 
     def init_properties(self):
         """
         Initialise the fluid properties on every connection of the network.
 
         - Set generic starting values for mass flow, enthalpy and pressure if
           not user specified, read from :code:`nit_path` or available from
@@ -1374,25 +1383,25 @@
 
                     c.good_starting_values = True
 
                 except IndexError:
                     msg = (
                         'Could not find connection ' + c.label + ' in '
                         'connections.csv of init_path ' + self.init_path + '.')
-                    logging.debug(msg)
+                    logger.debug(msg)
 
             if sum(c.fluid.val.values()) == 0:
                 msg = (
                     'The starting value for the fluid composition of the '
                     'connection ' + c.label + ' is empty. This might lead to '
                     'issues in the initialisation and solving process as '
                     'fluid property functions can not be called. Make sure '
                     'you specified a fluid composition in all parts of the '
                     'network.')
-                logging.warning(msg)
+                logger.warning(msg)
 
             for key in ['m', 'p', 'h']:
                 if not c.good_starting_values:
                     self.init_val0(c, key)
                 if not c.get_attr(key).val_set:
                     c.get_attr(key).val_SI = hlp.convert_to_SI(
                         key, c.get_attr(key).val0, c.get_attr(key).unit)
@@ -1425,36 +1434,36 @@
                 elif ((c.Td_bp.val_SI < 0 and c.Td_bp.val_set) or
                       (c.state.val == 'l' and c.state.is_set)):
                     h = fp.h_mix_pQ(c.get_flow(), 0)
                     if c.h.val_SI > h:
                         c.h.val_SI = h * 0.999
 
         msg = 'Generic fluid property specification complete.'
-        logging.debug(msg)
+        logger.debug(msg)
 
     def init_count_connections_parameters(self, c):
         """
         Count the number of parameters set on a connection.
 
         Parameters
         ----------
         c : tespy.connections.connection.Connection
             Connection count parameters of.
         """
         # variables 0 to 9: fluid properties
-        vars = self.specifications['Connection'].columns[:9]
-        row = [c.get_attr(var).val_set for var in vars]
+        local_vars = self.specifications['Connection'].columns[:9]
+        row = [c.get_attr(var).val_set for var in local_vars]
         self.num_conn_eq += row.count(True)
         # write information to specifaction dataframe
-        self.specifications['Connection'].loc[c.label, vars] = row
+        self.specifications['Connection'].loc[c.label, local_vars] = row
 
-        row = [c.get_attr(var).ref_set for var in vars]
+        row = [c.get_attr(var).ref_set for var in local_vars]
         self.num_conn_eq += row.count(True)
         # write refrenced value information to specifaction dataframe
-        self.specifications['Ref'].loc[c.label, vars] = row
+        self.specifications['Ref'].loc[c.label, local_vars] = row
 
         # variables 9 to last but one: fluid mass fractions
         fluids = self.specifications['Connection'].columns[9:-1]
         row = [c.fluid.val_set[fluid] for fluid in fluids]
         self.num_conn_eq += row.count(True)
         self.specifications['Connection'].loc[c.label, fluids] = row
 
@@ -1541,23 +1550,26 @@
         """
         path = hlp.modify_path_os(base_path + '/connections.csv')
         df = pd.read_csv(path, index_col=0, delimiter=';', decimal='.')
         return df
 
     def solve(self, mode, init_path=None, design_path=None,
               max_iter=50, min_iter=4, init_only=False, init_previous=True,
-              use_cuda=False, always_all_equations=True):
+              use_cuda=False, always_all_equations=True, print_results=True):
         r"""
         Solve the network.
 
         - Check network consistency.
         - Initialise calculation and preprocessing.
         - Perform actual calculation.
         - Postprocessing.
 
+        It is possible to check programatically, if a network was solved
+        successfully with the `.converged` property.
+
         Parameters
         ----------
         mode : str
             Choose from 'design' and 'offdesign'.
 
         init_path : str
             Path to the folder, where your network was saved to, e.g.
@@ -1593,14 +1605,15 @@
 
         Note
         ----
         For more information on the solution process have a look at the online
         documentation at tespy.readthedocs.io in the section "TESPy modules".
         """
         self.new_design = False
+        self.converged = False
         if self.design_path == design_path and design_path is not None:
             for c in self.conns['object']:
                 if c.new_design:
                     self.new_design = True
                     break
             if not self.new_design:
                 for cp in self.comps['object']:
@@ -1619,125 +1632,130 @@
         self.iter = 0
         self.use_cuda = use_cuda
         self.always_all_equations = always_all_equations
 
         if self.use_cuda and cu is None:
             msg = ('Specifying use_cuda=True requires cupy to be installed on '
                    'your machine. Numpy will be used instead.')
-            logging.warning(msg)
+            logger.warning(msg)
             self.use_cuda = False
 
         if mode != 'offdesign' and mode != 'design':
             msg = 'Mode must be "design" or "offdesign".'
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
         else:
             self.mode = mode
 
         msg = (
             'Solver properties: mode=' + self.mode + ', init_path=' +
             str(self.init_path) + ', design_path=' + str(self.design_path) +
             ', max_iter=' + str(max_iter) + ', min_iter=' + str(min_iter) +
             ', init_only=' + str(init_only))
-        logging.debug(msg)
+        logger.debug(msg)
 
         if not self.checked:
             self.check_network()
 
         msg = (
             'Network properties: '
             'number of components=' + str(len(self.comps)) +
             ', number of connections=' + str(len(self.conns.index)) +
             ', number of busses=' + str(len(self.busses)))
-        logging.debug(msg)
+        logger.debug(msg)
 
         self.initialise()
 
         if init_only:
             return
 
         msg = 'Starting solver.'
-        logging.info(msg)
+        logger.info(msg)
 
         self.solve_determination()
-        self.solve_loop()
+        self.solve_loop(print_results=print_results)
 
         if self.lin_dep:
             msg = (
                 'Singularity in jacobian matrix, calculation aborted! Make '
                 'sure your network does not have any linear dependencies in '
                 'the parametrisation. Other reasons might be\n-> given '
                 'temperature with given pressure in two phase region, try '
                 'setting enthalpy instead or provide accurate starting value '
                 'for pressure.\n-> given logarithmic temperature differences '
                 'or kA-values for heat exchangers, \n-> support better '
                 'starting values.\n-> bad starting value for fuel mass flow '
                 'of combustion chamber, provide small (near to zero, but not '
                 'zero) starting value.')
-            logging.error(msg)
+            logger.error(msg)
             return
 
         self.postprocessing()
         fp.Memorise.del_memory(self.fluids)
 
         if not self.progress:
             msg = (
                 'The solver does not seem to make any progress, aborting '
                 'calculation. Residual value is '
                 '{:.2e}'.format(norm(self.residual)) + '. This frequently '
                 'happens, if the solver pushes the fluid properties out of '
                 'their feasible range.')
-            logging.warning(msg)
+            logger.warning(msg)
             return
 
         msg = 'Calculation complete.'
-        logging.info(msg)
+        logger.info(msg)
+        return
 
-    def solve_loop(self):
+    def solve_loop(self, print_results=True):
         r"""Loop of the newton algorithm."""
         # parameter definitions
         self.res = np.array([])
         self.residual = np.zeros([self.num_vars])
         self.increment = np.ones([self.num_vars])
         self.jacobian = np.zeros((self.num_vars, self.num_vars))
 
         self.start_time = time()
         self.progress = True
 
         if self.iterinfo:
-            self.print_iterinfo_head()
-
-        for self.iter in range(self.max_iter):
+            self.iterinfo_head(print_results)
 
+        for count in range(self.max_iter):
+            self.iter = count
             self.increment_filter = np.absolute(self.increment) < err ** 2
             self.solve_control()
             self.res = np.append(self.res, norm(self.residual))
 
             if self.iterinfo:
-                self.print_iterinfo_body()
+                self.iterinfo_body(print_results)
 
             if ((self.iter >= self.min_iter and self.res[-1] < err ** 0.5) or
                     self.lin_dep):
+                self.converged = True
                 break
 
             if self.iter > 40:
                 if (all(self.res[(self.iter - 3):] >= self.res[-3] * 0.95) and
                         self.res[-1] >= self.res[-2] * 0.95):
                     self.progress = False
                     break
 
         self.end_time = time()
 
-        self.print_iterinfo_tail()
+        if self.iterinfo:
+            self.iterinfo_tail(print_results)
 
         if self.iter == self.max_iter - 1:
             msg = ('Reached maximum iteration count (' + str(self.max_iter) +
                    '), calculation stopped. Residual value is '
                    '{:.2e}'.format(norm(self.residual)))
-            logging.warning(msg)
+            logger.warning(msg)
+
+        return
 
     def solve_determination(self):
         r"""Check, if the number of supplied parameters is sufficient."""
         # number of variables per connection
         self.num_conn_vars = len(self.fluids) + 3
 
         # number of user defined functions
@@ -1753,116 +1771,144 @@
                 for c in func.conns}
 
         # total number of variables
         self.num_vars = (
             self.num_conn_vars * len(self.conns.index) + self.num_comp_vars)
 
         msg = 'Number of connection equations: ' + str(self.num_conn_eq) + '.'
-        logging.debug(msg)
+        logger.debug(msg)
 
         msg = 'Number of bus equations: ' + str(self.num_bus_eq) + '.'
-        logging.debug(msg)
+        logger.debug(msg)
 
         msg = 'Number of component equations: ' + str(self.num_comp_eq) + '.'
-        logging.debug(msg)
+        logger.debug(msg)
 
         msg = 'Number of user defined equations: ' + str(self.num_ude_eq) + '.'
-        logging.debug(msg)
+        logger.debug(msg)
 
         msg = 'Total number of variables: ' + str(self.num_vars) + '.'
-        logging.debug(msg)
+        logger.debug(msg)
         msg = 'Number of component variables: ' + str(self.num_comp_vars) + '.'
-        logging.debug(msg)
+        logger.debug(msg)
         msg = ('Number of connection variables: ' +
                str(self.num_conn_vars * len(self.conns.index)) + '.')
-        logging.debug(msg)
+        logger.debug(msg)
 
         n = (
             self.num_comp_eq + self.num_conn_eq +
             self.num_bus_eq + self.num_ude_eq)
         if n > self.num_vars:
             msg = ('You have provided too many parameters: ' +
                    str(self.num_vars) + ' required, ' + str(n) +
                    ' supplied. Aborting calculation!')
-            logging.error(msg)
+            logger.error(msg)
             raise hlp.TESPyNetworkError(msg)
         elif n < self.num_vars:
             msg = ('You have not provided enough parameters: '
                    + str(self.num_vars) + ' required, ' + str(n) +
                    ' supplied. Aborting calculation!')
-            logging.error(msg)
+            logger.error(msg)
             raise hlp.TESPyNetworkError(msg)
 
-    def print_iterinfo_head(self):
+    def iterinfo_head(self, print_results=True):
         """Print head of convergence progress."""
-        if self.num_comp_vars == 0:
-            # iterinfo printout without any custom variables
-            msg = (
-                'iter\t| residual | massflow | pressure | enthalpy | fluid\n')
-            msg += '-' * 8 + '+----------' * 4 + '+' + '-' * 9
-
-        else:
-            # iterinfo printout with custom variables in network
-            msg = ('iter\t| residual | massflow | pressure | enthalpy | '
-                   'fluid    | custom\n')
-            msg += '-' * 8 + '+----------' * 5 + '+' + '-' * 9
+        # Start with defining the format here
+        self.iterinfo_fmt = ' {iter:5s} | {residual:10s} | {progress:10s} '
+        self.iterinfo_fmt += '| {massflow:10s} | {pressure:10s} | {enthalpy:10s} '
+        self.iterinfo_fmt += '| {fluid:10s} | {custom:10s} '
+        # Use the format to create the first logging entry
+        custom = '' if self.num_comp_vars == 0 else 'custom'
+        msg = self.iterinfo_fmt.format(iter='iter',
+                                       residual='residual',
+                                       progress='progress',
+                                       massflow='massflow',
+                                       pressure='pressure',
+                                       enthalpy='enthalpy',
+                                       fluid='fluid',
+                                       custom=custom)
+        logger.progress(0, msg)
+        msg2 = '-' * 7 + '+------------' * 6 + "+"
+        if self.num_comp_vars > 0:
+            msg2 += '+-------------'
 
-        print(msg)
+        logger.progress(0, msg2)
+        if print_results:
+            print('\n' + msg + '\n' + msg2)
+        return
 
-    def print_iterinfo_body(self):
+    def iterinfo_body(self, print_results=True):
         """Print convergence progress."""
         vec = self.increment[0:-(self.num_comp_vars + 1)]
-        msg = (str(self.iter + 1))
-
-        if not self.lin_dep and not np.isnan(norm(self.residual)):
-            msg += '\t| ' + '{:.2e}'.format(norm(self.residual))
-            msg += ' | ' + '{:.2e}'.format(norm(vec[0::self.num_conn_vars]))
-            msg += ' | ' + '{:.2e}'.format(norm(vec[1::self.num_conn_vars]))
-            msg += ' | ' + '{:.2e}'.format(norm(vec[2::self.num_conn_vars]))
+        iter_str = str(self.iter + 1)
+        residual_norm = norm(self.residual)
+        residual = 'NaN'
+        progress = 'NaN'
+        massflow = 'NaN'
+        pressure = 'NaN'
+        enthalpy = 'NaN'
+        fluid = 'NaN'
+        custom = 'NaN'
+
+        if not np.isnan(residual_norm):
+            residual = '{:.2e}'.format(residual_norm)
+
+        if not self.lin_dep and not np.isnan(residual_norm):
+            massflow = '{:.2e}'.format(norm(vec[0::self.num_conn_vars]))
+            pressure = '{:.2e}'.format(norm(vec[1::self.num_conn_vars]))
+            enthalpy = '{:.2e}'.format(norm(vec[2::self.num_conn_vars]))
 
             ls = []
             for f in range(len(self.fluids)):
                 ls += vec[3 + f::self.num_conn_vars].tolist()
-
-            msg += ' | ' + '{:.2e}'.format(norm(ls))
+            fluid = '{:.2e}'.format(norm(ls))
 
             if self.num_comp_vars > 0:
-                msg += ' | ' + '{:.2e}'.format(norm(
+                custom = '{:.2e}'.format(norm(
                     self.increment[-self.num_comp_vars:]))
-
-        else:
-            if np.isnan(norm(self.residual)):
-                msg += '\t|      nan'
             else:
-                msg += '\t| ' + '{:.2e}'.format(norm(self.residual))
-            msg += ' |      nan' * 4
-            if self.num_comp_vars > 0:
-                msg += ' |      nan'
+                custom = ''
 
-        print(msg)
+        progress_val = -1
+        if not np.isnan(residual_norm) and residual_norm > np.finfo(float).eps*100:
+            # This should not be hardcoded here.
+            progress_min = np.log(err)
+            progress_max = np.log(err) * -1
+            progress_val = np.log(max(residual_norm, err)) * -1
+            # Scale to 0-1
+            progress_val = max(0, min(1, (progress_val - progress_min) / (progress_max - progress_min)))
+            # Scale to 100%
+            progress_val = int((progress_val - progress_min) / (progress_max - progress_min) * 100)
+            progress = '{:d} %'.format(progress_val)
+
+        msg = self.iterinfo_fmt.format(iter=iter_str,
+                                       residual=residual,
+                                       progress=progress,
+                                       massflow=massflow,
+                                       pressure=pressure,
+                                       enthalpy=enthalpy,
+                                       fluid=fluid,
+                                       custom=custom)
+        logger.progress(progress_val, msg)
+        if print_results:
+            print(msg)
+        return
 
-    def print_iterinfo_tail(self):
+    def iterinfo_tail(self, print_results=True):
         """Print tail of convergence progress."""
-        msg = (
-            'Total iterations: ' + str(self.iter + 1) + ', Calculation '
-            'time: ' + str(round(self.end_time - self.start_time, 1)) +
-            ' s, Iterations per second: ')
-        ips = 'inf'
-        if self.end_time != self.start_time:
-            ips = str(round(
-                (self.iter + 1) / (self.end_time - self.start_time), 2))
-        msg += ips
-        logging.debug(msg)
-
-        if self.iterinfo:
-            if self.num_comp_vars == 0:
-                print('-' * 8 + '+----------' * 4 + '+' + '-' * 9)
-            else:
-                print('-' * 8 + '+----------' * 5 + '+' + '-' * 9)
+        num_iter = self.iter + 1
+        clc_time = self.end_time - self.start_time
+        num_ips = num_iter / clc_time if clc_time > 1e-10 else np.Inf
+        msg = '-' * 7 + '+------------' * 7
+        logger.progress(100, msg)
+        msg = 'Total iterations: {0:d}, Calculation time: {1:.2f} s, Iterations per second: {2:.2f}'.format(num_iter, clc_time, num_ips)
+        logger.debug(msg)
+        if print_results:
             print(msg)
+        return
 
     def matrix_inversion(self):
         """Invert matrix of derivatives and caluclate increment."""
         self.lin_dep = True
         try:
             # Let the matrix inversion be computed by the GPU if use_cuda in
             # global_vars.py is true.
@@ -1996,19 +2042,19 @@
         """
         fl = hlp.single_fluid(c.fluid.val)
 
         if fl is not None:
             # pressure
             if c.p.val_SI < fp.Memorise.value_range[fl][0] and not c.p.val_set:
                 c.p.val_SI = fp.Memorise.value_range[fl][0]
-                logging.debug(self.property_range_message(c, 'p'))
+                logger.debug(self.property_range_message(c, 'p'))
             elif (c.p.val_SI > fp.Memorise.value_range[fl][1] and
                   not c.p.val_set):
                 c.p.val_SI = fp.Memorise.value_range[fl][1]
-                logging.debug(self.property_range_message(c, 'p'))
+                logger.debug(self.property_range_message(c, 'p'))
 
             # enthalpy
             try:
                 hmin = fp.h_pT(
                     c.p.val_SI, fp.Memorise.value_range[fl][2] * 1.001, fl)
             except ValueError:
                 f = 1.05
@@ -2019,73 +2065,73 @@
             while True:
                 try:
                     hmax = fp.h_pT(c.p.val_SI, T, fl)
                     break
                 except ValueError as e:
                     T *= 0.99
                     if T < fp.Memorise.value_range[fl][2]:
-                        raise ValueError(e)
+                        raise ValueError(e) from e
 
             if c.h.val_SI < hmin and not c.h.val_set:
                 if hmin < 0:
                     c.h.val_SI = hmin * 0.9999
                 else:
                     c.h.val_SI = hmin * 1.0001
-                logging.debug(self.property_range_message(c, 'h'))
+                logger.debug(self.property_range_message(c, 'h'))
 
             elif c.h.val_SI > hmax and not c.h.val_set:
                 c.h.val_SI = hmax * 0.9999
-                logging.debug(self.property_range_message(c, 'h'))
+                logger.debug(self.property_range_message(c, 'h'))
 
             if ((c.Td_bp.val_set or c.state.is_set) and
                     not c.h.val_set and self.iter < 3):
                 if (c.Td_bp.val_SI > 0 or
                         (c.state.val == 'g' and c.state.is_set)):
                     h = fp.h_mix_pQ(c.get_flow(), 1)
                     if c.h.val_SI < h:
                         c.h.val_SI = h * 1.01
-                        logging.debug(self.property_range_message(c, 'h'))
+                        logger.debug(self.property_range_message(c, 'h'))
                 elif (c.Td_bp.val_SI < 0 or
                       (c.state.val == 'l' and c.state.is_set)):
                     h = fp.h_mix_pQ(c.get_flow(), 0)
                     if c.h.val_SI > h:
                         c.h.val_SI = h * 0.99
-                        logging.debug(self.property_range_message(c, 'h'))
+                        logger.debug(self.property_range_message(c, 'h'))
 
         elif self.iter < 4 and not c.good_starting_values:
             # pressure
             if c.p.val_SI <= self.p_range_SI[0] and not c.p.val_set:
                 c.p.val_SI = self.p_range_SI[0]
-                logging.debug(self.property_range_message(c, 'p'))
+                logger.debug(self.property_range_message(c, 'p'))
 
             elif c.p.val_SI >= self.p_range_SI[1] and not c.p.val_set:
                 c.p.val_SI = self.p_range_SI[1]
-                logging.debug(self.property_range_message(c, 'p'))
+                logger.debug(self.property_range_message(c, 'p'))
 
             # enthalpy
             if c.h.val_SI < self.h_range_SI[0] and not c.h.val_set:
                 c.h.val_SI = self.h_range_SI[0]
-                logging.debug(self.property_range_message(c, 'h'))
+                logger.debug(self.property_range_message(c, 'h'))
 
             elif c.h.val_SI > self.h_range_SI[1] and not c.h.val_set:
                 c.h.val_SI = self.h_range_SI[1]
-                logging.debug(self.property_range_message(c, 'h'))
+                logger.debug(self.property_range_message(c, 'h'))
 
             # temperature
             if c.T.val_set and not c.h.val_set:
                 self.solve_check_temperature(c)
 
         # mass flow
         if c.m.val_SI <= self.m_range_SI[0] and not c.m.val_set:
             c.m.val_SI = self.m_range_SI[0]
-            logging.debug(self.property_range_message(c, 'm'))
+            logger.debug(self.property_range_message(c, 'm'))
 
         elif c.m.val_SI >= self.m_range_SI[1] and not c.m.val_set:
             c.m.val_SI = self.m_range_SI[1]
-            logging.debug(self.property_range_message(c, 'm'))
+            logger.debug(self.property_range_message(c, 'm'))
 
     def solve_check_temperature(self, c):
         r"""
         Check if temperature is within user specified limits.
 
         Parameters
         ----------
@@ -2102,19 +2148,19 @@
              f in flow[3].keys() if flow[3][f] > err]
         ) - 100
         hmin = fp.h_mix_pT(flow, Tmin)
         hmax = fp.h_mix_pT(flow, Tmax)
 
         if c.h.val_SI < hmin:
             c.h.val_SI = hmin
-            logging.debug(self.property_range_message(c, 'h'))
+            logger.debug(self.property_range_message(c, 'h'))
 
         if c.h.val_SI > hmax:
             c.h.val_SI = hmax
-            logging.debug(self.property_range_message(c, 'h'))
+            logger.debug(self.property_range_message(c, 'h'))
 
     def solve_components(self):
         r"""
         Calculate the residual and derivatives of component equations.
 
         - Iterate through components in network to get residuals and
           derivatives.
@@ -2529,15 +2575,15 @@
         r"""Calculate connection, bus and component parameters."""
 
         self.process_connections()
         self.process_components()
         self.process_busses()
 
         msg = 'Postprocessing complete.'
-        logging.info(msg)
+        logger.info(msg)
 
     def process_connections(self):
         """Process the Connection results."""
         for c in self.conns['object']:
             flow = c.get_flow()
             c.good_starting_values = True
             c.T.val_SI = fp.T_mix_ph(flow, T0=c.T.val_SI)
@@ -2551,15 +2597,15 @@
                 c.v.val_SI = np.nan
                 c.s.val_SI = np.nan
                 msg = (
                     'Could not find a feasible value for mixture temperature '
                     'at connection ' + c.label + '. The values for '
                     'temperature, specific volume, volumetric flow and '
                     'entropy are set to nan.')
-                logging.error(msg)
+                logger.error(msg)
 
             else:
                 c.vol.val_SI = fp.v_mix_ph(flow, T0=c.T.val_SI)
                 c.v.val_SI = c.vol.val_SI * c.m.val_SI
                 c.s.val_SI = fp.s_mix_ph(flow, T0=c.T.val_SI)
                 if fluid is not None:
                     if not c.x.val_set:
@@ -2573,17 +2619,16 @@
 
             c.m.val0 = c.m.val
             c.p.val0 = c.p.val
             c.h.val0 = c.h.val
             c.fluid.val0 = c.fluid.val.copy()
 
             self.results['Connection'].loc[c.label] = (
-                [c.m.val, c.p.val, c.h.val, c.T.val, c.v.val, c.vol.val,
-                 c.s.val, c.x.val, c.Td_bp.val] +
-                [f for f in c.fluid.val.values()])
+              [c.m.val, c.p.val, c.h.val, c.T.val, c.v.val, c.vol.val,
+               c.s.val, c.x.val, c.Td_bp.val] + list(c.fluid.val.values()))
 
     def process_components(self):
         """Process the component results."""
         # components
         for cp in self.comps['object']:
             cp.calc_parameters()
             cp.check_parameter_bounds()
@@ -2625,17 +2670,20 @@
                 self.results[b.label].loc[cp.label] = (
                     [cmp_val, bus_val, eff, design_value])
 
             b.P.val = self.results[b.label]['bus value'].sum()
 
 # %% printing and plotting
 
-    def print_results(self, colored=True, colors={}):
+    def print_results(self, colored=True, colors=None, print_results=True):
         r"""Print the calculations results to prompt."""
         # Define colors for highlighting values in result table
+        if colors is None:
+            colors = {}
+        result = ""
         coloring = {
             'end': '\033[0m',
             'set': '\033[94m',
             'err': '\033[31m',
             'var': '\033[32m'
         }
         coloring.update(colors)
@@ -2659,16 +2707,16 @@
                             self.print_components, axis=1,
                             args=(col, colored, coloring))
 
                     df.dropna(how='all', inplace=True)
 
                     if len(df) > 0:
                         # printout with tabulate
-                        print('##### RESULTS (' + cp + ') #####')
-                        print(
+                        result += ('\n##### RESULTS (' + cp + ') #####\n')
+                        result += (
                             tabulate(
                                 df, headers='keys', tablefmt='psql',
                                 floatfmt='.2e'
                             )
                         )
 
         # connection properties
@@ -2682,50 +2730,55 @@
                 for col in df.columns:
                     if conn.get_attr(col).val_set:
                         df.loc[c, col] = (
                             coloring['set'] + str(conn.get_attr(col).val) +
                             coloring['end'])
 
         if len(df) > 0:
-            print('##### RESULTS (Connection) #####')
-            print(
+            result += ('\n##### RESULTS (Connection) #####\n')
+            result += (
                 tabulate(df, headers='keys', tablefmt='psql', floatfmt='.3e')
             )
 
         for b in self.busses.values():
             if b.printout:
                 df = self.results[b.label].loc[
                     :, ['component value', 'bus value', 'efficiency']]
                 df.loc['total'] = df.sum()
                 df.loc['total', 'efficiency'] = np.nan
                 if colored and b.P.is_set:
                     df.loc['total', 'bus value'] = (
                         coloring['set'] + str(df.loc['total', 'bus value']) +
                         coloring['end'])
-                print('##### RESULTS (Bus: ' + b.label + ') #####')
-                print(
+                result += ('\n##### RESULTS (Bus: ' + b.label + ') #####\n')
+                result += (
                     tabulate(
                         df, headers='keys', tablefmt='psql',
                         floatfmt='.3e'
                     )
                 )
+        if len(str(result)) > 0:
+            logger.result(result)
+            if print_results:
+                print(result)
+        return
 
     def print_components(self, c, *args):
         """
         Get the print values for the component data.
 
         Parameters
         ----------
         c : pandas.core.series.Series
             Series containing the component data.
 
         param : str
             Component parameter to print.
 
-        colored : booloean
+        colored : bool
             Color the printout.
 
         coloring : dict
             Coloring information for colored printout.
 
         Returns
         ----------
@@ -2772,15 +2825,15 @@
           characteristics as well as .csv files for all types of components
           within your network.
         """
         if path[-1] != '/' and path[-1] != '\\':
             path += '/'
         path = hlp.modify_path_os(path)
 
-        logging.debug('Saving network to path ' + path + '.')
+        logger.debug('Saving network to path %s.', path)
         # creat path, if non existent
         if not os.path.exists(path):
             os.makedirs(path)
 
         # create path for component folder if non existent
         path_comps = hlp.modify_path_os(path + 'components/')
         if not os.path.exists(path_comps):
@@ -2814,15 +2867,15 @@
         data['v_unit'] = self.v_unit
         data['s_unit'] = self.s_unit
         data['fluids'] = self.fluids_backends
 
         with open(fn, 'w') as f:
             f.write(json.dumps(data, indent=4))
 
-        logging.debug('Network information saved to ' + fn + '.')
+        logger.debug('Network information saved to %s.', fn)
 
     def save_connections(self, fn):
         r"""
         Save the connection properties.
 
         - Uses connections object id as row identifier and saves
 
@@ -2891,15 +2944,15 @@
             df[val + '_set'] = df.apply(
                 f, axis=1, args=('fluid', 'val_set', val))
 
         # fluid balance
         df['balance'] = df.apply(f, axis=1, args=('fluid', 'balance'))
 
         df.to_csv(fn, sep=';', decimal='.', index=False, na_rep='nan')
-        logging.debug('Connection information saved to ' + fn + '.')
+        logger.debug('Connection information saved to %s.', fn)
 
     def save_components(self, path):
         r"""
         Save the component properties.
 
         - Uses components labels as row identifier.
         - Writes:
@@ -2966,16 +3019,15 @@
                 # component property container
                 elif isinstance(data, dc_gcp):
                     df[col] = df.apply(f, axis=1, args=(col, 'method'))
 
             df.set_index('label', inplace=True)
             fn = path + c + '.csv'
             df.to_csv(fn, sep=';', decimal='.', index=True, na_rep='nan')
-            logging.debug(
-                'Component information (' + c + ') saved to ' + fn + '.')
+            logger.debug('Component information (%s) saved to %s.', c, fn)
 
     def save_busses(self, fn):
         r"""
         Save the bus properties.
 
         Parameters
         ----------
@@ -2990,30 +3042,30 @@
             df['P'] = df.apply(Network.get_props, axis=1, args=('P', 'val'))
             df['P_set'] = df.apply(Network.get_props, axis=1,
                                    args=('P', 'is_set'))
             df.drop('id', axis=1, inplace=True)
 
             df.set_index('label', inplace=True)
             df.to_csv(fn, sep=';', decimal='.', index=True, na_rep='nan')
-            logging.debug('Bus information saved to ' + fn + '.')
+            logger.debug('Bus information saved to %s.', fn)
 
     def save_characteristics(self, path):
         r"""
         Save the characteristics.
 
         Parameters
         ----------
         fn : str
             Path/filename for the file.
         """
         # characteristic lines in components
         char_lines = []
         char_maps = []
         for c in self.comps['object']:
-            for col, data in c.variables.items():
+            for _col, data in c.variables.items():
                 if isinstance(data, dc_cc):
                     char_lines += [data.char_func]
                 elif isinstance(data, dc_cm):
                     char_maps += [data.char_func]
 
         # characteristic lines in busses
         for bus in self.busses.values():
@@ -3033,16 +3085,15 @@
             cols = ['x', 'y', 'extrapolate']
             for val in cols:
                 df[val] = df.apply(Network.get_props, axis=1, args=(val,))
 
             # write to char.csv
             fn = path + 'char_line.csv'
             df.to_csv(fn, sep=';', decimal='.', index=False, na_rep='nan')
-            logging.debug(
-                'Characteristic line information saved to ' + fn + '.')
+            logger.debug('Characteristic line information saved to %s.', fn)
 
         if len(char_maps) > 0:
             # get id and data
             df = pd.DataFrame(
                 {'id': char_maps}, index=char_maps, dtype='object')
             df['id'] = df.apply(Network.get_id, axis=1)
             df['type'] = df.apply(Network.get_class_base, axis=1)
@@ -3050,16 +3101,15 @@
             cols = ['x', 'y', 'z']
             for val in cols:
                 df[val] = df.apply(Network.get_props, axis=1, args=(val,))
 
             # write to char_map.csv
             fn = path + 'char_map.csv'
             df.to_csv(fn, sep=';', decimal='.', index=False, na_rep='nan')
-            logging.debug(
-                'Characteristic map information saved to ' + fn + '.')
+            logger.debug('Characteristic map information saved to %s.', fn)
 
     @staticmethod
     def get_id(c):
         """Return the id of the python object."""
         return str(c.name)[str(c.name).find(' at ') + 4:-1]
 
     @staticmethod
```

### Comparing `TESPy-0.6.2/src/tespy/networks/network_reader.py` & `TESPy-0.6.3/src/tespy/networks/network_reader.py`

 * *Files 18% similar despite different names*

```diff
@@ -1,671 +1,669 @@
-# -*- coding: utf-8
-
-"""Module for loading a tespy network from saved state.
-
-Use the method :func:`tespy.networks.network_reader.load_network` for importing
-a network from a saved state.
-
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location tespy/networks/network_reader.py
-
-SPDX-License-Identifier: MIT
-"""
-import ast
-import json
-import logging
-import os
-
-import pandas as pd
-
-from tespy.components import CombustionChamber
-from tespy.components import CombustionEngine
-from tespy.components import Compressor
-from tespy.components import Condenser
-from tespy.components import CycleCloser
-from tespy.components import Desuperheater
-from tespy.components import DropletSeparator
-from tespy.components import Drum
-from tespy.components import HeatExchanger
-from tespy.components import HeatExchangerSimple
-from tespy.components import Merge
-from tespy.components import ORCEvaporator
-from tespy.components import ParabolicTrough
-from tespy.components import Pipe
-from tespy.components import Pump
-from tespy.components import Separator
-from tespy.components import Sink
-from tespy.components import SolarCollector
-from tespy.components import Source
-from tespy.components import Splitter
-from tespy.components import SubsystemInterface
-from tespy.components import Turbine
-from tespy.components import Valve
-from tespy.components import WaterElectrolyzer
-from tespy.connections import Bus
-from tespy.connections import Connection
-from tespy.connections import Ref
-from tespy.networks.network import Network
-from tespy.tools.characteristics import CharLine
-from tespy.tools.characteristics import CharMap
-from tespy.tools.data_containers import ComponentCharacteristicMaps as dc_cm
-from tespy.tools.data_containers import ComponentCharacteristics as dc_cc
-from tespy.tools.data_containers import ComponentProperties as dc_cp
-from tespy.tools.data_containers import DataContainerSimple as dc_simple
-from tespy.tools.data_containers import FluidComposition as dc_flu
-from tespy.tools.data_containers import FluidProperties as dc_prop
-from tespy.tools.data_containers import GroupedComponentProperties as dc_gcp
-from tespy.tools.helpers import modify_path_os
-
-# pass the warning messages to the logger
-logging.captureWarnings(True)
-
-
-comp_target_classes = {
-    'CycleCloser': CycleCloser,
-    'Sink': Sink,
-    'Source': Source,
-    'SubsystemInterface': SubsystemInterface,
-    'CombustionChamber': CombustionChamber,
-    'CombustionEngine': CombustionEngine,
-    'ORCEvaporator': ORCEvaporator,
-    'Condenser': Condenser,
-    'Desuperheater': Desuperheater,
-    'HeatExchanger': HeatExchanger,
-    'HeatExchangerSimple': HeatExchangerSimple,
-    'SolarCollector': SolarCollector,
-    'ParabolicTrough': ParabolicTrough,
-    'DropletSeparator': DropletSeparator,
-    'Drum': Drum,
-    'Merge': Merge,
-    'Separator': Separator,
-    'Splitter': Splitter,
-    'Pipe': Pipe,
-    'Valve': Valve,
-    'WaterElectrolyzer': WaterElectrolyzer,
-    'Compressor': Compressor,
-    'Pump': Pump,
-    'Turbine': Turbine
-}
-
-# %% network loading
-
-
-def load_network(path):
-    r"""
-    Load a network from a base path.
-
-    Parameters
-    ----------
-    path : str
-        The path to the network data.
-
-    Returns
-    -------
-    nw : tespy.networks.network.Network
-        TESPy networks object.
-
-    Note
-    ----
-    If you save the network structure of an existing TESPy network, it will be
-    saved to the path you specified. The structure of the saved data in that
-    path is the structure you need to provide in the path for loading the
-    network.
-
-    The structure of the path must be as follows:
-
-    - Folder: path (e.g. 'mynetwork')
-    - Subfolder: components ('mynetwork/components') containing
-
-        - bus.csv*
-        - char.csv*
-        - char_map.csv*
-        - component_class_name.csv (e.g. heat_exchanger.csv)
-
-    - connections.csv
-    - network.json
-
-    The imported network has the following additional features:
-
-    - Connections are accessible by label, e.g.
-      :code:`myimportednetwork.get_conn('myconnection')`. The default label
-      logic is :code:`source:source_id_target:target_id`, where the source
-      means the label of the component the connection originates from and
-      target means the label of the component, the connections targets on.
-    - Components are accessible by label as well, e.g. for a component
-      'heat exchanger' :code:`myimportednetwork.get_comp('heat exchanger')`.
-    - Busses are stored in a dict like structure, therefore accessible like
-      follows, e.g. a bus labeld 'power input'
-      :code:`myimportednetwork.busses['power input']`.
-
-    Example
-    -------
-    Create a network and export it. This is followed by loading the network
-    with the network_reader module. All network information stored will be
-    passed to a new network object. Components, connections and busses will
-    be accessible by label. The following example setup is simple gas turbine
-    setup with compressor, combustion chamber and turbine. The fuel is fed
-    from a pipeline and throttled to the required pressure while keeping the
-    temperature at a constant value.
-
-    >>> import numpy as np
-    >>> from tespy.components import (Sink, Source, CombustionChamber,
-    ... Compressor, Turbine, HeatExchangerSimple)
-    >>> from tespy.connections import Connection, Ref, Bus
-    >>> from tespy.networks import load_network, Network
-    >>> import shutil
-    >>> fluid_list = ['CH4', 'O2', 'N2', 'CO2', 'H2O', 'Ar']
-    >>> nw = Network(fluids=fluid_list, p_unit='bar', T_unit='C',
-    ... h_unit='kJ / kg', iterinfo=False)
-    >>> air = Source('air')
-    >>> f = Source('fuel')
-    >>> c = Compressor('compressor')
-    >>> comb = CombustionChamber('combustion')
-    >>> t = Turbine('turbine')
-    >>> p = HeatExchangerSimple('fuel preheater')
-    >>> si = Sink('sink')
-    >>> inc = Connection(air, 'out1', c, 'in1', label='ambient air')
-    >>> cc = Connection(c, 'out1', comb, 'in1')
-    >>> fp = Connection(f, 'out1', p, 'in1')
-    >>> pc = Connection(p, 'out1', comb, 'in2')
-    >>> ct = Connection(comb, 'out1', t, 'in1')
-    >>> outg = Connection(t, 'out1', si, 'in1')
-    >>> nw.add_conns(inc, cc, fp, pc, ct, outg)
-
-    Specify component and connection properties. The intlet pressure at the
-    compressor and the outlet pressure after the turbine are identical. For the
-    compressor, the pressure ratio and isentropic efficiency are design
-    parameters. A compressor map (efficiency vs. mass flow and pressure rise
-    vs. mass flow) is selected for the compressor. Fuel is Methane.
-
-    >>> c.set_attr(pr=10, eta_s=0.88, design=['eta_s', 'pr'],
-    ... offdesign=['char_map_eta_s', 'char_map_pr'])
-    >>> t.set_attr(eta_s=0.9, design=['eta_s'],
-    ... offdesign=['eta_s_char', 'cone'])
-    >>> inc.set_attr(fluid={'N2': 0.7556, 'O2': 0.2315, 'Ar': 0.0129, 'CH4': 0,
-    ... 'H2O': 0}, fluid_balance=True, T=25, p=1)
-    >>> fp.set_attr(fluid={'N2': 0, 'O2': 0, 'Ar': 0, 'CH4': 0.96, 'H2O': 0,
-    ... 'CO2': 0.04}, T=25, p=40)
-    >>> pc.set_attr(T=25)
-    >>> ct.set_attr(T=1100)
-    >>> outg.set_attr(p=Ref(inc, 1, 0))
-    >>> power = Bus('total power output')
-    >>> power.add_comps({'comp': c}, {'comp': t})
-    >>> nw.add_busses(power)
-
-    For a stable start, we specify the fresh air mass flow.
-
-    >>> inc.set_attr(m=3)
-    >>> nw.solve('design')
-
-    The total power output is set to 1 MW, electrical or mechanical
-    efficiencies are not considered in this example. The documentation
-    example in class :py:class:`tespy.connections.bus.Bus` provides more
-    information on efficiencies of generators, for instance.
-
-    >>> inc.set_attr(m=np.nan)
-    >>> power.set_attr(P=-1e6)
-    >>> nw.solve('design')
-    >>> nw.lin_dep
-    False
-    >>> nw.save('exported_nwk')
-    >>> mass_flow = round(nw.get_conn('ambient air').m.val_SI, 1)
-    >>> c.set_attr(igva='var')
-    >>> nw.solve('offdesign', design_path='exported_nwk')
-    >>> round(t.eta_s.val, 1)
-    0.9
-    >>> power.set_attr(P=-0.75e6)
-    >>> nw.solve('offdesign', design_path='exported_nwk')
-    >>> nw.lin_dep
-    False
-    >>> eta_s_t = round(t.eta_s.val, 3)
-    >>> igva = round(c.igva.val, 3)
-    >>> eta_s_t
-    0.898
-    >>> igva
-    20.138
-
-    The designed network is exported to the path 'exported_nwk'. Now import the
-    network and recalculate. Check if the results match with the previous
-    calculation in design and offdesign case.
-
-    >>> imported_nwk = load_network('exported_nwk')
-    >>> imported_nwk.set_attr(iterinfo=False)
-    >>> imported_nwk.solve('design', init_path='exported_nwk')
-    >>> imported_nwk.lin_dep
-    False
-    >>> round(imported_nwk.get_conn('ambient air').m.val_SI, 1) == mass_flow
-    True
-    >>> round(imported_nwk.get_comp('turbine').eta_s.val, 3)
-    0.9
-    >>> imported_nwk.get_comp('compressor').set_attr(igva='var')
-    >>> imported_nwk.solve('offdesign', design_path='exported_nwk')
-    >>> round(imported_nwk.get_comp('turbine').eta_s.val, 3)
-    0.9
-    >>> imported_nwk.busses['total power output'].set_attr(P=-0.75e6)
-    >>> imported_nwk.solve('offdesign', design_path='exported_nwk')
-    >>> round(imported_nwk.get_comp('turbine').eta_s.val, 3) == eta_s_t
-    True
-    >>> round(imported_nwk.get_comp('compressor').igva.val, 3) == igva
-    True
-    >>> shutil.rmtree('./exported_nwk', ignore_errors=True)
-    """
-    if path[-1] != '/' and path[-1] != '\\':
-        path += '/'
-
-    path_comps = modify_path_os(path + 'components/')
-    path = modify_path_os(path)
-
-    msg = 'Reading network data from base path ' + path + '.'
-    logging.info(msg)
-
-    # load characteristics
-    fn = path_comps + 'char_line.csv'
-    try:
-        char_lines = pd.read_csv(fn, sep=';', decimal='.',
-                                 converters={'x': ast.literal_eval,
-                                             'y': ast.literal_eval})
-        msg = 'Reading characteristic lines data from ' + fn + '.'
-        logging.debug(msg)
-
-    except FileNotFoundError:
-        char_lines = pd.DataFrame(
-            columns=['id', 'type', 'x', 'y'], dtype='object')
-
-    # load characteristic maps
-    fn = path_comps + 'char_map.csv'
-    try:
-        msg = 'Reading characteristic maps data from ' + fn + '.'
-        logging.debug(msg)
-        char_maps = pd.read_csv(fn, sep=';', decimal='.',
-                                converters={'x': ast.literal_eval,
-                                            'y': ast.literal_eval,
-                                            'z': ast.literal_eval})
-
-    except FileNotFoundError:
-        char_maps = pd.DataFrame(
-            columns=['id', 'type', 'x', 'y', 'z'], dtype='object')
-
-    # load components
-    comps = pd.DataFrame(dtype='object')
-
-    files = os.listdir(path_comps)
-    for f in files:
-        if f != 'bus.csv' and f != 'char_line.csv' and f != 'char_map.csv':
-            fn = path_comps + f
-            df = pd.read_csv(fn, sep=';', decimal='.',
-                             converters={'design': ast.literal_eval,
-                                         'offdesign': ast.literal_eval,
-                                         'busses': ast.literal_eval,
-                                         'bus_param': ast.literal_eval,
-                                         'bus_P_ref': ast.literal_eval,
-                                         'bus_char': ast.literal_eval,
-                                         'bus_base': ast.literal_eval})
-
-            # create components
-            df['instance'] = df.apply(
-                construct_components, axis=1,  args=(char_lines, char_maps))
-
-            cols = [
-                'instance', 'label', 'busses', 'bus_param', 'bus_P_ref',
-                'bus_char', 'bus_base']
-
-            comps = pd.concat((comps, df[cols]), axis=0)
-
-            msg = 'Reading component data (' + f[:-4] + ') from ' + fn + '.'
-            logging.debug(msg)
-
-    comps = comps.set_index('label')
-    msg = 'Created network components.'
-    logging.info(msg)
-
-    # create network
-    nw = construct_network(path)
-
-    # load connections
-    fn = path + 'connections.csv'
-    conns = pd.read_csv(fn, sep=';', decimal='.',
-                        converters={'design': ast.literal_eval,
-                                    'offdesign': ast.literal_eval})
-
-    msg = 'Reading connection data from ' + fn + '.'
-    logging.debug(msg)
-
-    # create connections
-    conns['instance'] = conns.apply(
-        construct_connections, axis=1, args=(comps, nw,))
-    conns.apply(conns_set_ref, axis=1, args=(conns,))
-    conns = conns.set_index('id')
-
-    # add connections to network
-    for c in conns['instance']:
-        nw.add_conns(c)
-
-    msg = 'Created connections.'
-    logging.info(msg)
-
-    # load busses
-    try:
-        fn = path_comps + 'bus.csv'
-        busses = pd.read_csv(fn, sep=';', decimal='.')
-        msg = 'Reading bus data from ' + fn + '.'
-        logging.debug(msg)
-
-    except FileNotFoundError:
-        busses = pd.DataFrame(dtype='object')
-        msg = 'No bus data found!'
-        logging.debug(msg)
-
-    # create busses
-    if len(busses) > 0:
-        busses['instance'] = busses.apply(construct_busses, axis=1)
-
-        # add components to busses
-        comps.apply(busses_add_comps, axis=1, args=(busses, char_lines,))
-
-        # add busses to network
-        for b in busses['instance']:
-            nw.add_busses(b)
-
-        msg = 'Created busses.'
-        logging.info(msg)
-
-    msg = 'Created network.'
-    logging.info(msg)
-
-    nw.check_network()
-
-    return nw
-
-
-# %% create components
-
-
-def construct_components(c, *args):
-    r"""
-    Create TESPy component from class name and set parameters.
-
-    Parameters
-    ----------
-    c : pandas.core.series.Series
-        Component information from .csv-file.
-
-    args[0] : pandas.core.frame.DataFrame
-        DataFrame containing the data of characteristic lines.
-
-    args[1] : pandas.core.frame.DataFrame
-        DataFrame containing the data of characteristic maps.
-
-    Returns
-    -------
-    instance : tespy.components.component.Component
-        TESPy component object.
-    """
-    target_class = comp_target_classes[c['comp_type']]
-    instance = target_class(str(c['label']))
-    kwargs = {}
-
-    # basic properties
-    for key in ['design', 'offdesign', 'design_path', 'local_design',
-                'local_offdesign']:
-        if key in c:
-            if isinstance(c[key], float):
-                kwargs[key] = None
-            else:
-                kwargs[key] = c[key]
-
-    for key, value in instance.variables.items():
-        if key in c:
-            # component parameters
-            if isinstance(value, dc_cp):
-                kwargs[key] = {
-                    'val': c[key],
-                    'is_set': c[key + '_set'],
-                    'is_var': c[key + '_var']}
-
-            # component parameters
-            elif isinstance(value, dc_simple):
-                instance.get_attr(key).set_attr(
-                    **{'val': c[key], 'is_set': c[key + '_set']})
-
-            # component characteristics
-            elif isinstance(value, dc_cc):
-                # finding x and y values of the characteristic function
-                values = args[0]['id'] == c[key]
-
-                try:
-                    x = args[0][values].x.values[0]
-                    y = args[0][values].y.values[0]
-                    extrapolate = False
-                    if 'extrapolate' in args[0].columns:
-                        extrapolate = args[0][values].extrapolate.values[0]
-                    char = CharLine(x=x, y=y, extrapolate=extrapolate)
-
-                except IndexError:
-
-                    char = None
-                    msg = ('Could not find x and y values for characteristic '
-                           'line, using defaults instead for function ' + key +
-                           ' at component ' + c.label + '.')
-                    logging.warning(msg)
-
-                kwargs[key] = {
-                    'is_set': c[key + '_set'],
-                    'param': c[key + '_param'],
-                    'char_func': char}
-
-            # component characteristics
-            elif isinstance(value, dc_cm):
-                # finding x and y values of the characteristic function
-                values = args[1]['id'] == c[key]
-
-                try:
-                    x = list(args[1][values].x.values[0])
-                    y = list(args[1][values].y.values[0])
-                    z = list(args[1][values].z.values[0])
-                    char = CharMap(x=x, y=y, z=z)
-
-                except IndexError:
-                    char = None
-                    msg = ('Could not find x, y and z values for '
-                           'characteristic map of component ' + c.label + '!')
-                    logging.warning(msg)
-
-                kwargs[key] = {
-                    'is_set': c[key + '_set'],
-                    'param': c[key + '_param'],
-                    'char_func': char}
-
-            # grouped component parameters
-            elif isinstance(value, dc_gcp):
-                kwargs[key] = {'method': c[key]}
-
-    instance.set_attr(**kwargs)
-    return instance
-
-# %% create network object
-
-
-def construct_network(path):
-    r"""
-    Create TESPy network from the data provided in the netw.csv-file.
-
-    Parameters
-    ----------
-    path : str
-        Base-path to stored network data.
-
-    Returns
-    -------
-    nw : tespy.networks.network.Network
-        TESPy network object.
-    """
-    # read network .csv-file
-    with open(path + 'network.json', 'r') as f:
-        data = json.loads(f.read())
-
-    # construct fluid list
-    fluid_list = [
-        backend + '::' + fluid for fluid, backend in data['fluids'].items()]
-
-    # delete fluids from data
-    del data['fluids']
-
-    # create network object with its properties
-    nw = Network(fluids=fluid_list, **data)
-
-    return nw
-
-# %% create connections
-
-
-def construct_connections(c, *args):
-    r"""
-    Create TESPy connection from data in the .csv-file and its parameters.
-
-    Parameters
-    ----------
-    c : pandas.core.series.Series
-        Connection information from .csv-file.
-
-    args[0] : pandas.core.frame.DataFrame
-        DataFrame containing all created components.
-
-    Returns
-    -------
-    conn : tespy.connections.connection.Connection
-        TESPy connection object.
-    """
-    # create connection
-    conn = Connection(
-        args[0].instance[c.source], c.source_id,
-        args[0].instance[c.target], c.target_id, label=str(c.label)
-    )
-
-    # read basic properties
-    for key in ['design', 'offdesign', 'design_path', 'local_design',
-                'local_offdesign']:
-        if key in c:
-            if isinstance(c[key], float):
-                setattr(conn, key, None)
-            else:
-                setattr(conn, key, c[key])
-
-    # read fluid properties
-    for key in ['m', 'p', 'h', 'T', 'x', 'v', 'Td_bp']:
-        if key in c:
-            setattr(conn, key, dc_prop(
-                val=c[key], val0=c[key + '0'], val_set=c[key + '_set'],
-                unit=c[key + '_unit'], ref=None, ref_set=c[key + '_ref_set']))
-
-    if 'state' in c:
-        conn.state = dc_simple(val=c[key], is_set=c[key + '_set'])
-
-    # read fluid vector
-    val = {}
-    val0 = {}
-    val_set = {}
-    for key in args[1].fluids:
-        if key in c:
-            val[key] = c[key]
-            val0[key] = c[key + '0']
-            val_set[key] = c[key + '_set']
-
-    conn.fluid = dc_flu(
-        val=val, val0=val0, val_set=val_set, balance=c['balance'])
-
-    # write properties to connection and return connection object
-    return conn
-
-# %% set references on connections
-
-
-def conns_set_ref(c, *args):
-    r"""
-    Set references on connections as specified in connection data.
-
-    Parameters
-    ----------
-    c : pandas.core.series.Series
-        Connection information from .csv-file.
-
-    args[0] : pandas.core.frame.DataFrame
-        DataFrame containing all created connections.
-
-    Returns
-    -------
-    instance : tespy.connections.ref
-        TESPy reference object.
-    """
-    for col in ['m', 'p', 'h', 'T']:
-        # search for referenced connections
-        if isinstance(c[col + '_ref'], str):
-            # create reference object
-            instance = args[0].instance[c[col + '_ref'] ==
-                                        args[0]['id']].values[0]
-            # write to connection properties
-            c['instance'].get_attr(col).ref = Ref(
-                instance, c[col + '_ref_f'], c[col + '_ref_d'])
-
-# %% create busses
-
-
-def construct_busses(c, *args):
-    r"""
-    Create busses of the network.
-
-    Parameters
-    ----------
-    c : pandas.core.series.Series
-        Bus information from .csv-file.
-
-    Returns
-    -------
-    b : tespy.connections.bus.Bus
-        TESPy bus object.
-    """
-    # set up bus with label and specify value for power
-    b = Bus(str(c.label), P=c.P)
-    b.P.is_set = c.P_set
-    return b
-
-# %% add components to busses
-
-
-def busses_add_comps(c, *args):
-    r"""
-    Add components to busses according to data from .csv file.
-
-    Parameters
-    ----------
-    c : pandas.core.series.Series
-        Component information from .csv-file.
-
-    args[0] : pandas.core.frame.DataFrame
-        DataFrame containing all created busses.
-
-    args[1] : pandas.core.frame.DataFrame
-        DataFrame containing all created characteristic lines.
-    """
-    i = 0
-    for b in c.busses:
-        param = c.bus_param[i]
-        P_ref = c.bus_P_ref[i]
-        char = c.bus_char[i]
-        base = 'component'
-        if 'bus_base' in c.index:
-            base = c.bus_base[i]
-
-        values = char == args[1]['id']
-        char = CharLine(x=args[1][values].x.values[0],
-                        y=args[1][values].y.values[0])
-
-        # add component with corresponding details to bus
-        args[0].instance[b == args[0]['label']].values[0].add_comps({
-            'comp': c.instance,
-            'param': param,
-            'P_ref': P_ref,
-            'char': char,
-            'base': base})
-        i += 1
+# -*- coding: utf-8
+
+"""Module for loading a tespy network from saved state.
+
+Use the method :func:`tespy.networks.network_reader.load_network` for importing
+a network from a saved state.
+
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location tespy/networks/network_reader.py
+
+SPDX-License-Identifier: MIT
+"""
+import ast
+import json
+import os
+
+import pandas as pd
+
+from tespy.components import CombustionChamber
+from tespy.components import CombustionEngine
+from tespy.components import Compressor
+from tespy.components import Condenser
+from tespy.components import CycleCloser
+from tespy.components import Desuperheater
+from tespy.components import DropletSeparator
+from tespy.components import Drum
+from tespy.components import HeatExchanger
+from tespy.components import HeatExchangerSimple
+from tespy.components import Merge
+from tespy.components import ORCEvaporator
+from tespy.components import ParabolicTrough
+from tespy.components import Pipe
+from tespy.components import Pump
+from tespy.components import Separator
+from tespy.components import SimpleHeatExchanger
+from tespy.components import Sink
+from tespy.components import SolarCollector
+from tespy.components import Source
+from tespy.components import Splitter
+from tespy.components import SubsystemInterface
+from tespy.components import Turbine
+from tespy.components import Valve
+from tespy.components import WaterElectrolyzer
+from tespy.connections import Bus
+from tespy.connections import Connection
+from tespy.connections import Ref
+from tespy.networks.network import Network
+from tespy.tools import logger
+from tespy.tools.characteristics import CharLine
+from tespy.tools.characteristics import CharMap
+from tespy.tools.data_containers import ComponentCharacteristicMaps as dc_cm
+from tespy.tools.data_containers import ComponentCharacteristics as dc_cc
+from tespy.tools.data_containers import ComponentProperties as dc_cp
+from tespy.tools.data_containers import FluidComposition as dc_flu
+from tespy.tools.data_containers import FluidProperties as dc_prop
+from tespy.tools.data_containers import GroupedComponentProperties as dc_gcp
+from tespy.tools.data_containers import SimpleDataContainer as dc_simple
+from tespy.tools.helpers import modify_path_os
+
+comp_target_classes = {
+    'CycleCloser': CycleCloser,
+    'Sink': Sink,
+    'Source': Source,
+    'SubsystemInterface': SubsystemInterface,
+    'CombustionChamber': CombustionChamber,
+    'CombustionEngine': CombustionEngine,
+    'ORCEvaporator': ORCEvaporator,
+    'Condenser': Condenser,
+    'Desuperheater': Desuperheater,
+    'HeatExchanger': HeatExchanger,
+    'HeatExchangerSimple': HeatExchangerSimple,
+    'SimpleHeatExchanger': SimpleHeatExchanger,
+    'SolarCollector': SolarCollector,
+    'ParabolicTrough': ParabolicTrough,
+    'DropletSeparator': DropletSeparator,
+    'Drum': Drum,
+    'Merge': Merge,
+    'Separator': Separator,
+    'Splitter': Splitter,
+    'Pipe': Pipe,
+    'Valve': Valve,
+    'WaterElectrolyzer': WaterElectrolyzer,
+    'Compressor': Compressor,
+    'Pump': Pump,
+    'Turbine': Turbine
+}
+
+# %% network loading
+
+
+def load_network(path):
+    r"""
+    Load a network from a base path.
+
+    Parameters
+    ----------
+    path : str
+        The path to the network data.
+
+    Returns
+    -------
+    nw : tespy.networks.network.Network
+        TESPy networks object.
+
+    Note
+    ----
+    If you save the network structure of an existing TESPy network, it will be
+    saved to the path you specified. The structure of the saved data in that
+    path is the structure you need to provide in the path for loading the
+    network.
+
+    The structure of the path must be as follows:
+
+    - Folder: path (e.g. 'mynetwork')
+    - Subfolder: components ('mynetwork/components') containing
+
+        - bus.csv*
+        - char.csv*
+        - char_map.csv*
+        - component_class_name.csv (e.g. heat_exchanger.csv)
+
+    - connections.csv
+    - network.json
+
+    The imported network has the following additional features:
+
+    - Connections are accessible by label, e.g.
+      :code:`myimportednetwork.get_conn('myconnection')`. The default label
+      logic is :code:`source:source_id_target:target_id`, where the source
+      means the label of the component the connection originates from and
+      target means the label of the component, the connections targets on.
+    - Components are accessible by label as well, e.g. for a component
+      'heat exchanger' :code:`myimportednetwork.get_comp('heat exchanger')`.
+    - Busses are stored in a dict like structure, therefore accessible like
+      follows, e.g. a bus labeld 'power input'
+      :code:`myimportednetwork.busses['power input']`.
+
+    Example
+    -------
+    Create a network and export it. This is followed by loading the network
+    with the network_reader module. All network information stored will be
+    passed to a new network object. Components, connections and busses will
+    be accessible by label. The following example setup is simple gas turbine
+    setup with compressor, combustion chamber and turbine. The fuel is fed
+    from a pipeline and throttled to the required pressure while keeping the
+    temperature at a constant value.
+
+    >>> import numpy as np
+    >>> from tespy.components import (Sink, Source, CombustionChamber,
+    ... Compressor, Turbine, SimpleHeatExchanger)
+    >>> from tespy.connections import Connection, Ref, Bus
+    >>> from tespy.networks import load_network, Network
+    >>> import shutil
+    >>> fluid_list = ['CH4', 'O2', 'N2', 'CO2', 'H2O', 'Ar']
+    >>> nw = Network(fluids=fluid_list, p_unit='bar', T_unit='C',
+    ... h_unit='kJ / kg', iterinfo=False)
+    >>> air = Source('air')
+    >>> f = Source('fuel')
+    >>> c = Compressor('compressor')
+    >>> comb = CombustionChamber('combustion')
+    >>> t = Turbine('turbine')
+    >>> p = SimpleHeatExchanger('fuel preheater')
+    >>> si = Sink('sink')
+    >>> inc = Connection(air, 'out1', c, 'in1', label='ambient air')
+    >>> cc = Connection(c, 'out1', comb, 'in1')
+    >>> fp = Connection(f, 'out1', p, 'in1')
+    >>> pc = Connection(p, 'out1', comb, 'in2')
+    >>> ct = Connection(comb, 'out1', t, 'in1')
+    >>> outg = Connection(t, 'out1', si, 'in1')
+    >>> nw.add_conns(inc, cc, fp, pc, ct, outg)
+
+    Specify component and connection properties. The intlet pressure at the
+    compressor and the outlet pressure after the turbine are identical. For the
+    compressor, the pressure ratio and isentropic efficiency are design
+    parameters. A compressor map (efficiency vs. mass flow and pressure rise
+    vs. mass flow) is selected for the compressor. Fuel is Methane.
+
+    >>> c.set_attr(pr=10, eta_s=0.88, design=['eta_s', 'pr'],
+    ... offdesign=['char_map_eta_s', 'char_map_pr'])
+    >>> t.set_attr(eta_s=0.9, design=['eta_s'],
+    ... offdesign=['eta_s_char', 'cone'])
+    >>> inc.set_attr(fluid={'N2': 0.7556, 'O2': 0.2315, 'Ar': 0.0129, 'CH4': 0,
+    ... 'H2O': 0}, fluid_balance=True, T=25, p=1)
+    >>> fp.set_attr(fluid={'N2': 0, 'O2': 0, 'Ar': 0, 'CH4': 0.96, 'H2O': 0,
+    ... 'CO2': 0.04}, T=25, p=40)
+    >>> pc.set_attr(T=25)
+    >>> ct.set_attr(T=1100)
+    >>> outg.set_attr(p=Ref(inc, 1, 0))
+    >>> power = Bus('total power output')
+    >>> power.add_comps({'comp': c}, {'comp': t})
+    >>> nw.add_busses(power)
+
+    For a stable start, we specify the fresh air mass flow.
+
+    >>> inc.set_attr(m=3)
+    >>> nw.solve('design')
+
+    The total power output is set to 1 MW, electrical or mechanical
+    efficiencies are not considered in this example. The documentation
+    example in class :py:class:`tespy.connections.bus.Bus` provides more
+    information on efficiencies of generators, for instance.
+
+    >>> inc.set_attr(m=np.nan)
+    >>> power.set_attr(P=-1e6)
+    >>> nw.solve('design')
+    >>> nw.lin_dep
+    False
+    >>> nw.save('exported_nwk')
+    >>> mass_flow = round(nw.get_conn('ambient air').m.val_SI, 1)
+    >>> c.set_attr(igva='var')
+    >>> nw.solve('offdesign', design_path='exported_nwk')
+    >>> round(t.eta_s.val, 1)
+    0.9
+    >>> power.set_attr(P=-0.75e6)
+    >>> nw.solve('offdesign', design_path='exported_nwk')
+    >>> nw.lin_dep
+    False
+    >>> eta_s_t = round(t.eta_s.val, 3)
+    >>> igva = round(c.igva.val, 3)
+    >>> eta_s_t
+    0.898
+    >>> igva
+    20.138
+
+    The designed network is exported to the path 'exported_nwk'. Now import the
+    network and recalculate. Check if the results match with the previous
+    calculation in design and offdesign case.
+
+    >>> imported_nwk = load_network('exported_nwk')
+    >>> imported_nwk.set_attr(iterinfo=False)
+    >>> imported_nwk.solve('design', init_path='exported_nwk')
+    >>> imported_nwk.lin_dep
+    False
+    >>> round(imported_nwk.get_conn('ambient air').m.val_SI, 1) == mass_flow
+    True
+    >>> round(imported_nwk.get_comp('turbine').eta_s.val, 3)
+    0.9
+    >>> imported_nwk.get_comp('compressor').set_attr(igva='var')
+    >>> imported_nwk.solve('offdesign', design_path='exported_nwk')
+    >>> round(imported_nwk.get_comp('turbine').eta_s.val, 3)
+    0.9
+    >>> imported_nwk.busses['total power output'].set_attr(P=-0.75e6)
+    >>> imported_nwk.solve('offdesign', design_path='exported_nwk')
+    >>> round(imported_nwk.get_comp('turbine').eta_s.val, 3) == eta_s_t
+    True
+    >>> round(imported_nwk.get_comp('compressor').igva.val, 3) == igva
+    True
+    >>> shutil.rmtree('./exported_nwk', ignore_errors=True)
+    """
+    if path[-1] != '/' and path[-1] != '\\':
+        path += '/'
+
+    path_comps = modify_path_os(path + 'components/')
+    path = modify_path_os(path)
+
+    msg = 'Reading network data from base path ' + path + '.'
+    logger.info(msg)
+
+    # load characteristics
+    fn = path_comps + 'char_line.csv'
+    try:
+        char_lines = pd.read_csv(fn, sep=';', decimal='.',
+                                 converters={'x': ast.literal_eval,
+                                             'y': ast.literal_eval})
+        msg = 'Reading characteristic lines data from ' + fn + '.'
+        logger.debug(msg)
+
+    except FileNotFoundError:
+        char_lines = pd.DataFrame(
+            columns=['id', 'type', 'x', 'y'], dtype='object')
+
+    # load characteristic maps
+    fn = path_comps + 'char_map.csv'
+    try:
+        msg = 'Reading characteristic maps data from ' + fn + '.'
+        logger.debug(msg)
+        char_maps = pd.read_csv(fn, sep=';', decimal='.',
+                                converters={'x': ast.literal_eval,
+                                            'y': ast.literal_eval,
+                                            'z': ast.literal_eval})
+
+    except FileNotFoundError:
+        char_maps = pd.DataFrame(
+            columns=['id', 'type', 'x', 'y', 'z'], dtype='object')
+
+    # load components
+    comps = pd.DataFrame(dtype='object')
+
+    files = os.listdir(path_comps)
+    for f in files:
+        if f != 'bus.csv' and f != 'char_line.csv' and f != 'char_map.csv':
+            fn = path_comps + f
+            df = pd.read_csv(fn, sep=';', decimal='.',
+                             converters={'design': ast.literal_eval,
+                                         'offdesign': ast.literal_eval,
+                                         'busses': ast.literal_eval,
+                                         'bus_param': ast.literal_eval,
+                                         'bus_P_ref': ast.literal_eval,
+                                         'bus_char': ast.literal_eval,
+                                         'bus_base': ast.literal_eval})
+
+            # create components
+            df['instance'] = df.apply(
+                construct_components, axis=1,  args=(char_lines, char_maps))
+
+            cols = [
+                'instance', 'label', 'busses', 'bus_param', 'bus_P_ref',
+                'bus_char', 'bus_base']
+
+            comps = pd.concat((comps, df[cols]), axis=0)
+
+            msg = 'Reading component data (' + f[:-4] + ') from ' + fn + '.'
+            logger.debug(msg)
+
+    comps = comps.set_index('label')
+    msg = 'Created network components.'
+    logger.info(msg)
+
+    # create network
+    nw = construct_network(path)
+
+    # load connections
+    fn = path + 'connections.csv'
+    conns = pd.read_csv(fn, sep=';', decimal='.',
+                        converters={'design': ast.literal_eval,
+                                    'offdesign': ast.literal_eval})
+
+    msg = 'Reading connection data from ' + fn + '.'
+    logger.debug(msg)
+
+    # create connections
+    conns['instance'] = conns.apply(
+        construct_connections, axis=1, args=(comps, nw,))
+    conns.apply(conns_set_ref, axis=1, args=(conns,))
+    conns = conns.set_index('id')
+
+    # add connections to network
+    for c in conns['instance']:
+        nw.add_conns(c)
+
+    msg = 'Created connections.'
+    logger.info(msg)
+
+    # load busses
+    try:
+        fn = path_comps + 'bus.csv'
+        busses = pd.read_csv(fn, sep=';', decimal='.')
+        msg = 'Reading bus data from ' + fn + '.'
+        logger.debug(msg)
+
+    except FileNotFoundError:
+        busses = pd.DataFrame(dtype='object')
+        msg = 'No bus data found!'
+        logger.debug(msg)
+
+    # create busses
+    if len(busses) > 0:
+        busses['instance'] = busses.apply(construct_busses, axis=1)
+
+        # add components to busses
+        comps.apply(busses_add_comps, axis=1, args=(busses, char_lines,))
+
+        # add busses to network
+        for b in busses['instance']:
+            nw.add_busses(b)
+
+        msg = 'Created busses.'
+        logger.info(msg)
+
+    msg = 'Created network.'
+    logger.info(msg)
+
+    nw.check_network()
+
+    return nw
+
+
+# %% create components
+
+
+def construct_components(c, *args):
+    r"""
+    Create TESPy component from class name and set parameters.
+
+    Parameters
+    ----------
+    c : pandas.core.series.Series
+        Component information from .csv-file.
+
+    args[0] : pandas.core.frame.DataFrame
+        DataFrame containing the data of characteristic lines.
+
+    args[1] : pandas.core.frame.DataFrame
+        DataFrame containing the data of characteristic maps.
+
+    Returns
+    -------
+    instance : tespy.components.component.Component
+        TESPy component object.
+    """
+    target_class = comp_target_classes[c['comp_type']]
+    instance = target_class(str(c['label']))
+    kwargs = {}
+
+    # basic properties
+    for key in ['design', 'offdesign', 'design_path', 'local_design',
+                'local_offdesign']:
+        if key in c:
+            if isinstance(c[key], float):
+                kwargs[key] = None
+            else:
+                kwargs[key] = c[key]
+
+    for key, value in instance.variables.items():
+        if key in c:
+            # component parameters
+            if isinstance(value, dc_cp):
+                kwargs[key] = {
+                    'val': c[key],
+                    'is_set': c[key + '_set'],
+                    'is_var': c[key + '_var']}
+
+            # component parameters
+            elif isinstance(value, dc_simple):
+                instance.get_attr(key).set_attr(
+                    **{'val': c[key], 'is_set': c[key + '_set']})
+
+            # component characteristics
+            elif isinstance(value, dc_cc):
+                # finding x and y values of the characteristic function
+                values = args[0]['id'] == c[key]
+
+                try:
+                    x = args[0][values].x.values[0]
+                    y = args[0][values].y.values[0]
+                    extrapolate = False
+                    if 'extrapolate' in args[0].columns:
+                        extrapolate = args[0][values].extrapolate.values[0]
+                    char = CharLine(x=x, y=y, extrapolate=extrapolate)
+
+                except IndexError:
+
+                    char = None
+                    msg = ('Could not find x and y values for characteristic '
+                           'line, using defaults instead for function ' + key +
+                           ' at component ' + c.label + '.')
+                    logger.warning(msg)
+
+                kwargs[key] = {
+                    'is_set': c[key + '_set'],
+                    'param': c[key + '_param'],
+                    'char_func': char}
+
+            # component characteristics
+            elif isinstance(value, dc_cm):
+                # finding x and y values of the characteristic function
+                values = args[1]['id'] == c[key]
+
+                try:
+                    x = list(args[1][values].x.values[0])
+                    y = list(args[1][values].y.values[0])
+                    z = list(args[1][values].z.values[0])
+                    char = CharMap(x=x, y=y, z=z)
+
+                except IndexError:
+                    char = None
+                    msg = ('Could not find x, y and z values for '
+                           'characteristic map of component ' + c.label + '!')
+                    logger.warning(msg)
+
+                kwargs[key] = {
+                    'is_set': c[key + '_set'],
+                    'param': c[key + '_param'],
+                    'char_func': char}
+
+            # grouped component parameters
+            elif isinstance(value, dc_gcp):
+                kwargs[key] = {'method': c[key]}
+
+    instance.set_attr(**kwargs)
+    return instance
+
+# %% create network object
+
+
+def construct_network(path):
+    r"""
+    Create TESPy network from the data provided in the netw.csv-file.
+
+    Parameters
+    ----------
+    path : str
+        Base-path to stored network data.
+
+    Returns
+    -------
+    nw : tespy.networks.network.Network
+        TESPy network object.
+    """
+    # read network .csv-file
+    with open(path + 'network.json', 'r') as f:
+        data = json.loads(f.read())
+
+    # construct fluid list
+    fluid_list = [
+        backend + '::' + fluid for fluid, backend in data['fluids'].items()]
+
+    # delete fluids from data
+    del data['fluids']
+
+    # create network object with its properties
+    nw = Network(fluids=fluid_list, **data)
+
+    return nw
+
+# %% create connections
+
+
+def construct_connections(c, *args):
+    r"""
+    Create TESPy connection from data in the .csv-file and its parameters.
+
+    Parameters
+    ----------
+    c : pandas.core.series.Series
+        Connection information from .csv-file.
+
+    args[0] : pandas.core.frame.DataFrame
+        DataFrame containing all created components.
+
+    Returns
+    -------
+    conn : tespy.connections.connection.Connection
+        TESPy connection object.
+    """
+    # create connection
+    conn = Connection(
+        args[0].instance[c.source], c.source_id,
+        args[0].instance[c.target], c.target_id, label=str(c.label)
+    )
+
+    # read basic properties
+    for key in ['design', 'offdesign', 'design_path', 'local_design',
+                'local_offdesign']:
+        if key in c:
+            if isinstance(c[key], float):
+                setattr(conn, key, None)
+            else:
+                setattr(conn, key, c[key])
+
+    # read fluid properties
+    for key in ['m', 'p', 'h', 'T', 'x', 'v', 'Td_bp']:
+        if key in c:
+            setattr(conn, key, dc_prop(
+                val=c[key], val0=c[key + '0'], val_set=c[key + '_set'],
+                unit=c[key + '_unit'], ref=None, ref_set=c[key + '_ref_set']))
+
+    if 'state' in c:
+        conn.state = dc_simple(val=c[key], is_set=c[key + '_set'])
+
+    # read fluid vector
+    val = {}
+    val0 = {}
+    val_set = {}
+    for key in args[1].fluids:
+        if key in c:
+            val[key] = c[key]
+            val0[key] = c[key + '0']
+            val_set[key] = c[key + '_set']
+
+    conn.fluid = dc_flu(
+        val=val, val0=val0, val_set=val_set, balance=c['balance'])
+
+    # write properties to connection and return connection object
+    return conn
+
+# %% set references on connections
+
+
+def conns_set_ref(c, *args):
+    r"""
+    Set references on connections as specified in connection data.
+
+    Parameters
+    ----------
+    c : pandas.core.series.Series
+        Connection information from .csv-file.
+
+    args[0] : pandas.core.frame.DataFrame
+        DataFrame containing all created connections.
+
+    Returns
+    -------
+    instance : tespy.connections.ref
+        TESPy reference object.
+    """
+    for col in ['m', 'p', 'h', 'T']:
+        # search for referenced connections
+        if isinstance(c[col + '_ref'], str):
+            # create reference object
+            instance = args[0].instance[c[col + '_ref'] ==
+                                        args[0]['id']].values[0]
+            # write to connection properties
+            c['instance'].get_attr(col).ref = Ref(
+                instance, c[col + '_ref_f'], c[col + '_ref_d'])
+
+# %% create busses
+
+
+def construct_busses(c, *args):
+    r"""
+    Create busses of the network.
+
+    Parameters
+    ----------
+    c : pandas.core.series.Series
+        Bus information from .csv-file.
+
+    Returns
+    -------
+    b : tespy.connections.bus.Bus
+        TESPy bus object.
+    """
+    # set up bus with label and specify value for power
+    b = Bus(str(c.label), P=c.P)
+    b.P.is_set = c.P_set
+    return b
+
+# %% add components to busses
+
+
+def busses_add_comps(c, *args):
+    r"""
+    Add components to busses according to data from .csv file.
+
+    Parameters
+    ----------
+    c : pandas.core.series.Series
+        Component information from .csv-file.
+
+    args[0] : pandas.core.frame.DataFrame
+        DataFrame containing all created busses.
+
+    args[1] : pandas.core.frame.DataFrame
+        DataFrame containing all created characteristic lines.
+    """
+    i = 0
+    for b in c.busses:
+        param = c.bus_param[i]
+        P_ref = c.bus_P_ref[i]
+        char = c.bus_char[i]
+        base = 'component'
+        if 'bus_base' in c.index:
+            base = c.bus_base[i]
+
+        values = char == args[1]['id']
+        char = CharLine(x=args[1][values].x.values[0],
+                        y=args[1][values].y.values[0])
+
+        # add component with corresponding details to bus
+        args[0].instance[b == args[0]['label']].values[0].add_comps({
+            'comp': c.instance,
+            'param': param,
+            'P_ref': P_ref,
+            'char': char,
+            'base': base})
+        i += 1
```

### Comparing `TESPy-0.6.2/src/tespy/tools/__init__.py` & `TESPy-0.6.3/src/tespy/tools/__init__.py`

 * *Files 8% similar despite different names*

```diff
@@ -4,13 +4,13 @@
 from .characteristics import CharLine  # noqa: F401
 from .characteristics import CharMap  # noqa: F401
 from .characteristics import load_custom_char  # noqa: F401
 from .characteristics import load_default_char  # noqa: F401
 from .data_containers import ComponentCharacteristicMaps  # noqa: F401
 from .data_containers import ComponentCharacteristics  # noqa: F401
 from .data_containers import ComponentProperties  # noqa: F401
-from .data_containers import DataContainerSimple  # noqa: F401
 from .data_containers import FluidComposition  # noqa: F401
 from .data_containers import FluidProperties  # noqa: F401
 from .data_containers import GroupedComponentProperties  # noqa: F401
+from .data_containers import SimpleDataContainer  # noqa: F401
 from .document_models import document_model  # noqa: F401
 from .optimization import OptimizationProblem  # noqa: F401
```

### Comparing `TESPy-0.6.2/src/tespy/tools/characteristics.py` & `TESPy-0.6.3/src/tespy/tools/characteristics.py`

 * *Files 4% similar despite different names*

```diff
@@ -11,20 +11,20 @@
 by the contributors recorded in the version control history of the file,
 available from its original location tespy/tools/characteristics.py
 
 SPDX-License-Identifier: MIT
 """
 
 import json
-import logging
 import os
 
 import numpy as np
 
 from tespy import __datapath__
+from tespy.tools import logger
 from tespy.tools.helpers import extend_basic_path
 
 # %%
 
 
 class CharLine:
     r"""
@@ -70,19 +70,19 @@
         self.x = self.x.astype(float)
         self.y = self.y.astype(float)
 
         if len(self.x) != len(self.y):
             msg = ('Please provide the same amount of x-values and y-values. '
                    'Number of x-values is ' + str(len(self.x)) + ', number of '
                    'y-values is ' + str(len(self.y)) + ' for CharLine.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         msg = ('Created characteristic line function.')
-        logging.debug(msg)
+        logger.debug(msg)
 
     def evaluate(self, x):
         r"""
         Return characteristic line evaluation at x.
 
         Parameters
         ----------
@@ -135,20 +135,20 @@
         x : float
             Input value for linear interpolation.
         """
         if x > self.x[-1]:
             msg = ('Operating point above characteristic line range: '
                    'X=' + str(round(x, 3)) + ' with maximum of ' +
                    str(self.x[-1]) + ' at component ' + c + '.')
-            logging.warning(msg)
+            logger.warning(msg)
         elif x < self.x[0]:
             msg = ('Operating point below characteristic line range: '
                    'X=' + str(round(x, 3)) + ' with minimum of ' +
                    str(self.x[0]) + ' at component ' + c + '.')
-            logging.warning(msg)
+            logger.warning(msg)
 
     def get_attr(self, key):
         r"""
         Get the value of an attribute.
 
         Parameters
         ----------
@@ -160,15 +160,15 @@
         value : object
             Value of object attribute key.
         """
         if key in self.__dict__:
             return self.__dict__[key]
         else:
             msg = 'Char_map has no attribute \"' + key + '\".'
-            logging.error(msg)
+            logger.error(msg)
             raise KeyError(msg)
 
     def plot(self, path, title, xlabel, ylabel):
 
         from matplotlib import pyplot as plt
 
         # plotting
@@ -230,25 +230,25 @@
 
         if self.x.shape[0] != self.y.shape[0]:
             msg = (
                 'The number of x-values determines the number of dimension '
                 'for the characteristic map. You have provided ' +
                 str(len(self.x)) + 'x-values. Thus, the y- and z-arrays must '
                 'have ' + str(len(self.x)) + ' number of dimensions.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
         elif self.y.shape != self.z.shape:
             msg = (
                 'Make sure that the number of dimensions and the number of '
                 'values in the y-, z-arrays are identical!')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         msg = ('Created characteristic map function.')
-        logging.debug(msg)
+        logger.debug(msg)
 
     def evaluate_x(self, x):
         r"""
         Evaluate CharMap for x inputs.
 
         Parameters
         ----------
@@ -362,21 +362,21 @@
         """
         xpos = np.searchsorted(self.x, x)
         if xpos == len(self.x) and x != self.x[-1]:
             yarr = self.y[xpos - 1]
             msg = ('Operating point above CharMap range: '
                    'X=' + str(round(x, 3)) + ' with maximum of ' +
                    str(self.x[-1]) + ' at component ' + c + '.')
-            logging.warning(msg)
+            logger.warning(msg)
         elif xpos == 0 and x != self.x[0]:
             yarr = self.y[0]
             msg = ('Operating point below CharMap range: '
                    'X=' + str(round(x, 3)) + ' with minimum of ' +
                    str(self.x[0]) + ' at component ' + c + '.')
-            logging.warning(msg)
+            logger.warning(msg)
         else:
             yfrac = (x - self.x[xpos - 1]) / (self.x[xpos] - self.x[xpos - 1])
             yarr = self.y[xpos - 1] + yfrac * (self.y[xpos] - self.y[xpos - 1])
 
         return yarr
 
     def get_domain_errors_y(self, y, yarr, c):
@@ -397,21 +397,21 @@
         """
         ypos = np.searchsorted(yarr, y)
         if ypos == len(yarr) and y != yarr[-1]:
             msg = (
                 'Operating point above compressor map range: Y=' +
                 str(round(y, 3)) + ' with maximum of ' + str(yarr[-1]) +
                 ' at component ' + c + '.')
-            logging.warning(msg)
+            logger.warning(msg)
         elif ypos == 0 and y != yarr[0]:
             msg = (
                 'Operating point below compressor map range: Y=' +
                 str(round(y, 3)) + ' with minimum of ' + str(yarr[0]) +
                 ' at component ' + c + '.')
-            logging.warning(msg)
+            logger.warning(msg)
 
     def get_domain_errors(self, x, y, c):
         r"""
         Check the CharMap for bound violations.
 
         Parameters
         ----------
@@ -438,15 +438,15 @@
         value : object
             Value of object attribute key.
         """
         if key in self.__dict__:
             return self.__dict__[key]
         else:
             msg = 'Char_map has no attribute \"' + key + '\".'
-            logging.error(msg)
+            logger.error(msg)
             raise KeyError(msg)
 
     def plot(self, path, title, xlabel, ylabel):
 
         from matplotlib import pyplot as plt
 
         # plotting
@@ -552,9 +552,9 @@
 
         return obj
 
     else:
         msg = ('The file containing your custom charactersitics could not be '
                'found on your system. The path should be ' + path + '. Please '
                'make sure the .tespy/data path exists in your home directory.')
-        logging.error(msg)
+        logger.error(msg)
         raise FileNotFoundError(msg)
```

### Comparing `TESPy-0.6.2/src/tespy/tools/data_containers.py` & `TESPy-0.6.3/src/tespy/tools/data_containers.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,469 +1,470 @@
-# -*- coding: utf-8
-
-"""Module for data container classes.
-
-The DataContainer class and its subclasses are used to store component or
-connection properties.
-
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location tespy/tools/data_containers.py
-
-SPDX-License-Identifier: MIT
-"""
-
-import collections
-import logging
-
-import numpy as np
-
-# %%
-
-
-class DataContainer:
-    """
-    The DataContainer is parent class for all data containers.
-
-    Parameters
-    ----------
-    **kwargs :
-        See the class documentation of desired DataContainer for available
-        keywords.
-
-    Note
-    ----
-    The initialisation method (:code:`__init__`), setter method
-    (:code:`set_attr`) and getter method (:code:`get_attr`) are used for
-    instances of class DataContainer and its children. TESPy uses different
-    :code:`DataContainer` classes for specific objectives:
-
-    - component characteristics
-      :py:class:`tespy.tools.data_containers.ComponentCharacteristics`
-    - component characteristic maps
-      :py:class:`tespy.tools.data_containers.ComponentCharacteristicMaps`
-    - component properties
-      :py:class:`tespy.tools.data_containers.ComponentProperties`
-    - grouped component properites
-      :py:class:`tespy.tools.data_containers.GroupedComponentProperties`
-    - fluid composition
-      :py:class:`tespy.tools.data_containers.FluidComposition`
-    - fluid properties
-      :py:class:`tespy.tools.data_containers.FluidProperties`
-
-    Grouped component properties are used, if more than one component property
-    has to be specified in order to apply one equation, e.g. pressure drop in
-    pipes by specified length, diameter and roughness. If you specify all three
-    of these properties, the DataContainer for the group will be created
-    automatically!
-
-    For the full list of available parameters for each data container, see its
-    documentation.
-
-    Example
-    -------
-    The examples below show the different (sub-)classes of DataContainers
-    available.
-
-    >>> from tespy.tools.data_containers import (
-    ... ComponentCharacteristics, ComponentCharacteristicMaps,
-    ... ComponentProperties, FluidComposition, GroupedComponentProperties,
-    ... FluidProperties, DataContainerSimple)
-    >>> from tespy.components import Pipe
-    >>> type(ComponentCharacteristicMaps(is_set=True))
-    <class 'tespy.tools.data_containers.ComponentCharacteristicMaps'>
-    >>> type(ComponentCharacteristics(is_set=True, param='m'))
-    <class 'tespy.tools.data_containers.ComponentCharacteristics'>
-    >>> type(ComponentProperties(val=100, is_set=True, is_var=True,
-    ...      max_val=1000, min_val=1))
-    <class 'tespy.tools.data_containers.ComponentProperties'>
-    >>> pi = Pipe('testpipe', L=100, D=0.5, ks=5e-5)
-    >>> type(GroupedComponentProperties(is_set=True,
-    ...      elements=[pi.L, pi.D, pi.ks], method='default'))
-    <class 'tespy.tools.data_containers.GroupedComponentProperties'>
-    >>> type(FluidComposition(
-    ... val={'CO2': 0.1, 'H2O': 0.11, 'N2': 0.75, 'O2': 0.03},
-    ... val_set={'CO2': False, 'H2O': False, 'N2': False, 'O2': True},
-    ... balance=False))
-    <class 'tespy.tools.data_containers.FluidComposition'>
-    >>> type(FluidProperties(val=5, val_SI=500000, val_set=True, unit='bar',
-    ...      ref=None, ref_set=False))
-    <class 'tespy.tools.data_containers.FluidProperties'>
-    >>> type(DataContainerSimple(val=5, is_set=False))
-    <class 'tespy.tools.data_containers.DataContainerSimple'>
-    """
-
-    def __init__(self, **kwargs):
-
-        var = self.attr()
-
-        # default values
-        for key in var.keys():
-            self.__dict__.update({key: var[key]})
-
-        self.set_attr(**kwargs)
-
-    def set_attr(self, **kwargs):
-        """
-        Sets, resets or unsets attributes of a DataContainer type object.
-
-        Parameters
-        ----------
-        **kwargs :
-            See the class documentation of desired DataContainer for available
-            keywords.
-        """
-        var = self.attr()
-        # specify values
-        for key in kwargs:
-            if key in var:
-                self.__dict__.update({key: kwargs[key]})
-
-            else:
-                msg = ('Data container of type ' + self.__class__.__name__ +
-                       ' has no attribute ' + key + '.')
-                logging.error(msg)
-                raise KeyError(msg)
-
-    def get_attr(self, key):
-        """
-        Get the value of a DataContainer's attribute.
-
-        Parameters
-        ----------
-        key : str
-            The attribute you want to retrieve.
-
-        Returns
-        -------
-        out :
-            Specified attribute.
-        """
-        if key in self.__dict__:
-            return self.__dict__[key]
-        else:
-            msg = ('Datacontainer of type ' + self.__class__.__name__ +
-                   ' has no attribute \"' + str(key) + '\".')
-            logging.error(msg)
-            raise KeyError(msg)
-
-    @staticmethod
-    def attr():
-        """
-        Return the available attributes for a DataContainer type object.
-
-        Returns
-        -------
-        out : dict
-            Dictionary of available attributes (dictionary keys) with default
-            values.
-        """
-        return {}
-
-
-class ComponentCharacteristics(DataContainer):
-    """
-    Data container for component characteristics.
-
-    Parameters
-    ----------
-    func : tespy.components.characteristics.characteristics
-        Function to be applied for this characteristics, default: None.
-
-    is_set : boolean
-        Should this equation be applied?, default: is_set=False.
-
-    param : str
-        Which parameter should be applied as the x value?
-        default: method='default'.
-    """
-
-    @staticmethod
-    def attr():
-        """
-        Return the available attributes for a ComponentCharacteristics
-        type object.
-
-        Returns
-        -------
-        out : dict
-            Dictionary of available attributes (dictionary keys) with default
-            values.
-        """
-        return {
-            'char_func': None, 'is_set': False, 'param': None,
-            'func_params': {}, 'func': None, 'deriv': None, 'latex': None,
-            'char_params': {'type': 'rel', 'inconn': 0, 'outconn': 0},
-            'num_eq': 0}
-
-
-class ComponentCharacteristicMaps(DataContainer):
-    """
-    Data container for characteristic maps.
-
-    Parameters
-    ----------
-    func : tespy.components.characteristics.characteristics
-        Function to be applied for this characteristic map, default: None.
-
-    is_set : boolean
-        Should this equation be applied?, default: is_set=False.
-
-    param : str
-        Which parameter should be applied as the x value?
-        default: method='default'.
-    """
-
-    @staticmethod
-    def attr():
-        """
-        Return the available attributes for a ComponentCharacteristicMaps type
-        object.
-
-        Returns
-        -------
-        out : dict
-            Dictionary of available attributes (dictionary keys) with default
-            values.
-        """
-        return {
-            'char_func': None, 'is_set': False, 'param': None, 'latex': None,
-            'func_params': {}, 'func': None, 'deriv': None,
-            'num_eq': 0}
-
-
-class ComponentProperties(DataContainer):
-    """
-    Data container for component properties.
-
-    Parameters
-    ----------
-    val : float
-        Value for this component attribute, default: val=1.
-
-    val_SI : float
-        Value in SI_unit (available for temperatures only, unit transformation
-        according to network's temperature unit), default: val_SI=0.
-
-    is_set : boolean
-        Has the value for this attribute been set?, default: is_set=False.
-
-    is_var : boolean
-        Is this attribute part of the system variables?, default: is_var=False.
-
-    d : float
-        Interval width for numerical calculation of partial derivative towards
-        this attribute, it is part of the system variables, default d=1e-4.
-
-    min_val : float
-        Minimum value for this attribute, used if attribute is part of the
-        system variables, default: min_val=1.1e-4.
-
-    max_val : float
-        Maximum value for this attribute, used if attribute is part of the
-        system variables, default: max_val=1e12.
-    """
-
-    @staticmethod
-    def attr():
-        """
-        Return the available attributes for a ComponentProperties type object.
-
-        Returns
-        -------
-        out : dict
-            Dictionary of available attributes (dictionary keys) with default
-            values.
-        """
-        return {
-            'val': 1, 'val_SI': 0, 'is_set': False, 'd': 1e-4,
-            'min_val': -1e12, 'max_val': 1e12, 'is_var': False,
-            'val_ref': 1, 'design': np.nan, 'is_result': False,
-            'num_eq': 0, 'func_params': {}, 'func': None, 'deriv': None,
-            'latex': None}
-
-
-class FluidComposition(DataContainer):
-    """
-    Data container for fluid composition.
-
-    Parameters
-    ----------
-    val : dict
-        Mass fractions of the fluids in a mixture, default: val={}.
-        Pattern for dictionary: keys are fluid name, values are mass fractions.
-
-    val0 : dict
-        Starting values for mass fractions of the fluids in a mixture,
-        default: val0={}. Pattern for dictionary: keys are fluid name, values
-        are mass fractions.
-
-    val_set : dict
-        Which fluid mass fractions have been set, default val_set={}.
-        Pattern for dictionary: keys are fluid name, values are True or False.
-
-    balance : boolean
-        Should the fluid balance equation be applied for this mixture?
-        default: False.
-    """
-
-    @staticmethod
-    def attr():
-        """
-        Return the available attributes for a FluidComposition type object.
-
-        Returns
-        -------
-        out : dict
-            Dictionary of available attributes (dictionary keys) with default
-            values.
-        """
-        return {'val': {}, 'val0': {}, 'val_set': {},
-                'design': collections.OrderedDict(), 'balance': False}
-
-
-class GroupedComponentProperties(DataContainer):
-    """
-    Data container for grouped component parameters.
-
-    Parameters
-    ----------
-    is_set : boolean
-        Should the equation for this parameter group be applied?
-        default: is_set=False.
-
-    method : str
-        Which calculation method for this parameter group should be used?
-        default: method='default'.
-
-    elements : list
-        Which component properties are part of this component group?
-        default elements=[].
-    """
-
-    @staticmethod
-    def attr():
-        """
-        Return the available attributes for a GroupedComponentProperties type
-        object.
-
-        Returns
-        -------
-        out : dict
-            Dictionary of available attributes (dictionary keys) with default
-            values.
-        """
-        return {'is_set': False, 'method': 'default', 'elements': [],
-                'func': None, 'deriv': None, 'num_eq': 0, 'latex': None,
-                'func_params': {}}
-
-
-class GroupedComponentCharacteristics(DataContainer):
-    """
-    Data container for grouped component characteristics.
-
-    Parameters
-    ----------
-    is_set : boolean
-        Should the equation for this parameter group be applied?
-        default: is_set=False.
-
-    elements : list
-        Which component properties are part of this component group?
-        default elements=[].
-    """
-
-    @staticmethod
-    def attr():
-        """
-        Return the available attributes for a GroupedComponentCharacteristics
-        type object.
-
-        Returns
-        -------
-        out : dict
-            Dictionary of available attributes (dictionary keys) with default
-            values.
-        """
-        return {'is_set': False, 'elements': [], 'func': None, 'deriv': None,
-                'num_eq': 0, 'latex': None, 'func_params': {}}
-
-
-class FluidProperties(DataContainer):
-    """
-    Data container for fluid properties.
-
-    Parameters
-    ----------
-    val : float
-        Value in user specified unit (or network unit) if unit is unspecified,
-        default: val=np.nan.
-
-    val0 : float
-        Starting value in user specified unit (or network unit) if unit is
-        unspecified, default: val0=np.nan.
-
-    val_SI : float
-        Value in SI_unit, default: val_SI=0.
-
-    val_set : boolean
-        Has the value for this property been set? default: val_set=False.
-
-    ref : tespy.connections.ref
-        Reference object, default: ref=None.
-
-    ref_set : boolean
-        Has a value for this property been referenced to another connection?
-        default: ref_set=False.
-
-    unit : str
-        Unit for this property, default: ref=None.
-
-    unit : boolean
-        Has the unit for this property been specified manually by the user?
-        default: unit_set=False.
-    """
-
-    @staticmethod
-    def attr():
-        r"""
-        Return the available attributes for a FluidProperties type object.
-
-        Returns
-        -------
-        out : dict
-            Dictionary of available attributes (dictionary keys) with default
-            values.
-        """
-        return {'val': np.nan, 'val0': np.nan, 'val_SI': 0, 'val_set': False,
-                'ref': None, 'ref_set': False, 'unit': None, 'design': np.nan}
-
-
-class DataContainerSimple(DataContainer):
-    """
-    Simple data container without data type restrictions to val field.
-
-    Parameters
-    ----------
-    val : no specific datatype
-        Value for the property, no predefined datatype.
-
-    is_set : boolean
-        Has the value for this property been set? default: val_set=False.
-    """
-
-    @staticmethod
-    def attr():
-        r"""
-        Return the available attributes for a DataContainerSimple type object.
-
-        Returns
-        -------
-        out : dict
-            Dictionary of available attributes (dictionary keys) with default
-            values.
-        """
-        return {
-            'val': np.nan, 'is_set': False,
-            'func_params': {}, 'func': None, 'deriv': None, 'latex': None,
-            'num_eq': 0}
+# -*- coding: utf-8
+
+"""Module for data container classes.
+
+The DataContainer class and its subclasses are used to store component or
+connection properties.
+
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location tespy/tools/data_containers.py
+
+SPDX-License-Identifier: MIT
+"""
+
+import collections
+
+import numpy as np
+
+from tespy.tools import logger
+
+# %%
+
+
+class DataContainer:
+    """
+    The DataContainer is parent class for all data containers.
+
+    Parameters
+    ----------
+    **kwargs :
+        See the class documentation of desired DataContainer for available
+        keywords.
+
+    Note
+    ----
+    The initialisation method (:code:`__init__`), setter method
+    (:code:`set_attr`) and getter method (:code:`get_attr`) are used for
+    instances of class DataContainer and its children. TESPy uses different
+    :code:`DataContainer` classes for specific objectives:
+
+    - component characteristics
+      :py:class:`tespy.tools.data_containers.ComponentCharacteristics`
+    - component characteristic maps
+      :py:class:`tespy.tools.data_containers.ComponentCharacteristicMaps`
+    - component properties
+      :py:class:`tespy.tools.data_containers.ComponentProperties`
+    - grouped component properites
+      :py:class:`tespy.tools.data_containers.GroupedComponentProperties`
+    - fluid composition
+      :py:class:`tespy.tools.data_containers.FluidComposition`
+    - fluid properties
+      :py:class:`tespy.tools.data_containers.FluidProperties`
+
+    Grouped component properties are used, if more than one component property
+    has to be specified in order to apply one equation, e.g. pressure drop in
+    pipes by specified length, diameter and roughness. If you specify all three
+    of these properties, the DataContainer for the group will be created
+    automatically!
+
+    For the full list of available parameters for each data container, see its
+    documentation.
+
+    Example
+    -------
+    The examples below show the different (sub-)classes of DataContainers
+    available.
+
+    >>> from tespy.tools.data_containers import (
+    ... ComponentCharacteristics, ComponentCharacteristicMaps,
+    ... ComponentProperties, FluidComposition, GroupedComponentProperties,
+    ... FluidProperties, SimpleDataContainer)
+    >>> from tespy.components import Pipe
+    >>> type(ComponentCharacteristicMaps(is_set=True))
+    <class 'tespy.tools.data_containers.ComponentCharacteristicMaps'>
+    >>> type(ComponentCharacteristics(is_set=True, param='m'))
+    <class 'tespy.tools.data_containers.ComponentCharacteristics'>
+    >>> type(ComponentProperties(val=100, is_set=True, is_var=True,
+    ...      max_val=1000, min_val=1))
+    <class 'tespy.tools.data_containers.ComponentProperties'>
+    >>> pi = Pipe('testpipe', L=100, D=0.5, ks=5e-5)
+    >>> type(GroupedComponentProperties(is_set=True,
+    ...      elements=[pi.L, pi.D, pi.ks], method='default'))
+    <class 'tespy.tools.data_containers.GroupedComponentProperties'>
+    >>> type(FluidComposition(
+    ... val={'CO2': 0.1, 'H2O': 0.11, 'N2': 0.75, 'O2': 0.03},
+    ... val_set={'CO2': False, 'H2O': False, 'N2': False, 'O2': True},
+    ... balance=False))
+    <class 'tespy.tools.data_containers.FluidComposition'>
+    >>> type(FluidProperties(val=5, val_SI=500000, val_set=True, unit='bar',
+    ...      ref=None, ref_set=False))
+    <class 'tespy.tools.data_containers.FluidProperties'>
+    >>> type(SimpleDataContainer(val=5, is_set=False))
+    <class 'tespy.tools.data_containers.SimpleDataContainer'>
+    """
+
+    def __init__(self, **kwargs):
+
+        var = self.attr()
+
+        # default values
+        for key in var.keys():
+            self.__dict__.update({key: var[key]})
+
+        self.set_attr(**kwargs)
+
+    def set_attr(self, **kwargs):
+        """
+        Sets, resets or unsets attributes of a DataContainer type object.
+
+        Parameters
+        ----------
+        **kwargs :
+            See the class documentation of desired DataContainer for available
+            keywords.
+        """
+        var = self.attr()
+        # specify values
+        for key in kwargs:
+            if key in var:
+                self.__dict__.update({key: kwargs[key]})
+
+            else:
+                msg = ('Data container of type ' + self.__class__.__name__ +
+                       ' has no attribute ' + key + '.')
+                logger.error(msg)
+                raise KeyError(msg)
+
+    def get_attr(self, key):
+        """
+        Get the value of a DataContainer's attribute.
+
+        Parameters
+        ----------
+        key : str
+            The attribute you want to retrieve.
+
+        Returns
+        -------
+        out :
+            Specified attribute.
+        """
+        if key in self.__dict__:
+            return self.__dict__[key]
+        else:
+            msg = ('Datacontainer of type ' + self.__class__.__name__ +
+                   ' has no attribute \"' + str(key) + '\".')
+            logger.error(msg)
+            raise KeyError(msg)
+
+    @staticmethod
+    def attr():
+        """
+        Return the available attributes for a DataContainer type object.
+
+        Returns
+        -------
+        out : dict
+            Dictionary of available attributes (dictionary keys) with default
+            values.
+        """
+        return {}
+
+
+class ComponentCharacteristics(DataContainer):
+    """
+    Data container for component characteristics.
+
+    Parameters
+    ----------
+    func : tespy.components.characteristics.characteristics
+        Function to be applied for this characteristics, default: None.
+
+    is_set : boolean
+        Should this equation be applied?, default: is_set=False.
+
+    param : str
+        Which parameter should be applied as the x value?
+        default: method='default'.
+    """
+
+    @staticmethod
+    def attr():
+        """
+        Return the available attributes for a ComponentCharacteristics
+        type object.
+
+        Returns
+        -------
+        out : dict
+            Dictionary of available attributes (dictionary keys) with default
+            values.
+        """
+        return {
+            'char_func': None, 'is_set': False, 'param': None,
+            'func_params': {}, 'func': None, 'deriv': None, 'latex': None,
+            'char_params': {'type': 'rel', 'inconn': 0, 'outconn': 0},
+            'num_eq': 0}
+
+
+class ComponentCharacteristicMaps(DataContainer):
+    """
+    Data container for characteristic maps.
+
+    Parameters
+    ----------
+    func : tespy.components.characteristics.characteristics
+        Function to be applied for this characteristic map, default: None.
+
+    is_set : boolean
+        Should this equation be applied?, default: is_set=False.
+
+    param : str
+        Which parameter should be applied as the x value?
+        default: method='default'.
+    """
+
+    @staticmethod
+    def attr():
+        """
+        Return the available attributes for a ComponentCharacteristicMaps type
+        object.
+
+        Returns
+        -------
+        out : dict
+            Dictionary of available attributes (dictionary keys) with default
+            values.
+        """
+        return {
+            'char_func': None, 'is_set': False, 'param': None, 'latex': None,
+            'func_params': {}, 'func': None, 'deriv': None,
+            'num_eq': 0}
+
+
+class ComponentProperties(DataContainer):
+    """
+    Data container for component properties.
+
+    Parameters
+    ----------
+    val : float
+        Value for this component attribute, default: val=1.
+
+    val_SI : float
+        Value in SI_unit (available for temperatures only, unit transformation
+        according to network's temperature unit), default: val_SI=0.
+
+    is_set : boolean
+        Has the value for this attribute been set?, default: is_set=False.
+
+    is_var : boolean
+        Is this attribute part of the system variables?, default: is_var=False.
+
+    d : float
+        Interval width for numerical calculation of partial derivative towards
+        this attribute, it is part of the system variables, default d=1e-4.
+
+    min_val : float
+        Minimum value for this attribute, used if attribute is part of the
+        system variables, default: min_val=1.1e-4.
+
+    max_val : float
+        Maximum value for this attribute, used if attribute is part of the
+        system variables, default: max_val=1e12.
+    """
+
+    @staticmethod
+    def attr():
+        """
+        Return the available attributes for a ComponentProperties type object.
+
+        Returns
+        -------
+        out : dict
+            Dictionary of available attributes (dictionary keys) with default
+            values.
+        """
+        return {
+            'val': 1, 'val_SI': 0, 'is_set': False, 'd': 1e-4,
+            'min_val': -1e12, 'max_val': 1e12, 'is_var': False,
+            'val_ref': 1, 'design': np.nan, 'is_result': False,
+            'num_eq': 0, 'func_params': {}, 'func': None, 'deriv': None,
+            'latex': None}
+
+
+class FluidComposition(DataContainer):
+    """
+    Data container for fluid composition.
+
+    Parameters
+    ----------
+    val : dict
+        Mass fractions of the fluids in a mixture, default: val={}.
+        Pattern for dictionary: keys are fluid name, values are mass fractions.
+
+    val0 : dict
+        Starting values for mass fractions of the fluids in a mixture,
+        default: val0={}. Pattern for dictionary: keys are fluid name, values
+        are mass fractions.
+
+    val_set : dict
+        Which fluid mass fractions have been set, default val_set={}.
+        Pattern for dictionary: keys are fluid name, values are True or False.
+
+    balance : boolean
+        Should the fluid balance equation be applied for this mixture?
+        default: False.
+    """
+
+    @staticmethod
+    def attr():
+        """
+        Return the available attributes for a FluidComposition type object.
+
+        Returns
+        -------
+        out : dict
+            Dictionary of available attributes (dictionary keys) with default
+            values.
+        """
+        return {'val': {}, 'val0': {}, 'val_set': {},
+                'design': collections.OrderedDict(), 'balance': False}
+
+
+class GroupedComponentProperties(DataContainer):
+    """
+    Data container for grouped component parameters.
+
+    Parameters
+    ----------
+    is_set : boolean
+        Should the equation for this parameter group be applied?
+        default: is_set=False.
+
+    method : str
+        Which calculation method for this parameter group should be used?
+        default: method='default'.
+
+    elements : list
+        Which component properties are part of this component group?
+        default elements=[].
+    """
+
+    @staticmethod
+    def attr():
+        """
+        Return the available attributes for a GroupedComponentProperties type
+        object.
+
+        Returns
+        -------
+        out : dict
+            Dictionary of available attributes (dictionary keys) with default
+            values.
+        """
+        return {'is_set': False, 'method': 'default', 'elements': [],
+                'func': None, 'deriv': None, 'num_eq': 0, 'latex': None,
+                'func_params': {}}
+
+
+class GroupedComponentCharacteristics(DataContainer):
+    """
+    Data container for grouped component characteristics.
+
+    Parameters
+    ----------
+    is_set : boolean
+        Should the equation for this parameter group be applied?
+        default: is_set=False.
+
+    elements : list
+        Which component properties are part of this component group?
+        default elements=[].
+    """
+
+    @staticmethod
+    def attr():
+        """
+        Return the available attributes for a GroupedComponentCharacteristics
+        type object.
+
+        Returns
+        -------
+        out : dict
+            Dictionary of available attributes (dictionary keys) with default
+            values.
+        """
+        return {'is_set': False, 'elements': [], 'func': None, 'deriv': None,
+                'num_eq': 0, 'latex': None, 'func_params': {}}
+
+
+class FluidProperties(DataContainer):
+    """
+    Data container for fluid properties.
+
+    Parameters
+    ----------
+    val : float
+        Value in user specified unit (or network unit) if unit is unspecified,
+        default: val=np.nan.
+
+    val0 : float
+        Starting value in user specified unit (or network unit) if unit is
+        unspecified, default: val0=np.nan.
+
+    val_SI : float
+        Value in SI_unit, default: val_SI=0.
+
+    val_set : boolean
+        Has the value for this property been set? default: val_set=False.
+
+    ref : tespy.connections.ref
+        Reference object, default: ref=None.
+
+    ref_set : boolean
+        Has a value for this property been referenced to another connection?
+        default: ref_set=False.
+
+    unit : str
+        Unit for this property, default: ref=None.
+
+    unit : boolean
+        Has the unit for this property been specified manually by the user?
+        default: unit_set=False.
+    """
+
+    @staticmethod
+    def attr():
+        r"""
+        Return the available attributes for a FluidProperties type object.
+
+        Returns
+        -------
+        out : dict
+            Dictionary of available attributes (dictionary keys) with default
+            values.
+        """
+        return {'val': np.nan, 'val0': np.nan, 'val_SI': 0, 'val_set': False,
+                'ref': None, 'ref_set': False, 'unit': None, 'design': np.nan}
+
+
+class SimpleDataContainer(DataContainer):
+    """
+    Simple data container without data type restrictions to val field.
+
+    Parameters
+    ----------
+    val : no specific datatype
+        Value for the property, no predefined datatype.
+
+    is_set : boolean
+        Has the value for this property been set? default: val_set=False.
+    """
+
+    @staticmethod
+    def attr():
+        r"""
+        Return the available attributes for a SimpleDataContainer type object.
+
+        Returns
+        -------
+        out : dict
+            Dictionary of available attributes (dictionary keys) with default
+            values.
+        """
+        return {
+            'val': np.nan, 'is_set': False,
+            'func_params': {}, 'func': None, 'deriv': None, 'latex': None,
+            'num_eq': 0}
```

### Comparing `TESPy-0.6.2/src/tespy/tools/document_models.py` & `TESPy-0.6.3/src/tespy/tools/document_models.py`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/src/tespy/tools/fluid_properties.py` & `TESPy-0.6.3/src/tespy/tools/fluid_properties.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,1749 +1,1816 @@
-# -*- coding: utf-8
-
-"""Module for fluid property integration.
-
-TESPy uses the CoolProp python interface for all fluid property functions.
-
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location tespy/tools/fluid_properties.py
-
-SPDX-License-Identifier: MIT
-"""
-
-import logging
-
-import CoolProp as CP
-import numpy as np
-from CoolProp.CoolProp import PropsSI as CPPSI
-from CoolProp.CoolProp import get_aliases
-
-from tespy.tools.global_vars import err
-from tespy.tools.global_vars import gas_constants
-from tespy.tools.global_vars import molar_masses
-from tespy.tools.helpers import molar_mass_flow
-from tespy.tools.helpers import newton
-from tespy.tools.helpers import single_fluid
-
-
-class Memorise:
-    r"""Memorization of fluid properties."""
-
-    @staticmethod
-    def add_fluids(fluids, memorise_fluid_properties=True):
-        r"""
-        Add list of fluids to fluid memorisation class.
-
-        - Generate arrays for fluid property lookup if memorisation is
-          activated.
-        - Calculate/set fluid property value ranges for convergence checks.
-
-        Parameters
-        ----------
-        fluids : dict
-            Dict of fluid and corresponding CoolProp back end for fluid
-            property memorization.
-
-        memorise_fluid_properties : boolean
-            Activate or deactivate fluid property value memorisation. Default
-            state is activated (:code:`True`).
-
-        Note
-        ----
-        The Memorise class creates globally accessible variables for different
-        fluid property calls as dictionaries:
-
-        - T(p,h)
-        - T(p,s)
-        - v(p,h)
-        - visc(p,h)
-        - s(p,h)
-
-        Each dictionary uses the list of fluids passed to the Memorise class as
-        identifier for the fluid property memorisation. The fluid properties
-        are stored as numpy array, where each column represents the mass
-        fraction of the respective fluid and the additional columns are the
-        values for the fluid properties. The fluid property function will then
-        look for identical fluid property inputs (p, h, (s), fluid mass
-        fraction). If the inputs are in the array, the first column of that row
-        is returned, see example.
-
-        Example
-        -------
-        T(p,h) for set of fluids ('water', 'air'):
-
-        - row 1: [282.64527752319697, 10000, 40000, 1, 0]
-        - row 2: [284.3140698256616, 10000, 47000, 1, 0]
-        """
-        # number of fluids
-        num_fl = len(fluids)
-        if memorise_fluid_properties and num_fl > 0:
-            fl = tuple(fluids.keys())
-            # fluid property tables
-            Memorise.T_ph[fl] = np.empty((0, num_fl + 4), float)
-            Memorise.T_ps[fl] = np.empty((0, num_fl + 5), float)
-            Memorise.v_ph[fl] = np.empty((0, num_fl + 4), float)
-            Memorise.visc_ph[fl] = np.empty((0, num_fl + 4), float)
-            Memorise.s_ph[fl] = np.empty((0, num_fl + 4), float)
-
-            msg = (
-                'Added fluids ' + ', '.join(fl) +
-                ' to memorise lookup tables.')
-            logging.debug(msg)
-
-        Memorise.water = None
-        for f, back_end in fluids.items():
-
-            # save name for water in memorise
-            if f in get_aliases("H2O"):
-                Memorise.water = f
-
-            if f in Memorise.state:
-                del Memorise.state[f]
-
-            # create CoolProp.AbstractState object
-            try:
-                Memorise.state[f] = CP.AbstractState(back_end, f)
-                Memorise.back_end[f] = back_end
-            except ValueError:
-                msg = (
-                    'Could not find the fluid "' + f + '" in the fluid '
-                    'property database.'
-                )
-                logging.warning(msg)
-                continue
-
-            msg = (
-                'Created CoolProp.AbstractState object for fluid ' +
-                f + ' with back end ' + back_end + '.')
-            logging.debug(msg)
-            # pressure range
-            try:
-                pmin = Memorise.state[f].trivial_keyed_output(CP.iP_min)
-                pmax = Memorise.state[f].trivial_keyed_output(CP.iP_max)
-            except ValueError:
-                pmin = 1e4
-                pmax = 1e8
-                msg = (
-                    'Could not find values for maximum and minimum '
-                    'pressure.')
-                logging.warning(msg)
-
-            # temperature range
-            Tmin = Memorise.state[f].trivial_keyed_output(CP.iT_min)
-            Tmax = Memorise.state[f].trivial_keyed_output(CP.iT_max)
-
-            # value range for fluid properties
-            Memorise.value_range[f] = [pmin, pmax, Tmin, Tmax]
-
-            try:
-                molar_masses[f] = Memorise.state[f].molar_mass()
-                gas_constants[f] = Memorise.state[f].gas_constant()
-            except ValueError:
-                try:
-                    molar_masses[f] = CPPSI('M', f)
-                    gas_constants[f] = CPPSI('GAS_CONSTANT', f)
-                except ValueError:
-                    molar_masses[f] = 1
-                    gas_constants[f] = 1
-                    msg = (
-                        'Could not find values for molar mass and gas '
-                        'constant.')
-                    logging.warning(msg)
-
-            msg = (
-                'Specifying fluid property ranges for pressure and '
-                'temperature for convergence check of fluid ' + f + '.')
-            logging.debug(msg)
-
-    @staticmethod
-    def del_memory(fluids):
-        r"""
-        Delete non frequently used fluid property values from memorise class.
-
-        Parameters
-        ----------
-        fluids : list
-            List of fluid for fluid property memorization.
-        """
-        fl = tuple(fluids)
-        threshold = 3
-        try:
-            # delete memory
-            Memorise.s_ph[fl] = Memorise.s_ph[fl][
-                Memorise.s_ph[fl][:, -1] > threshold]
-            Memorise.s_ph[fl][:, -1] = 0
-
-            Memorise.T_ph[fl] = Memorise.T_ph[fl][
-                Memorise.T_ph[fl][:, -1] > threshold]
-            Memorise.T_ph[fl][:, -1] = 0
-
-            Memorise.T_ps[fl] = Memorise.T_ps[fl][
-                Memorise.T_ps[fl][:, -1] > threshold]
-            Memorise.T_ps[fl][:, -1] = 0
-
-            Memorise.v_ph[fl] = Memorise.v_ph[fl][
-                Memorise.v_ph[fl][:, -1] > threshold]
-            Memorise.v_ph[fl][:, -1] = 0
-
-            Memorise.visc_ph[fl] = Memorise.visc_ph[fl][
-                Memorise.visc_ph[fl][:, -1] > threshold]
-            Memorise.visc_ph[fl][:, -1] = 0
-
-            msg = ('Dropping not frequently used fluid property values from '
-                   'memorise class for fluids ' + ', '.join(fl) + '.')
-            logging.debug(msg)
-        except KeyError:
-            pass
-
-
-# create memorise dictionaries
-Memorise.state = {}
-Memorise.back_end = {}
-Memorise.T_ph = {}
-Memorise.T_ps = {}
-Memorise.v_ph = {}
-Memorise.visc_ph = {}
-Memorise.s_ph = {}
-Memorise.value_range = {}
-
-
-def T_mix_ph(flow, T0=675):
-    r"""
-    Calculate the temperature from pressure and enthalpy.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    Returns
-    -------
-    T : float
-        Temperature T / K.
-
-    Note
-    ----
-    First, check if fluid property has been memorised already.
-    If this is the case, return stored value, otherwise calculate value and
-    store it in the memorisation class.
-
-    Uses CoolProp interface for pure fluids, newton algorithm for mixtures:
-
-    .. math::
-
-        T_{mix}\left(p,h\right) = T_{i}\left(p,h_{i}\right)\;
-        \forall i \in \text{fluid components}\\
-
-        h_{i} = h \left(pp_{i}, T_{mix} \right)\\
-        pp: \text{partial pressure}
-    """
-    # check if fluid properties have been calculated before
-    fl = tuple(flow[3].keys())
-    memorisation = fl in Memorise.T_ph
-    if memorisation:
-        a = Memorise.T_ph[fl][:, :-2]
-        b = np.array([flow[1], flow[2]] + list(flow[3].values()))
-        ix = np.where(np.all(abs(a - b) <= err, axis=1))[0]
-
-        if ix.size == 1:
-            # known fluid properties
-            Memorise.T_ph[fl][ix, -1] += 1
-            return Memorise.T_ph[fl][ix, -2][0]
-
-    # unknown fluid properties
-    fluid = single_fluid(flow[3])
-    if fluid is None:
-        # calculate the fluid properties for fluid mixtures
-        valmin = max(
-            [Memorise.value_range[f][2] for f in fl if flow[3][f] > err]
-        ) + 0.1
-        if T0 < valmin or np.isnan(T0):
-            T0 = valmin * 1.1
-
-        val = newton(h_mix_pT, dh_mix_pdT, flow, flow[2], val0=T0,
-                     valmin=valmin, valmax=3000, imax=10)
-    else:
-        # calculate fluid property for pure fluids
-        val = T_ph(flow[1], flow[2], fluid)
-
-    if memorisation:
-        # memorise the newly calculated value
-        new = np.asarray(
-            [[flow[1], flow[2]] + list(flow[3].values()) + [val, 0]])
-        Memorise.T_ph[fl] = np.append(Memorise.T_ph[fl], new, axis=0)
-
-    return val
-
-
-def T_ph(p, h, fluid):
-    r"""
-    Calculate the temperature from pressure and enthalpy for a pure fluid.
-
-    Parameters
-    ----------
-    p : float
-        Pressure p / Pa.
-
-    h : float
-        Specific enthalpy h / (J/kg).
-
-    fluid : str
-        Fluid name.
-
-    Returns
-    -------
-    T : float
-        Temperature T / K.
-    """
-    if Memorise.back_end[fluid] == 'IF97':
-        return entropy_iteration_IF97(p, h, fluid, 'T')
-    else:
-        Memorise.state[fluid].update(CP.HmassP_INPUTS, h, p)
-        return Memorise.state[fluid].T()
-
-
-def dT_mix_dph(flow, T0=675):
-    r"""
-    Calculate partial derivate of temperature to pressure.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    Returns
-    -------
-    dT / dp : float
-        Partial derivative of temperature to pressure dT /dp / (K/Pa).
-
-        .. math::
-
-            \frac{\partial T_{mix}}{\partial p} = \frac{T_{mix}(p+d,h)-
-            T_{mix}(p-d,h)}{2 \cdot d}
-    """
-    d = 0.1
-    up = flow.copy()
-    lo = flow.copy()
-    up[1] += d
-    lo[1] -= d
-    return (T_mix_ph(up, T0=T0) - T_mix_ph(lo, T0=T0)) / (2 * d)
-
-
-def dT_mix_pdh(flow, T0=675):
-    r"""
-    Calculate partial derivate of temperature to enthalpy.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    Returns
-    -------
-    dT / dh : float
-        Partial derivative of temperature to enthalpy dT /dh / ((kgK)/J).
-
-        .. math::
-
-            \frac{\partial T_{mix}}{\partial h} = \frac{T_{mix}(p,h+d)-
-            T_{mix}(p,h-d)}{2 \cdot d}
-    """
-    d = 0.1
-    up = flow.copy()
-    lo = flow.copy()
-    up[2] += d
-    lo[2] -= d
-    return (T_mix_ph(up, T0=T0) - T_mix_ph(lo, T0=T0)) / (2 * d)
-
-
-def dT_mix_ph_dfluid(flow, T0=675):
-    r"""
-    Calculate partial derivate of temperature to fluid composition.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    Returns
-    -------
-    dT / dfluid : ndarray
-        Partial derivatives of temperature to fluid composition
-        dT / dfluid / K.
-
-        .. math::
-
-            \frac{\partial T_{mix}}{\partial fluid_{i}} =
-            \frac{T_{mix}(p,h,fluid_{i}+d)-
-            T_{mix}(p,h,fluid_{i}-d)}{2 \cdot d}
-    """
-    d = 1e-5
-    up = flow.copy()
-    lo = flow.copy()
-    vec_deriv = []
-    for fluid, x in flow[3].items():
-        if x > err:
-            up[3][fluid] += d
-            lo[3][fluid] -= d
-            vec_deriv += [
-                (T_mix_ph(up, T0=T0) - T_mix_ph(lo, T0=T0)) / (2 * d)]
-            up[3][fluid] -= d
-            lo[3][fluid] += d
-        else:
-            vec_deriv += [0]
-
-    return vec_deriv
-
-
-def T_mix_ps(flow, s, T0=675):
-    r"""
-    Calculate the temperature from pressure and entropy.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    s : float
-        Entropy of flow in J / (kgK).
-
-    Returns
-    -------
-    T : float
-        Temperature T / K.
-
-    Note
-    ----
-    First, check if fluid property has been memorised already.
-    If this is the case, return stored value, otherwise calculate value and
-    store it in the memorisation class.
-
-    Uses CoolProp interface for pure fluids, newton algorithm for mixtures:
-
-    .. math::
-
-        T_{mix}\left(p,s\right) = T_{i}\left(p,s_{i}\right)\;
-        \forall i \in \text{fluid components}\\
-
-        s_{i} = s \left(pp_{i}, T_{mix} \right)\\
-        pp: \text{partial pressure}
-
-    """
-    # check if fluid properties have been calculated before
-    fl = tuple(flow[3].keys())
-    memorisation = fl in Memorise.T_ps
-    if memorisation:
-        a = Memorise.T_ps[fl][:, :-2]
-        b = np.asarray([flow[1], flow[2]] + list(flow[3].values()) + [s])
-        ix = np.where(np.all(abs(a - b) <= err, axis=1))[0]
-        if ix.size == 1:
-            # known fluid properties
-            Memorise.T_ps[fl][ix, -1] += 1
-            return Memorise.T_ps[fl][ix, -2][0]
-
-    # unknown fluid properties
-    fluid = single_fluid(flow[3])
-    if fluid is None:
-        # calculate the fluid properties for fluid mixtures
-        valmin = max(
-            [Memorise.value_range[f][2] for f in fl if flow[3][f] > err]
-        ) + 0.1
-        if T0 < valmin or np.isnan(T0):
-            T0 = valmin * 1.1
-
-        val = newton(s_mix_pT, ds_mix_pdT, flow, s, val0=T0,
-                     valmin=valmin, valmax=3000, imax=10)
-
-    else:
-        # calculate fluid property for pure fluids
-        val = T_ps(flow[1], s, fluid)
-
-    if memorisation:
-        new = np.asarray(
-            [[flow[1], flow[2]] + list(flow[3].values()) + [s, val, 0]])
-        # memorise the newly calculated value
-        Memorise.T_ps[fl] = np.append(Memorise.T_ps[fl], new, axis=0)
-
-    return val
-
-
-def T_ps(p, s, fluid):
-    r"""
-    Calculate the temperature from pressure and entropy for a pure fluid.
-
-    Parameters
-    ----------
-    p : float
-       Pressure p / Pa.
-
-    s : float
-       Specific entropy h / (J/(kgK)).
-
-    fluid : str
-       Fluid name.
-
-    Returns
-    -------
-    T : float
-       Temperature T / K.
-    """
-    Memorise.state[fluid].update(CP.PSmass_INPUTS, p, s)
-    return Memorise.state[fluid].T()
-
-
-def h_mix_pT(flow, T, force_gas=False):
-    r"""
-    Calculate the enthalpy from pressure and Temperature.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    T : float
-        Temperature of flow T / K.
-
-    Returns
-    -------
-    h : float
-        Enthalpy h / (J/kg).
-
-    Note
-    ----
-    Calculation for fluid mixtures.
-
-    .. math::
-
-        h_{mix}(p,T)=\sum_{i} h(pp_{i},T,fluid_{i})\;
-        \forall i \in \text{fluid components}\\
-        pp: \text{partial pressure}
-    """
-    n = molar_mass_flow(flow[3])
-
-    h = 0
-    fluid_name = single_fluid(flow[3])
-    if fluid_name is None:
-
-        x_i = {
-            fluid: y / (molar_masses[fluid] * n)
-            for fluid, y in flow[3].items()
-        }
-
-        water = Memorise.water
-        if (water is not None and not force_gas and flow[3][water] > err):
-            y_i_gas, x_i_gas, y_water_liq, x_water_liq = (
-                cond_check(flow[3], x_i, flow[1], n, T)
-            )
-
-        else:
-            y_i_gas = flow[3]
-            y_water_liq = 0
-            x_i_gas = x_i
-
-        for fluid, y in y_i_gas.items():
-            if y > err:
-                if fluid == water and y_water_liq > 0:
-                    Memorise.state[fluid].update(CP.QT_INPUTS, 0, T)
-                    h += Memorise.state[fluid].hmass() * y_water_liq
-                    Memorise.state[fluid].update(CP.QT_INPUTS, 1, T)
-                    h += Memorise.state[fluid].hmass() * y * (1 - y_water_liq)
-
-                else:
-                    h += h_pT(
-                        flow[1] * x_i_gas[fluid], T, fluid, force_gas
-                    ) * y * (1 - y_water_liq)
-
-    else:
-        h = h_pT(flow[1], T, fluid_name, force_gas)
-
-    return h
-
-
-def h_pT(p, T, fluid, force_gas=False):
-    r"""
-    Calculate the enthalpy from pressure and temperature for a pure fluid.
-
-    Parameters
-    ----------
-    p : float
-        Pressure p / Pa.
-
-    T : float
-        Temperature T / K.
-
-    fluid : str
-        Fluid name.
-
-    Returns
-    -------
-    h : float
-        Specific enthalpy h / (J/kg).
-    """
-    if force_gas:
-        if T < get_T_crit(fluid):
-            Memorise.state[fluid].update(CP.PT_INPUTS, p, T)
-            h = Memorise.state[fluid].hmass()
-            Memorise.state[fluid].update(CP.QT_INPUTS, 1, T)
-            h_sat = Memorise.state[fluid].hmass()
-            return max(h, h_sat)
-
-    Memorise.state[fluid].update(CP.PT_INPUTS, p, T)
-    return Memorise.state[fluid].hmass()
-
-
-def dh_mix_pdT(flow, T):
-    r"""
-    Calculate partial derivate of enthalpy to temperature.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    T : float
-        Temperature T / K.
-
-    Returns
-    -------
-    dh / dT : float
-        Partial derivative of enthalpy to temperature dh / dT / (J/(kgK)).
-
-        .. math::
-
-            \frac{\partial h_{mix}}{\partial T} =
-            \frac{h_{mix}(p,T+d)-h_{mix}(p,T-d)}{2 \cdot d}
-    """
-    d = 0.01
-    return (h_mix_pT(flow, T + d) - h_mix_pT(flow, T - d)) / (2 * d)
-
-
-def h_mix_ps(flow, s, T0=675):
-    r"""
-    Calculate the enthalpy from pressure and temperature.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    s : float
-        Specific entropy of flow s / (J/(kgK)).
-
-    Returns
-    -------
-    h : float
-        Specific enthalpy h / (J/kg).
-
-    Note
-    ----
-    Calculation for fluid mixtures.
-
-    .. math::
-
-        h_{mix}\left(p,s\right)=h\left(p, T_{mix}\left(p,s\right)\right)
-    """
-    return h_mix_pT(flow, T_mix_ps(flow, s, T0=T0))
-
-
-def h_ps(p, s, fluid):
-    r"""
-    Calculate the enthalpy from pressure and entropy for a pure fluid.
-
-    Parameters
-    ----------
-    p : float
-        Pressure p / Pa.
-
-    s : float
-        Specific entropy h / (J/(kgK)).
-
-    fluid : str
-        Fluid name.
-
-    Returns
-    -------
-    h : float
-        Specific enthalpy h / (J/kg).
-    """
-    Memorise.state[fluid].update(CP.PSmass_INPUTS, p, s)
-    return Memorise.state[fluid].hmass()
-
-
-def h_ps_IF97(params, s):
-    r"""
-    Calculate the enthalpy from pressure and entropy for IF97 backend.
-
-    Parameters
-    ----------
-    fluid : str
-        Fluid name.
-
-    p : float
-        Pressure p / Pa.
-
-    s : float
-        Specific entropy h / (J/(kgK)).
-
-    Returns
-    -------
-    h : float
-        Specific enthalpy h / (J/kg).
-    """
-    Memorise.state[params[0]].update(CP.PSmass_INPUTS, params[1], s)
-    return Memorise.state[params[0]].hmass()
-
-
-def dh_pds_IF97(params, s):
-    r"""
-    Calculate the derivative of enthalpy to entropy at constant pressure.
-
-    For pure fluids only, required for IF97 entropy iteration only.
-
-    Parameters
-    ----------
-    p : float
-        Pressure p / Pa.
-
-    s : float
-        Specific entropy h / (J/(kgK)).
-
-    fluid : str
-        Fluid name.
-
-    Returns
-    -------
-    dh : float
-        Derivative of specific enthalpy dh / ds / K.
-    """
-    d = 1e-2
-    Memorise.state[params[0]].update(CP.PSmass_INPUTS, params[1], s + d)
-    h_upper = Memorise.state[params[0]].hmass()
-
-    Memorise.state[params[0]].update(CP.PSmass_INPUTS, params[1], s - d)
-    h_lower = Memorise.state[params[0]].hmass()
-
-    return (h_upper - h_lower) / (2 * d)
-
-
-def h_mix_pQ(flow, Q):
-    r"""
-    Calculate the enthalpy from pressure and vapour mass fraction.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    Q : float
-        Vapour mass fraction Q / 1.
-
-    Returns
-    -------
-    h : float
-        Specific enthalpy h / (J/kg).
-
-    Note
-    ----
-    This function works for pure fluids only!
-    """
-    fluid = single_fluid(flow[3])
-    if fluid is None:
-        if sum(flow[3].values()) == 0:
-            msg = 'The function h_mix_pQ is called without fluid information.'
-            logging.error(msg)
-            raise ValueError(msg)
-        else:
-            msg = 'The function h_mix_pQ can only be used for pure fluids.'
-            logging.error(msg)
-            raise ValueError(msg)
-
-    try:
-        Memorise.state[fluid].update(CP.PQ_INPUTS, flow[1], Q)
-    except ValueError:
-        p_crit = get_p_crit(fluid)
-        Memorise.state[fluid].update(CP.PQ_INPUTS, p_crit * 0.99, Q)
-
-    return Memorise.state[fluid].hmass()
-
-
-def dh_mix_dpQ(flow, Q):
-    r"""
-    Calculate partial derivate of enthalpy to vapour mass fraction.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    Q : float
-        Vapour mass fraction Q / 1.
-
-    Returns
-    -------
-    dh / dQ : float
-        Partial derivative of enthalpy to vapour mass fraction
-        dh / dQ / (J/kg).
-
-        .. math::
-
-            \frac{\partial h_{mix}}{\partial p} =
-            \frac{h_{mix}(p+d,Q)-h_{mix}(p-d,Q)}{2 \cdot d}\\
-            Q: \text{vapour mass fraction}
-
-    Note
-    ----
-    This works for pure fluids only!
-    """
-    d = 0.1
-    up = flow.copy()
-    lo = flow.copy()
-    up[1] += d
-    lo[1] -= d
-    return (h_mix_pQ(up, Q) - h_mix_pQ(lo, Q)) / (2 * d)
-
-
-def get_p_crit(fluid):
-    """
-    Get critical point pressure.
-
-    Parameters
-    ----------
-    fluid : str
-        Fluid name.
-
-    Returns
-    -------
-    p_crit : float
-        Critical point pressure.
-    """
-    return Memorise.state[fluid].trivial_keyed_output(CP.iP_critical)
-
-
-def get_T_crit(fluid):
-    """
-    Get critical point temperature.
-
-    Parameters
-    ----------
-    fluid : str
-        Fluid name.
-
-    Returns
-    -------
-    T_crit : float
-        Critical point temperature.
-    """
-    return Memorise.state[fluid].trivial_keyed_output(CP.iT_critical)
-
-
-def T_bp_p(flow):
-    r"""
-    Calculate temperature from boiling point pressure.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    Returns
-    -------
-    T : float
-        Temperature at boiling point.
-
-    Note
-    ----
-    This function works for pure fluids only!
-    """
-    fluid = single_fluid(flow[3])
-    p_crit = get_p_crit(fluid)
-    if flow[1] > p_crit:
-        Memorise.state[fluid].update(CP.PQ_INPUTS, p_crit * 0.99, 1)
-    else:
-        Memorise.state[fluid].update(CP.PQ_INPUTS, flow[1], 1)
-    return Memorise.state[fluid].T()
-
-
-def dT_bp_dp(flow):
-    r"""
-    Calculate partial derivate of temperature to boiling point pressure.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    Returns
-    -------
-    dT / dp : float
-        Partial derivative of temperature to boiling point pressure in K / Pa.
-
-        .. math::
-
-            \frac{\partial h_{mix}}{\partial p} =
-            \frac{T_{bp}(p+d)-T_{bp}(p-d)}{2 \cdot d}\\
-            Q: \text{vapour mass fraction}
-
-    Note
-    ----
-    This works for pure fluids only!
-    """
-    d = 0.1
-    up = flow.copy()
-    lo = flow.copy()
-    up[1] += d
-    lo[1] -= d
-    return (T_bp_p(up) - T_bp_p(lo)) / (2 * d)
-
-
-def cond_check(y_i, x_i, p, n, T):
-    """_summary_
-
-    Parameters
-    ----------
-    y_i : dict
-        Mass specific fluid composition.
-    x_i : dict
-        Mole specific fluid composition.
-    p : float
-        Pressure of mass flow.
-    n : float
-        Molar mass flow.
-    T : float
-        Temperatrure of mass flow.
-
-    Returns
-    -------
-    tuple
-        Tuple containing gasphase mass specific and molar specific compositions
-        and overall liquid water mass fraction.
-    """
-    x_i_gas = x_i.copy()
-    y_i_gas = y_i.copy()
-    y_water_liq = 0
-    x_water_liq = 0
-    water_label = Memorise.water
-
-    if T < get_T_crit(water_label):
-        Memorise.state[water_label].update(CP.QT_INPUTS, 1, T)
-        p_sat = Memorise.state[water_label].p()
-
-        pp_water = p * y_i[water_label] / (
-            molar_masses[water_label] * n
-        )
-
-        if p_sat < pp_water:
-            x_water_gas = (1 - x_i[water_label]) / (p / p_sat - 1)
-            x_water_liq = x_i[water_label] - x_water_gas
-            x_gas_sum = 1 - x_water_liq
-
-            x_i_gas = {f: x / x_gas_sum for f, x in x_i.items()}
-            x_i_gas[water_label] = x_water_gas / x_gas_sum
-
-            y_water_liq = x_water_liq * molar_masses[water_label] / (
-                sum([
-                    x * molar_masses[fluid]
-                    for fluid, x in x_i.items()
-                ])
-            )
-
-            M = sum([x * molar_masses[fluid] for fluid, x in x_i_gas.items()])
-            y_i_gas = {
-                fluid: x / M * molar_masses[fluid]
-                for fluid, x in x_i_gas.items()
-            }
-
-    return y_i_gas, x_i_gas, y_water_liq, x_water_liq
-
-
-def v_mix_ph(flow, T0=675):
-    r"""
-    Calculate the specific volume from pressure and enthalpy.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    Returns
-    -------
-    v : float
-        Specific volume v / (:math:`\mathrm{m}^3`/kg).
-
-    Note
-    ----
-    First, check if fluid property has been memorised already.
-    If this is the case, return stored value, otherwise calculate value and
-    store it in the memorisation class.
-
-    Uses CoolProp interface for pure fluids, newton algorithm for mixtures:
-
-    .. math::
-
-        v_{mix}\left(p,h\right) = v\left(p,T_{mix}(p,h)\right)
-    """
-    # check if fluid properties have been calculated before
-    fl = tuple(flow[3].keys())
-    memorisation = fl in Memorise.v_ph
-    if memorisation:
-        a = Memorise.v_ph[fl][:, :-2]
-        b = np.asarray([flow[1], flow[2]] + list(flow[3].values()))
-        ix = np.where(np.all(abs(a - b) <= err, axis=1))[0]
-        if ix.size == 1:
-            # known fluid properties
-            Memorise.v_ph[fl][ix, -1] += 1
-            return Memorise.v_ph[fl][ix, -2][0]
-
-    # unknown fluid properties
-    fluid = single_fluid(flow[3])
-    if fluid is None:
-        # calculate the fluid properties for fluid mixtures
-        val = v_mix_pT(flow, T_mix_ph(flow, T0=T0))
-    else:
-        # calculate fluid property for pure fluids
-        val = 1 / d_ph(flow[1], flow[2], fluid)
-
-    if memorisation:
-        # memorise the newly calculated value
-        new = np.asarray(
-            [[flow[1], flow[2]] + list(flow[3].values()) + [val, 0]])
-        Memorise.v_ph[fl] = np.append(Memorise.v_ph[fl], new, axis=0)
-
-    return val
-
-
-def d_ph(p, h, fluid):
-    r"""
-    Calculate the density from pressure and enthalpy for a pure fluid.
-
-    Parameters
-    ----------
-    p : float
-        Pressure p / Pa.
-
-    h : float
-        Specific enthalpy h / (J/kg).
-
-    fluid : str
-        Fluid name.
-
-    Returns
-    -------
-    d : float
-        Density d / (kg/:math:`\mathrm{m}^3`).
-    """
-    if Memorise.back_end[fluid] == 'IF97':
-        return entropy_iteration_IF97(p, h, fluid, 'rho')
-    else:
-        Memorise.state[fluid].update(CP.HmassP_INPUTS, h, p)
-        return Memorise.state[fluid].rhomass()
-
-
-def Q_ph(p, h, fluid):
-    r"""
-    Calculate vapor mass fraction from pressure and enthalpy for a pure fluid.
-
-    Parameters
-    ----------
-    p : float
-        Pressure p / Pa.
-
-    h : float
-        Specific enthalpy h / (J/kg).
-
-    fluid : str
-        Fluid name.
-
-    Returns
-    -------
-    x : float
-        Vapor mass fraction.
-    """
-    try:
-        Memorise.state[fluid].update(CP.HmassP_INPUTS, h, p)
-        return Memorise.state[fluid].Q()
-    except (KeyError, ValueError, AttributeError):
-        return np.nan
-
-
-def dv_mix_dph(flow, T0=675):
-    r"""
-    Calculate partial derivate of specific volume to pressure.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    Returns
-    -------
-    dv / dp : float
-        Partial derivative of specific volume to pressure
-        dv /dp / (:math:`\mathrm{m}^3`/(Pa kg)).
-
-        .. math::
-
-            \frac{\partial v_{mix}}{\partial p} = \frac{v_{mix}(p+d,h)-
-            v_{mix}(p-d,h)}{2 \cdot d}
-    """
-    d = 0.1
-    up = flow.copy()
-    lo = flow.copy()
-    up[1] += d
-    lo[1] -= d
-    return (v_mix_ph(up, T0=T0) - v_mix_ph(lo, T0=T0)) / (2 * d)
-
-
-def dv_mix_pdh(flow, T0=675):
-    r"""
-    Calculate partial derivate of specific volume to enthalpy.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    Returns
-    -------
-    dv / dh : float
-        Partial derivative of specific volume to enthalpy
-        dv /dh / (:math:`\mathrm{m}^3`/J).
-
-        .. math::
-
-            \frac{\partial v_{mix}}{\partial h} = \frac{v_{mix}(p,h+d)-
-            v_{mix}(p,h-d)}{2 \cdot d}
-    """
-    d = 0.1
-    up = flow.copy()
-    lo = flow.copy()
-    up[2] += d
-    lo[2] -= d
-    return (v_mix_ph(up, T0=T0) - v_mix_ph(lo, T0=T0)) / (2 * d)
-
-
-def v_mix_pT(flow, T):
-    r"""
-    Calculate the specific volume from pressure and temperature.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    T : float
-        Temperature T / K.
-
-    Returns
-    -------
-    v : float
-        Specific volume v / (:math:`\mathrm{m}^3`/kg).
-
-    Note
-    ----
-    Calculation for fluid mixtures.
-
-    .. math::
-
-        v_{mix}(p,T)=\frac{1}{\sum_{i} \rho(pp_{i}, T, fluid_{i})}\;
-        \forall i \in \text{fluid components}\\
-        pp: \text{partial pressure}
-    """
-    n = molar_mass_flow(flow[3])
-
-    d = 0
-    for fluid, x in flow[3].items():
-        if x > err:
-            ni = x / molar_masses[fluid]
-            d += d_pT(flow[1] * ni / n, T, fluid)
-
-    return 1 / d
-
-
-def d_mix_pT(flow, T):
-    r"""
-    Calculate the density from pressure and temperature.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    T : float
-        Temperature T / K.
-
-    Returns
-    -------
-    d : float
-        Density d / (kg/:math:`\mathrm{m}^3`).
-
-    Note
-    ----
-    Calculation for fluid mixtures.
-
-    .. math::
-
-        \rho_{mix}\left(p,T\right)=\frac{1}{v_{mix}\left(p,T\right)}
-    """
-    return 1 / v_mix_pT(flow, T)
-
-
-def d_pT(p, T, fluid):
-    r"""
-    Calculate the density from pressure and temperature for a pure fluid.
-
-    Parameters
-    ----------
-    p : float
-        Pressure p / Pa.
-
-    T : float
-        Temperature T / K.
-
-    fluid : str
-        Fluid name.
-
-    Returns
-    -------
-    d : float
-        Density d / (kg/:math:`\mathrm{m}^3`).
-    """
-    Memorise.state[fluid].update(CP.PT_INPUTS, p, T)
-    return Memorise.state[fluid].rhomass()
-
-
-def visc_mix_ph(flow, T0=675):
-    r"""
-    Calculate the dynamic viscorsity from pressure and enthalpy.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    Returns
-    -------
-    visc : float
-        Dynamic viscosity visc / Pa s.
-
-    Note
-    ----
-    First, check if fluid property has been memorised already.
-    If this is the case, return stored value, otherwise calculate value and
-    store it in the memorisation class.
-
-    Uses CoolProp interface for pure fluids, newton algorithm for mixtures:
-
-    .. math::
-
-        \eta_{mix}\left(p,h\right) = \eta\left(p,T_{mix}(p,h)\right)
-    """
-    # check if fluid properties have been calculated before
-    fl = tuple(flow[3].keys())
-    memorisation = fl in Memorise.visc_ph
-    if memorisation:
-        a = Memorise.visc_ph[fl][:, :-2]
-        b = np.asarray([flow[1], flow[2]] + list(flow[3].values()))
-        ix = np.where(np.all(abs(a - b) <= err, axis=1))[0]
-        if ix.size == 1:
-            # known fluid properties
-            Memorise.visc_ph[fl][ix, -1] += 1
-            return Memorise.visc_ph[fl][ix, -2][0]
-
-    # unknown fluid properties
-    fluid = single_fluid(flow[3])
-    if fluid is None:
-        # calculate the fluid properties for fluid mixtures
-        val = visc_mix_pT(flow, T_mix_ph(flow, T0=T0))
-    else:
-        # calculate the fluid properties for pure fluids
-        val = visc_ph(flow[1], flow[2], fluid)
-
-    if memorisation:
-        # memorise the newly calculated value
-        new = np.asarray(
-            [[flow[1], flow[2]] + list(flow[3].values()) + [val, 0]])
-        Memorise.visc_ph[fl] = np.append(Memorise.visc_ph[fl], new, axis=0)
-    return val
-
-
-def visc_ph(p, h, fluid):
-    r"""
-    Calculate dynamic viscosity from pressure and enthalpy for a pure fluid.
-
-    Parameters
-    ----------
-    p : float
-        Pressure p / Pa.
-
-    h : float
-        Specific enthalpy h / (J/kg).
-
-    fluid : str
-        Fluid name.
-
-    Returns
-    -------
-    visc : float
-        Viscosity visc / Pa s.
-    """
-    if Memorise.back_end[fluid] == 'IF97':
-        return entropy_iteration_IF97(p, h, fluid, 'visc')
-    else:
-        Memorise.state[fluid].update(CP.HmassP_INPUTS, h, p)
-        return Memorise.state[fluid].viscosity()
-
-
-def visc_mix_pT(flow, T):
-    r"""
-    Calculate dynamic viscosity from pressure and temperature.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    T : float
-        Temperature T / K.
-
-    Returns
-    -------
-    visc : float
-        Dynamic viscosity visc / Pa s.
-
-    Note
-    ----
-    Calculation for fluid mixtures.
-
-    .. math::
-
-        \eta_{mix}(p,T)=\frac{\sum_{i} \left( \eta(p,T,fluid_{i}) \cdot y_{i}
-        \cdot \sqrt{M_{i}} \right)}
-        {\sum_{i} \left(y_{i} \cdot \sqrt{M_{i}} \right)}\;
-        \forall i \in \text{fluid components}\\
-        y: \text{volume fraction}\\
-        M: \text{molar mass}
-
-    Reference: :cite:`Herning1936`.
-    """
-    n = molar_mass_flow(flow[3])
-
-    a = 0
-    b = 0
-    for fluid, x in flow[3].items():
-        if x > err:
-            bi = x * np.sqrt(molar_masses[fluid]) / (molar_masses[fluid] * n)
-            b += bi
-            a += bi * visc_pT(flow[1], T, fluid)
-
-    return a / b
-
-
-def visc_pT(p, T, fluid):
-    r"""
-    Calculate dynamic viscosity from pressure and temperature for a pure fluid.
-
-    Parameters
-    ----------
-    p : float
-        Pressure p / Pa.
-
-    T : float
-        Temperature T / K.
-
-    fluid : str
-        Fluid name.
-
-    Returns
-    -------
-    visc : float
-        Viscosity visc / Pa s.
-    """
-    Memorise.state[fluid].update(CP.PT_INPUTS, p, T)
-    return Memorise.state[fluid].viscosity()
-
-
-def s_mix_ph(flow, T0=675):
-    r"""
-    Calculate the entropy from pressure and enthalpy.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    Returns
-    -------
-    s : float
-        Specific entropy s / (J/(kgK)).
-
-    Note
-    ----
-    First, check if fluid property has been memorised already.
-    If this is the case, return stored value, otherwise calculate value and
-    store it in the memorisation class.
-
-    Uses CoolProp interface for pure fluids, newton algorithm for mixtures:
-
-    .. math::
-
-        s_{mix}\left(p,h\right) = s\left(p,T_{mix}(p,h)\right)
-    """
-    # check if fluid properties have been calculated before
-    fl = tuple(flow[3].keys())
-    memorisation = fl in Memorise.s_ph
-    if memorisation:
-        a = Memorise.s_ph[fl][:, :-2]
-        b = np.asarray([flow[1], flow[2]] + list(flow[3].values()))
-        ix = np.where(np.all(abs(a - b) <= err, axis=1))[0]
-        if ix.size == 1:
-            # known fluid properties
-            Memorise.s_ph[fl][ix, -1] += 1
-            return Memorise.s_ph[fl][ix, -2][0]
-
-    # unknown fluid properties
-    fluid = single_fluid(flow[3])
-    if fluid is None:
-        # calculate the fluid properties for fluid mixtures
-        val = s_mix_pT(flow, T_mix_ph(flow, T0=T0))
-    else:
-        # calculate fluid property for pure fluids
-        val = s_ph(flow[1], flow[2], fluid)
-
-    if memorisation:
-        # memorise the newly calculated value
-        new = np.asarray(
-            [[flow[1], flow[2]] + list(flow[3].values()) + [val, 0]])
-        Memorise.s_ph[fl] = np.append(Memorise.s_ph[fl], new, axis=0)
-
-    return val
-
-
-def s_ph(p, h, fluid):
-    r"""
-    Calculate the entropy from pressure and enthalpy for a pure fluid.
-
-    Parameters
-    ----------
-    p : float
-        Pressure p / Pa.
-
-    h : float
-        Specific enthalpy h / (J/kg).
-
-    fluid : str
-        Fluid name.
-
-    Returns
-    -------
-    s : float
-        Specific entropy s / (J/(kgK)).
-    """
-    if Memorise.back_end[fluid] == 'IF97':
-        return entropy_iteration_IF97(p, h, fluid, 's')
-    else:
-        Memorise.state[fluid].update(CP.HmassP_INPUTS, h, p)
-        return Memorise.state[fluid].smass()
-
-
-def s_mix_pT(flow, T, force_gas=False):
-    r"""
-    Calculate the entropy from pressure and temperature.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    T : float
-        Temperature T / K.
-
-    Returns
-    -------
-    s : float
-        Specific entropy s / (J/(kgK)).
-
-    Note
-    ----
-    Calculation for fluid mixtures.
-
-    .. math::
-
-        s_{mix}(p,T)=\sum_{i} x_{i} \cdot s(pp_{i},T,fluid_{i})-
-        \sum_{i} x_{i} \cdot R_{i} \cdot \ln \frac{pp_{i}}{p}\;
-        \forall i \in \text{fluid components}\\
-        pp: \text{partial pressure}\\
-        R: \text{gas constant}
-    """
-    n = molar_mass_flow(flow[3])
-    s = 0
-
-    fluid_name = single_fluid(flow[3])
-    if fluid_name is None:
-
-        x_i = {
-            fluid: y / (molar_masses[fluid] * n)
-            for fluid, y in flow[3].items()
-        }
-
-        water = Memorise.water
-        if (water is not None and not force_gas and flow[3][water] > err):
-            y_i_gas, x_i_gas, y_water_liq, x_water_liq = (
-                cond_check(flow[3], x_i, flow[1], n, T)
-            )
-
-        else:
-            y_i_gas = flow[3]
-            y_water_liq = 0
-            x_i_gas = x_i
-
-        for fluid, y in y_i_gas.items():
-            if y > err:
-                if fluid == water and y_water_liq > 0:
-                    Memorise.state[water].update(CP.QT_INPUTS, 1, T)
-                    s += Memorise.state[water].smass() * y * (
-                        1 - y_water_liq
-                    )
-                    Memorise.state[water].update(CP.QT_INPUTS, 0, T)
-                    s += Memorise.state[water].smass() * y_water_liq
-
-                else:
-                    pp = flow[1] * x_i_gas[fluid]
-                    s += y * (1 - y_water_liq) * s_pT(pp, T, fluid, force_gas)
-
-    else:
-        s = s_pT(flow[1], T, fluid_name, force_gas)
-
-    return s
-
-
-def s_pT(p, T, fluid, force_gas):
-    r"""
-    Calculate the entropy from pressure and temperature for a pure fluid.
-
-    Parameters
-    ----------
-    p : float
-        Pressure p / Pa.
-
-    T : float
-        Temperature T / K.
-
-    fluid : str
-        Fluid name.
-
-    Returns
-    -------
-    s : float
-        Specific entropy s / (J/(kgK)).
-    """
-    if force_gas:
-        if T < get_T_crit(fluid):
-            Memorise.state[fluid].update(CP.PT_INPUTS, p, T)
-            s = Memorise.state[fluid].smass()
-            Memorise.state[fluid].update(CP.QT_INPUTS, 1, T)
-            s_sat = Memorise.state[fluid].smass()
-            return max(s, s_sat)
-
-    Memorise.state[fluid].update(CP.PT_INPUTS, p, T)
-    return Memorise.state[fluid].smass()
-
-
-def ds_mix_pdT(flow, T):
-    r"""
-    Calculate partial derivate of entropy to temperature.
-
-    Parameters
-    ----------
-    flow : list
-        Fluid property vector containing mass flow, pressure, enthalpy and
-        fluid composition.
-
-    T : float
-        Temperature T / K.
-
-    Returns
-    -------
-    ds / dT : float
-        Partial derivative of specific entropy to temperature
-        ds / dT / (J/(kg :math:`\mathrm{K}^2`)).
-
-        .. math::
-
-            \frac{\partial s_{mix}}{\partial T} =
-            \frac{s_{mix}(p,T+d)-s_{mix}(p,T-d)}{2 \cdot d}
-    """
-    d = 0.01
-    return (s_mix_pT(flow, T + d) - s_mix_pT(flow, T - d)) / (2 * d)
-
-
-def isentropic(inflow, outflow, T0=675):
-    r"""
-    Calculate the enthalpy at the outlet after isentropic process.
-
-    Parameters
-    ----------
-    inflow : list
-        Inflow fluid property vector containing mass flow, pressure, enthalpy
-        and fluid composition.
-
-    outflow : list
-        Outflow fluid property vector containing mass flow, pressure, enthalpy
-        and fluid composition.
-
-    Returns
-    -------
-    h_s : float
-        Enthalpy after isentropic state change.
-
-        .. math::
-
-            h_\mathrm{s} = \begin{cases}
-            h\left(p_{out}, s\left(p_{in}, h_{in}\right) \right) &
-            \text{pure fluids}\\
-            h\left(p_{out}, s\left(p_{in}, T_{in}\right) \right) &
-            \text{mixtures}\\
-            \end{cases}
-    """
-    fluid = single_fluid(inflow[3])
-    if fluid is not None:
-        return h_ps(outflow[1], s_ph(inflow[1], inflow[2], fluid), fluid)
-    else:
-        s_mix = s_mix_ph(inflow)
-        return h_mix_ps(outflow, s_mix, T0=T0)
-
-
-def calc_physical_exergy(conn, p0, T0):
-    r"""
-    Calculate specific physical exergy.
-
-    Physical exergy is allocated to a thermal and a mechanical share according
-    to :cite:`Morosuk2019`.
-
-    Parameters
-    ----------
-    conn : tespy.connections.connection.Connection
-        Connection to calculate specific physical exergy for.
-
-    p0 : float
-        Ambient pressure p0 / Pa.
-
-    T0 : float
-        Ambient temperature T0 / K.
-
-    Returns
-    -------
-    e_ph : tuple
-        Specific thermal and mechanical exergy
-        (:math:`e^\mathrm{T}`, :math:`e^\mathrm{M}`) in J / kg.
-
-        .. math::
-
-            e^\mathrm{T} = \left( h - h \left( p, T_0 \right) \right) -
-            T_0 \cdot \left(s - s\left(p, T_0\right)\right)
-
-            e^\mathrm{M}=\left(h\left(p,T_0\right)-h\left(p_0,T_0\right)\right)
-            -T_0\cdot\left(s\left(p, T_0\right)-s\left(p_0,T_0\right)\right)
-
-            e^\mathrm{PH} = e^\mathrm{T} + e^\mathrm{M}
-    """
-    h_T0_p = h_mix_pT([0, conn.p.val_SI, 0, conn.fluid.val], T0)
-    s_T0_p = s_mix_pT([0, conn.p.val_SI, 0, conn.fluid.val], T0)
-    ex_therm = (conn.h.val_SI - h_T0_p) - T0 * (conn.s.val_SI - s_T0_p)
-    h0 = h_mix_pT([0, p0, 0, conn.fluid.val], T0)
-    s0 = s_mix_pT([0, p0, 0, conn.fluid.val], T0)
-    ex_mech = (h_T0_p - h0) - T0 * (s_T0_p - s0)
-    return ex_therm, ex_mech
-
-
-def entropy_iteration_IF97(p, h, fluid, output):
-    r"""
-    Calculate state in IF97 back-end via entropy iteration.
-
-    Parameters
-    ----------
-    p : float
-        Pressure p / Pa.
-
-    h : float
-        Specific enthalpy h / (J/kg).
-
-    fluid : str
-        Fluid name.
-
-    Returns
-    -------
-    T : float
-        Temperature T / K.
-    """
-    # region 1 exclusive issue!
-    Memorise.state[fluid].update(CP.HmassP_INPUTS, h, p)
-    if p <= 16.529164252605 * 1e6:
-        h_at_ph = Memorise.state[fluid].hmass()
-        deviation = abs(h_at_ph - h)
-        if deviation / h > 0.001:
-            # region 1, where isenthalpic lines are tangent to saturation dome
-            if p > 1e6 and p < 1e7 and h > 2700000 and h < 2850000:
-                smin = 5750
-                smax = 6500
-            # bottom left corner in Ts diagram
-            elif h < 10000:
-                smin = 0
-                smax = 50
-            else:
-                # proximity to saturated liquid
-                Memorise.state[fluid].update(CP.PQ_INPUTS, p, 0)
-                h_sat_l = Memorise.state[fluid].hmass()
-                if abs(h - h_sat_l) / h_sat_l < 1e-1:
-                    if p < 1000:
-                        smin = 0
-                    elif p < 60000:
-                        smin = Memorise.state[fluid].smass() * 0.9
-                    else:
-                        smin = Memorise.state[fluid].smass() * 0.95
-
-                    Memorise.state[fluid].update(CP.PQ_INPUTS, p, 0.3)
-                    smax = Memorise.state[fluid].smass()
-                # all others
-                else:
-                    Memorise.state[fluid].update(CP.HmassP_INPUTS, h, p)
-                    s0 = Memorise.state[fluid].smass()
-                    smin = 0.8 * s0
-                    smax = 1.2 * s0
-
-            s0 = (smax + smin) / 2
-            s = newton(func=h_ps_IF97, deriv=dh_pds_IF97, params=[fluid, p],
-                       y=h, val0=s0, valmin=smin, valmax=smax, max_iter=5,
-                       tol_rel=1e-3, tol_mode='rel')
-            Memorise.state[fluid].update(CP.PSmass_INPUTS, p, s)
-
-    if output == 'T':
-        return Memorise.state[fluid].T()
-    elif output == 's':
-        return Memorise.state[fluid].smass()
-    elif output == 'rho':
-        return Memorise.state[fluid].rhomass()
-    else:
-        return Memorise.state[fluid].viscosity()
+# -*- coding: utf-8
+
+"""Module for fluid property integration.
+
+TESPy uses the CoolProp python interface for all fluid property functions.
+
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location tespy/tools/fluid_properties.py
+
+SPDX-License-Identifier: MIT
+"""
+
+import CoolProp as CP
+import numpy as np
+from CoolProp.CoolProp import PropsSI as CPPSI
+from CoolProp.CoolProp import get_aliases
+
+from tespy.tools import logger
+from tespy.tools.global_vars import err
+from tespy.tools.global_vars import gas_constants
+from tespy.tools.global_vars import molar_masses
+from tespy.tools.helpers import molar_mass_flow
+from tespy.tools.helpers import newton
+from tespy.tools.helpers import single_fluid
+
+
+class Memorise:
+    r"""Memorization of fluid properties."""
+
+    @staticmethod
+    def add_fluids(fluids, memorise_fluid_properties=True):
+        r"""
+        Add list of fluids to fluid memorisation class.
+
+        - Generate arrays for fluid property lookup if memorisation is
+          activated.
+        - Calculate/set fluid property value ranges for convergence checks.
+
+        Parameters
+        ----------
+        fluids : dict
+            Dict of fluid and corresponding CoolProp back end for fluid
+            property memorization.
+
+        memorise_fluid_properties : boolean
+            Activate or deactivate fluid property value memorisation. Default
+            state is activated (:code:`True`).
+
+        Note
+        ----
+        The Memorise class creates globally accessible variables for different
+        fluid property calls as dictionaries:
+
+        - T(p,h)
+        - T(p,s)
+        - v(p,h)
+        - visc(p,h)
+        - s(p,h)
+
+        Each dictionary uses the list of fluids passed to the Memorise class as
+        identifier for the fluid property memorisation. The fluid properties
+        are stored as numpy array, where each column represents the mass
+        fraction of the respective fluid and the additional columns are the
+        values for the fluid properties. The fluid property function will then
+        look for identical fluid property inputs (p, h, (s), fluid mass
+        fraction). If the inputs are in the array, the first column of that row
+        is returned, see example.
+
+        Example
+        -------
+        T(p,h) for set of fluids ('water', 'air'):
+
+        - row 1: [282.64527752319697, 10000, 40000, 1, 0]
+        - row 2: [284.3140698256616, 10000, 47000, 1, 0]
+        """
+        # number of fluids
+        num_fl = len(fluids)
+        if memorise_fluid_properties and num_fl > 0:
+            fl = tuple(fluids.keys())
+            # fluid property tables
+            Memorise.T_ph[fl] = np.empty((0, num_fl + 4), float)
+            Memorise.T_ps[fl] = np.empty((0, num_fl + 5), float)
+            Memorise.v_ph[fl] = np.empty((0, num_fl + 4), float)
+            Memorise.visc_ph[fl] = np.empty((0, num_fl + 4), float)
+            Memorise.s_ph[fl] = np.empty((0, num_fl + 4), float)
+
+            msg = (
+                'Added fluids ' + ', '.join(fl) +
+                ' to memorise lookup tables.')
+            logger.debug(msg)
+
+        Memorise.water = None
+        for f, back_end in fluids.items():
+
+            # save name for water in memorise
+            if f in get_aliases("H2O"):
+                Memorise.water = f
+
+            if f in Memorise.state:
+                del Memorise.state[f]
+
+            # create CoolProp.AbstractState object
+            try:
+                Memorise.state[f] = CP.AbstractState(back_end, f)
+                Memorise.back_end[f] = back_end
+            except ValueError:
+                msg = (
+                    'Could not find the fluid "' + f + '" in the fluid '
+                    'property database.'
+                )
+                logger.warning(msg)
+                continue
+
+            msg = (
+                'Created CoolProp.AbstractState object for fluid ' +
+                f + ' with back end ' + back_end + '.')
+            logger.debug(msg)
+            # pressure range
+            try:
+                pmin = Memorise.state[f].trivial_keyed_output(CP.iP_min)
+                pmax = Memorise.state[f].trivial_keyed_output(CP.iP_max)
+            except ValueError:
+                pmin = 1e4
+                pmax = 1e8
+                msg = (
+                    'Could not find values for maximum and minimum '
+                    'pressure.')
+                logger.warning(msg)
+
+            # temperature range
+            Tmin = Memorise.state[f].trivial_keyed_output(CP.iT_min)
+            Tmax = Memorise.state[f].trivial_keyed_output(CP.iT_max)
+
+            # value range for fluid properties
+            Memorise.value_range[f] = [pmin, pmax, Tmin, Tmax]
+
+            try:
+                molar_masses[f] = Memorise.state[f].molar_mass()
+                gas_constants[f] = Memorise.state[f].gas_constant()
+            except ValueError:
+                try:
+                    molar_masses[f] = CPPSI('M', f)
+                    gas_constants[f] = CPPSI('GAS_CONSTANT', f)
+                except ValueError:
+                    molar_masses[f] = 1
+                    gas_constants[f] = 1
+                    msg = (
+                        'Could not find values for molar mass and gas '
+                        'constant.')
+                    logger.warning(msg)
+
+            msg = (
+                'Specifying fluid property ranges for pressure and '
+                'temperature for convergence check of fluid ' + f + '.')
+            logger.debug(msg)
+
+    @staticmethod
+    def del_memory(fluids):
+        r"""
+        Delete non frequently used fluid property values from memorise class.
+
+        Parameters
+        ----------
+        fluids : list
+            List of fluid for fluid property memorization.
+        """
+        fl = tuple(fluids)
+        threshold = 3
+        try:
+            # delete memory
+            Memorise.s_ph[fl] = Memorise.s_ph[fl][
+                Memorise.s_ph[fl][:, -1] > threshold]
+            Memorise.s_ph[fl][:, -1] = 0
+
+            Memorise.T_ph[fl] = Memorise.T_ph[fl][
+                Memorise.T_ph[fl][:, -1] > threshold]
+            Memorise.T_ph[fl][:, -1] = 0
+
+            Memorise.T_ps[fl] = Memorise.T_ps[fl][
+                Memorise.T_ps[fl][:, -1] > threshold]
+            Memorise.T_ps[fl][:, -1] = 0
+
+            Memorise.v_ph[fl] = Memorise.v_ph[fl][
+                Memorise.v_ph[fl][:, -1] > threshold]
+            Memorise.v_ph[fl][:, -1] = 0
+
+            Memorise.visc_ph[fl] = Memorise.visc_ph[fl][
+                Memorise.visc_ph[fl][:, -1] > threshold]
+            Memorise.visc_ph[fl][:, -1] = 0
+
+            msg = ('Dropping not frequently used fluid property values from '
+                   'memorise class for fluids ' + ', '.join(fl) + '.')
+            logger.debug(msg)
+        except KeyError:
+            pass
+
+
+# create memorise dictionaries
+Memorise.state = {}
+Memorise.back_end = {}
+Memorise.T_ph = {}
+Memorise.T_ps = {}
+Memorise.v_ph = {}
+Memorise.visc_ph = {}
+Memorise.s_ph = {}
+Memorise.value_range = {}
+
+
+def T_mix_ph(flow, T0=675):
+    r"""
+    Calculate the temperature from pressure and enthalpy.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    Returns
+    -------
+    T : float
+        Temperature T / K.
+
+    Note
+    ----
+    First, check if fluid property has been memorised already.
+    If this is the case, return stored value, otherwise calculate value and
+    store it in the memorisation class.
+
+    Uses CoolProp interface for pure fluids, newton algorithm for mixtures:
+
+    .. math::
+
+        T_{mix}\left(p,h\right) = T_{i}\left(p,h_{i}\right)\;
+        \forall i \in \text{fluid components}\\
+
+        h_{i} = h \left(pp_{i}, T_{mix} \right)\\
+        pp: \text{partial pressure}
+    """
+    # check if fluid properties have been calculated before
+    fl = tuple(flow[3].keys())
+    memorisation = fl in Memorise.T_ph
+    if memorisation:
+        a = Memorise.T_ph[fl][:, :-2]
+        b = np.array([flow[1], flow[2]] + list(flow[3].values()))
+        ix = np.where(np.all(abs(a - b) <= err, axis=1))[0]
+
+        if ix.size == 1:
+            # known fluid properties
+            Memorise.T_ph[fl][ix, -1] += 1
+            return Memorise.T_ph[fl][ix, -2][0]
+
+    # unknown fluid properties
+    fluid = single_fluid(flow[3])
+    if fluid is None:
+        # calculate the fluid properties for fluid mixtures
+        valmin = max(
+            [Memorise.value_range[f][2] for f in fl if flow[3][f] > err]
+        ) + 0.1
+        if T0 < valmin or np.isnan(T0):
+            T0 = valmin * 1.1
+
+        val = newton(h_mix_pT, dh_mix_pdT, flow, flow[2], val0=T0,
+                     valmin=valmin, valmax=3000, imax=10)
+    else:
+        # calculate fluid property for pure fluids
+        val = T_ph(flow[1], flow[2], fluid)
+
+    if memorisation:
+        # memorise the newly calculated value
+        new = np.asarray(
+            [[flow[1], flow[2]] + list(flow[3].values()) + [val, 0]])
+        Memorise.T_ph[fl] = np.append(Memorise.T_ph[fl], new, axis=0)
+
+    return val
+
+
+def T_ph(p, h, fluid):
+    r"""
+    Calculate the temperature from pressure and enthalpy for a pure fluid.
+
+    Parameters
+    ----------
+    p : float
+        Pressure p / Pa.
+
+    h : float
+        Specific enthalpy h / (J/kg).
+
+    fluid : str
+        Fluid name.
+
+    Returns
+    -------
+    T : float
+        Temperature T / K.
+    """
+    if Memorise.back_end[fluid] == 'IF97':
+        return entropy_iteration_IF97(p, h, fluid, 'T')
+    else:
+        Memorise.state[fluid].update(CP.HmassP_INPUTS, h, p)
+        return Memorise.state[fluid].T()
+
+
+def dT_mix_dph(flow, T0=675):
+    r"""
+    Calculate partial derivate of temperature to pressure.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    Returns
+    -------
+    dT / dp : float
+        Partial derivative of temperature to pressure dT /dp / (K/Pa).
+
+        .. math::
+
+            \frac{\partial T_{mix}}{\partial p} = \frac{T_{mix}(p+d,h)-
+            T_{mix}(p-d,h)}{2 \cdot d}
+    """
+    d = 0.1
+    up = flow.copy()
+    lo = flow.copy()
+    up[1] += d
+    lo[1] -= d
+    return (T_mix_ph(up, T0=T0) - T_mix_ph(lo, T0=T0)) / (2 * d)
+
+
+def dT_mix_pdh(flow, T0=675):
+    r"""
+    Calculate partial derivate of temperature to enthalpy.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    Returns
+    -------
+    dT / dh : float
+        Partial derivative of temperature to enthalpy dT /dh / ((kgK)/J).
+
+        .. math::
+
+            \frac{\partial T_{mix}}{\partial h} = \frac{T_{mix}(p,h+d)-
+            T_{mix}(p,h-d)}{2 \cdot d}
+    """
+    d = 0.1
+    up = flow.copy()
+    lo = flow.copy()
+    up[2] += d
+    lo[2] -= d
+    return (T_mix_ph(up, T0=T0) - T_mix_ph(lo, T0=T0)) / (2 * d)
+
+
+def dT_mix_ph_dfluid(flow, T0=675):
+    r"""
+    Calculate partial derivate of temperature to fluid composition.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    Returns
+    -------
+    dT / dfluid : ndarray
+        Partial derivatives of temperature to fluid composition
+        dT / dfluid / K.
+
+        .. math::
+
+            \frac{\partial T_{mix}}{\partial fluid_{i}} =
+            \frac{T_{mix}(p,h,fluid_{i}+d)-
+            T_{mix}(p,h,fluid_{i}-d)}{2 \cdot d}
+    """
+    d = 1e-5
+    up = flow.copy()
+    lo = flow.copy()
+    vec_deriv = []
+    for fluid, x in flow[3].items():
+        if x > err:
+            up[3][fluid] += d
+            lo[3][fluid] -= d
+            vec_deriv += [
+                (T_mix_ph(up, T0=T0) - T_mix_ph(lo, T0=T0)) / (2 * d)]
+            up[3][fluid] -= d
+            lo[3][fluid] += d
+        else:
+            vec_deriv += [0]
+
+    return vec_deriv
+
+
+def T_mix_ps(flow, s, T0=675):
+    r"""
+    Calculate the temperature from pressure and entropy.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    s : float
+        Entropy of flow in J / (kgK).
+
+    Returns
+    -------
+    T : float
+        Temperature T / K.
+
+    Note
+    ----
+    First, check if fluid property has been memorised already.
+    If this is the case, return stored value, otherwise calculate value and
+    store it in the memorisation class.
+
+    Uses CoolProp interface for pure fluids, newton algorithm for mixtures:
+
+    .. math::
+
+        T_{mix}\left(p,s\right) = T_{i}\left(p,s_{i}\right)\;
+        \forall i \in \text{fluid components}\\
+
+        s_{i} = s \left(pp_{i}, T_{mix} \right)\\
+        pp: \text{partial pressure}
+
+    """
+    # check if fluid properties have been calculated before
+    fl = tuple(flow[3].keys())
+    memorisation = fl in Memorise.T_ps
+    if memorisation:
+        a = Memorise.T_ps[fl][:, :-2]
+        b = np.asarray([flow[1], flow[2]] + list(flow[3].values()) + [s])
+        ix = np.where(np.all(abs(a - b) <= err, axis=1))[0]
+        if ix.size == 1:
+            # known fluid properties
+            Memorise.T_ps[fl][ix, -1] += 1
+            return Memorise.T_ps[fl][ix, -2][0]
+
+    # unknown fluid properties
+    fluid = single_fluid(flow[3])
+    if fluid is None:
+        # calculate the fluid properties for fluid mixtures
+        valmin = max(
+            [Memorise.value_range[f][2] for f in fl if flow[3][f] > err]
+        ) + 0.1
+        if T0 < valmin or np.isnan(T0):
+            T0 = valmin * 1.1
+
+        val = newton(s_mix_pT, ds_mix_pdT, flow, s, val0=T0,
+                     valmin=valmin, valmax=3000, imax=10)
+
+    else:
+        # calculate fluid property for pure fluids
+        val = T_ps(flow[1], s, fluid)
+
+    if memorisation:
+        new = np.asarray(
+            [[flow[1], flow[2]] + list(flow[3].values()) + [s, val, 0]])
+        # memorise the newly calculated value
+        Memorise.T_ps[fl] = np.append(Memorise.T_ps[fl], new, axis=0)
+
+    return val
+
+
+def T_ps(p, s, fluid):
+    r"""
+    Calculate the temperature from pressure and entropy for a pure fluid.
+
+    Parameters
+    ----------
+    p : float
+       Pressure p / Pa.
+
+    s : float
+       Specific entropy h / (J/(kgK)).
+
+    fluid : str
+       Fluid name.
+
+    Returns
+    -------
+    T : float
+       Temperature T / K.
+    """
+    Memorise.state[fluid].update(CP.PSmass_INPUTS, p, s)
+    return Memorise.state[fluid].T()
+
+
+def h_mix_pT(flow, T, force_gas=False):
+    r"""
+    Calculate the enthalpy from pressure and Temperature.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    T : float
+        Temperature of flow T / K.
+
+    Returns
+    -------
+    h : float
+        Enthalpy h / (J/kg).
+
+    Note
+    ----
+    Calculation for fluid mixtures.
+
+    .. math::
+
+        h_{mix}(p,T)=\sum_{i} h(pp_{i},T,fluid_{i})\;
+        \forall i \in \text{fluid components}\\
+        pp: \text{partial pressure}
+    """
+    n = molar_mass_flow(flow[3])
+
+    h = 0
+    fluid_name = single_fluid(flow[3])
+    if fluid_name is None:
+
+        x_i = {
+            fluid: y / (molar_masses[fluid] * n)
+            for fluid, y in flow[3].items()
+        }
+
+        water = Memorise.water
+        if (water is not None and not force_gas and flow[3][water] > err):
+            y_i_gas, x_i_gas, y_water_liq, x_water_liq = (
+                cond_check(flow[3], x_i, flow[1], n, T)
+            )
+
+        else:
+            y_i_gas = flow[3]
+            y_water_liq = 0
+            x_i_gas = x_i
+
+        for fluid, y in y_i_gas.items():
+            if y > err:
+                if fluid == water and y_water_liq > 0:
+                    Memorise.state[fluid].update(CP.QT_INPUTS, 0, T)
+                    h += Memorise.state[fluid].hmass() * y_water_liq
+                    Memorise.state[fluid].update(CP.QT_INPUTS, 1, T)
+                    h += Memorise.state[fluid].hmass() * y * (1 - y_water_liq)
+
+                else:
+                    h += h_pT(
+                        flow[1] * x_i_gas[fluid], T, fluid, force_gas
+                    ) * y * (1 - y_water_liq)
+
+    else:
+        h = h_pT(flow[1], T, fluid_name, force_gas)
+
+    return h
+
+
+def h_pT(p, T, fluid, force_gas=False):
+    r"""
+    Calculate the enthalpy from pressure and temperature for a pure fluid.
+
+    Parameters
+    ----------
+    p : float
+        Pressure p / Pa.
+
+    T : float
+        Temperature T / K.
+
+    fluid : str
+        Fluid name.
+
+    Returns
+    -------
+    h : float
+        Specific enthalpy h / (J/kg).
+    """
+    if force_gas:
+        if T < get_T_crit(fluid):
+            Memorise.state[fluid].update(CP.PT_INPUTS, p, T)
+            h = Memorise.state[fluid].hmass()
+            Memorise.state[fluid].update(CP.QT_INPUTS, 1, T)
+            h_sat = Memorise.state[fluid].hmass()
+            return max(h, h_sat)
+
+    Memorise.state[fluid].update(CP.PT_INPUTS, p, T)
+    return Memorise.state[fluid].hmass()
+
+
+def dh_mix_pdT(flow, T):
+    r"""
+    Calculate partial derivate of enthalpy to temperature.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    T : float
+        Temperature T / K.
+
+    Returns
+    -------
+    dh / dT : float
+        Partial derivative of enthalpy to temperature dh / dT / (J/(kgK)).
+
+        .. math::
+
+            \frac{\partial h_{mix}}{\partial T} =
+            \frac{h_{mix}(p,T+d)-h_{mix}(p,T-d)}{2 \cdot d}
+    """
+    d = 0.01
+    return (h_mix_pT(flow, T + d) - h_mix_pT(flow, T - d)) / (2 * d)
+
+
+def h_mix_ps(flow, s, T0=675):
+    r"""
+    Calculate the enthalpy from pressure and temperature.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    s : float
+        Specific entropy of flow s / (J/(kgK)).
+
+    Returns
+    -------
+    h : float
+        Specific enthalpy h / (J/kg).
+
+    Note
+    ----
+    Calculation for fluid mixtures.
+
+    .. math::
+
+        h_{mix}\left(p,s\right)=h\left(p, T_{mix}\left(p,s\right)\right)
+    """
+    return h_mix_pT(flow, T_mix_ps(flow, s, T0=T0))
+
+
+def h_ps(p, s, fluid):
+    r"""
+    Calculate the enthalpy from pressure and entropy for a pure fluid.
+
+    Parameters
+    ----------
+    p : float
+        Pressure p / Pa.
+
+    s : float
+        Specific entropy h / (J/(kgK)).
+
+    fluid : str
+        Fluid name.
+
+    Returns
+    -------
+    h : float
+        Specific enthalpy h / (J/kg).
+    """
+    Memorise.state[fluid].update(CP.PSmass_INPUTS, p, s)
+    return Memorise.state[fluid].hmass()
+
+
+def h_ps_IF97(params, s):
+    r"""
+    Calculate the enthalpy from pressure and entropy for IF97 backend.
+
+    Parameters
+    ----------
+    fluid : str
+        Fluid name.
+
+    p : float
+        Pressure p / Pa.
+
+    s : float
+        Specific entropy h / (J/(kgK)).
+
+    Returns
+    -------
+    h : float
+        Specific enthalpy h / (J/kg).
+    """
+    Memorise.state[params[0]].update(CP.PSmass_INPUTS, params[1], s)
+    return Memorise.state[params[0]].hmass()
+
+
+def dh_pds_IF97(params, s):
+    r"""
+    Calculate the derivative of enthalpy to entropy at constant pressure.
+
+    For pure fluids only, required for IF97 entropy iteration only.
+
+    Parameters
+    ----------
+    p : float
+        Pressure p / Pa.
+
+    s : float
+        Specific entropy h / (J/(kgK)).
+
+    fluid : str
+        Fluid name.
+
+    Returns
+    -------
+    dh : float
+        Derivative of specific enthalpy dh / ds / K.
+    """
+    d = 1e-2
+    Memorise.state[params[0]].update(CP.PSmass_INPUTS, params[1], s + d)
+    h_upper = Memorise.state[params[0]].hmass()
+
+    Memorise.state[params[0]].update(CP.PSmass_INPUTS, params[1], s - d)
+    h_lower = Memorise.state[params[0]].hmass()
+
+    return (h_upper - h_lower) / (2 * d)
+
+
+def h_mix_pQ(flow, Q):
+    r"""
+    Calculate the enthalpy from pressure and vapour mass fraction.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    Q : float
+        Vapour mass fraction Q / 1.
+
+    Returns
+    -------
+    h : float
+        Specific enthalpy h / (J/kg).
+
+    Note
+    ----
+    This function works for pure fluids only!
+    """
+    fluid = single_fluid(flow[3])
+    if fluid is None:
+        if sum(flow[3].values()) == 0:
+            msg = 'The function h_mix_pQ is called without fluid information.'
+            logger.error(msg)
+            raise ValueError(msg)
+        else:
+            msg = 'The function h_mix_pQ can only be used for pure fluids.'
+            logger.error(msg)
+            raise ValueError(msg)
+
+    try:
+        Memorise.state[fluid].update(CP.PQ_INPUTS, flow[1], Q)
+    except ValueError:
+        p_crit = get_p_crit(fluid)
+        Memorise.state[fluid].update(CP.PQ_INPUTS, p_crit * 0.99, Q)
+
+    return Memorise.state[fluid].hmass()
+
+
+def dh_mix_dpQ(flow, Q):
+    r"""
+    Calculate partial derivate of enthalpy to vapour mass fraction.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    Q : float
+        Vapour mass fraction Q / 1.
+
+    Returns
+    -------
+    dh / dQ : float
+        Partial derivative of enthalpy to vapour mass fraction
+        dh / dQ / (J/kg).
+
+        .. math::
+
+            \frac{\partial h_{mix}}{\partial p} =
+            \frac{h_{mix}(p+d,Q)-h_{mix}(p-d,Q)}{2 \cdot d}\\
+            Q: \text{vapour mass fraction}
+
+    Note
+    ----
+    This works for pure fluids only!
+    """
+    d = 0.1
+    up = flow.copy()
+    lo = flow.copy()
+    up[1] += d
+    lo[1] -= d
+    return (h_mix_pQ(up, Q) - h_mix_pQ(lo, Q)) / (2 * d)
+
+
+def get_p_crit(fluid):
+    """
+    Get critical point pressure.
+
+    Parameters
+    ----------
+    fluid : str
+        Fluid name.
+
+    Returns
+    -------
+    p_crit : float
+        Critical point pressure.
+    """
+    return Memorise.state[fluid].trivial_keyed_output(CP.iP_critical)
+
+
+def get_T_crit(fluid):
+    """
+    Get critical point temperature.
+
+    Parameters
+    ----------
+    fluid : str
+        Fluid name.
+
+    Returns
+    -------
+    T_crit : float
+        Critical point temperature.
+    """
+    return Memorise.state[fluid].trivial_keyed_output(CP.iT_critical)
+
+
+def T_bp_p(flow):
+    r"""
+    Calculate temperature from boiling point pressure.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    Returns
+    -------
+    T : float
+        Temperature at boiling point.
+
+    Note
+    ----
+    This function works for pure fluids only!
+    """
+    fluid = single_fluid(flow[3])
+    p_crit = get_p_crit(fluid)
+    if flow[1] > p_crit:
+        Memorise.state[fluid].update(CP.PQ_INPUTS, p_crit * 0.99, 1)
+    else:
+        Memorise.state[fluid].update(CP.PQ_INPUTS, flow[1], 1)
+    return Memorise.state[fluid].T()
+
+
+def dT_bp_dp(flow):
+    r"""
+    Calculate partial derivate of temperature to boiling point pressure.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    Returns
+    -------
+    dT / dp : float
+        Partial derivative of temperature to boiling point pressure in K / Pa.
+
+        .. math::
+
+            \frac{\partial h_{mix}}{\partial p} =
+            \frac{T_{bp}(p+d)-T_{bp}(p-d)}{2 \cdot d}\\
+            Q: \text{vapour mass fraction}
+
+    Note
+    ----
+    This works for pure fluids only!
+    """
+    d = 0.1
+    up = flow.copy()
+    lo = flow.copy()
+    up[1] += d
+    lo[1] -= d
+    return (T_bp_p(up) - T_bp_p(lo)) / (2 * d)
+
+
+def cond_check(y_i, x_i, p, n, T):
+    """Check if water is partially condensing in gaseous mixture.
+
+    Parameters
+    ----------
+    y_i : dict
+        Mass specific fluid composition.
+    x_i : dict
+        Mole specific fluid composition.
+    p : float
+        Pressure of mass flow.
+    n : float
+        Molar mass flow.
+    T : float
+        Temperature of mass flow.
+
+    Returns
+    -------
+    tuple
+        Tuple containing gas phase mass specific and molar specific
+        compositions and overall liquid water mass fraction.
+    """
+    x_i_gas = x_i.copy()
+    y_i_gas = y_i.copy()
+    y_water_liq = 0
+    x_water_liq = 0
+    water_label = Memorise.water
+
+    if T < get_T_crit(water_label):
+        Memorise.state[water_label].update(CP.QT_INPUTS, 1, T)
+        p_sat = Memorise.state[water_label].p()
+
+        pp_water = p * y_i[water_label] / (
+            molar_masses[water_label] * n
+        )
+
+        if p_sat < pp_water:
+            x_water_gas = (1 - x_i[water_label]) / (p / p_sat - 1)
+            x_water_liq = x_i[water_label] - x_water_gas
+            x_gas_sum = 1 - x_water_liq
+
+            x_i_gas = {f: x / x_gas_sum for f, x in x_i.items()}
+            x_i_gas[water_label] = x_water_gas / x_gas_sum
+
+            y_water_liq = x_water_liq * molar_masses[water_label] / (
+                sum([
+                    x * molar_masses[fluid]
+                    for fluid, x in x_i.items()
+                ])
+            )
+
+            M = sum([x * molar_masses[fluid] for fluid, x in x_i_gas.items()])
+            y_i_gas = {
+                fluid: x / M * molar_masses[fluid]
+                for fluid, x in x_i_gas.items()
+            }
+
+    return y_i_gas, x_i_gas, y_water_liq, x_water_liq
+
+
+def v_mix_ph(flow, T0=675):
+    r"""
+    Calculate the specific volume from pressure and enthalpy.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    Returns
+    -------
+    v : float
+        Specific volume v / (:math:`\mathrm{m}^3`/kg).
+
+    Note
+    ----
+    First, check if fluid property has been memorised already.
+    If this is the case, return stored value, otherwise calculate value and
+    store it in the memorisation class.
+
+    Uses CoolProp interface for pure fluids, newton algorithm for mixtures:
+
+    .. math::
+
+        v_{mix}\left(p,h\right) = v\left(p,T_{mix}(p,h)\right)
+    """
+    # check if fluid properties have been calculated before
+    fl = tuple(flow[3].keys())
+    memorisation = fl in Memorise.v_ph
+    if memorisation:
+        a = Memorise.v_ph[fl][:, :-2]
+        b = np.asarray([flow[1], flow[2]] + list(flow[3].values()))
+        ix = np.where(np.all(abs(a - b) <= err, axis=1))[0]
+        if ix.size == 1:
+            # known fluid properties
+            Memorise.v_ph[fl][ix, -1] += 1
+            return Memorise.v_ph[fl][ix, -2][0]
+
+    # unknown fluid properties
+    fluid = single_fluid(flow[3])
+    if fluid is None:
+        # calculate the fluid properties for fluid mixtures
+        val = v_mix_pT(flow, T_mix_ph(flow, T0=T0))
+    else:
+        # calculate fluid property for pure fluids
+        val = 1 / d_ph(flow[1], flow[2], fluid)
+
+    if memorisation:
+        # memorise the newly calculated value
+        new = np.asarray(
+            [[flow[1], flow[2]] + list(flow[3].values()) + [val, 0]])
+        Memorise.v_ph[fl] = np.append(Memorise.v_ph[fl], new, axis=0)
+
+    return val
+
+
+def d_ph(p, h, fluid):
+    r"""
+    Calculate the density from pressure and enthalpy for a pure fluid.
+
+    Parameters
+    ----------
+    p : float
+        Pressure p / Pa.
+
+    h : float
+        Specific enthalpy h / (J/kg).
+
+    fluid : str
+        Fluid name.
+
+    Returns
+    -------
+    d : float
+        Density d / (kg/:math:`\mathrm{m}^3`).
+    """
+    if Memorise.back_end[fluid] == 'IF97':
+        return entropy_iteration_IF97(p, h, fluid, 'rho')
+    else:
+        Memorise.state[fluid].update(CP.HmassP_INPUTS, h, p)
+        return Memorise.state[fluid].rhomass()
+
+
+def Q_ph(p, h, fluid):
+    r"""
+    Calculate vapor mass fraction from pressure and enthalpy for a pure fluid.
+
+    Parameters
+    ----------
+    p : float
+        Pressure p / Pa.
+
+    h : float
+        Specific enthalpy h / (J/kg).
+
+    fluid : str
+        Fluid name.
+
+    Returns
+    -------
+    x : float
+        Vapor mass fraction.
+    """
+    try:
+        Memorise.state[fluid].update(CP.HmassP_INPUTS, h, p)
+        return Memorise.state[fluid].Q()
+    except (KeyError, ValueError, AttributeError):
+        return np.nan
+
+
+def dv_mix_dph(flow, T0=675):
+    r"""
+    Calculate partial derivate of specific volume to pressure.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    Returns
+    -------
+    dv / dp : float
+        Partial derivative of specific volume to pressure
+        dv /dp / (:math:`\mathrm{m}^3`/(Pa kg)).
+
+        .. math::
+
+            \frac{\partial v_{mix}}{\partial p} = \frac{v_{mix}(p+d,h)-
+            v_{mix}(p-d,h)}{2 \cdot d}
+    """
+    d = 0.1
+    up = flow.copy()
+    lo = flow.copy()
+    up[1] += d
+    lo[1] -= d
+    return (v_mix_ph(up, T0=T0) - v_mix_ph(lo, T0=T0)) / (2 * d)
+
+
+def dv_mix_pdh(flow, T0=675):
+    r"""
+    Calculate partial derivate of specific volume to enthalpy.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    Returns
+    -------
+    dv / dh : float
+        Partial derivative of specific volume to enthalpy
+        dv /dh / (:math:`\mathrm{m}^3`/J).
+
+        .. math::
+
+            \frac{\partial v_{mix}}{\partial h} = \frac{v_{mix}(p,h+d)-
+            v_{mix}(p,h-d)}{2 \cdot d}
+    """
+    d = 0.1
+    up = flow.copy()
+    lo = flow.copy()
+    up[2] += d
+    lo[2] -= d
+    return (v_mix_ph(up, T0=T0) - v_mix_ph(lo, T0=T0)) / (2 * d)
+
+
+def v_mix_pT(flow, T):
+    r"""
+    Calculate the specific volume from pressure and temperature.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    T : float
+        Temperature T / K.
+
+    Returns
+    -------
+    v : float
+        Specific volume v / (:math:`\mathrm{m}^3`/kg).
+
+    Note
+    ----
+    Calculation for fluid mixtures.
+
+    .. math::
+
+        v_{mix}(p,T)=\frac{1}{\sum_{i} \rho(pp_{i}, T, fluid_{i})}\;
+        \forall i \in \text{fluid components}\\
+        pp: \text{partial pressure}
+    """
+    n = molar_mass_flow(flow[3])
+
+    d = 0
+    for fluid, x in flow[3].items():
+        if x > err:
+            ni = x / molar_masses[fluid]
+            d += d_pT(flow[1] * ni / n, T, fluid)
+
+    return 1 / d
+
+
+def d_mix_pT(flow, T):
+    r"""
+    Calculate the density from pressure and temperature.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    T : float
+        Temperature T / K.
+
+    Returns
+    -------
+    d : float
+        Density d / (kg/:math:`\mathrm{m}^3`).
+
+    Note
+    ----
+    Calculation for fluid mixtures.
+
+    .. math::
+
+        \rho_{mix}\left(p,T\right)=\frac{1}{v_{mix}\left(p,T\right)}
+    """
+    return 1 / v_mix_pT(flow, T)
+
+
+def d_pT(p, T, fluid):
+    r"""
+    Calculate the density from pressure and temperature for a pure fluid.
+
+    Parameters
+    ----------
+    p : float
+        Pressure p / Pa.
+
+    T : float
+        Temperature T / K.
+
+    fluid : str
+        Fluid name.
+
+    Returns
+    -------
+    d : float
+        Density d / (kg/:math:`\mathrm{m}^3`).
+    """
+    Memorise.state[fluid].update(CP.PT_INPUTS, p, T)
+    return Memorise.state[fluid].rhomass()
+
+
+def visc_mix_ph(flow, T0=675):
+    r"""
+    Calculate the dynamic viscorsity from pressure and enthalpy.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    Returns
+    -------
+    visc : float
+        Dynamic viscosity visc / Pa s.
+
+    Note
+    ----
+    First, check if fluid property has been memorised already.
+    If this is the case, return stored value, otherwise calculate value and
+    store it in the memorisation class.
+
+    Uses CoolProp interface for pure fluids, newton algorithm for mixtures:
+
+    .. math::
+
+        \eta_{mix}\left(p,h\right) = \eta\left(p,T_{mix}(p,h)\right)
+    """
+    # check if fluid properties have been calculated before
+    fl = tuple(flow[3].keys())
+    memorisation = fl in Memorise.visc_ph
+    if memorisation:
+        a = Memorise.visc_ph[fl][:, :-2]
+        b = np.asarray([flow[1], flow[2]] + list(flow[3].values()))
+        ix = np.where(np.all(abs(a - b) <= err, axis=1))[0]
+        if ix.size == 1:
+            # known fluid properties
+            Memorise.visc_ph[fl][ix, -1] += 1
+            return Memorise.visc_ph[fl][ix, -2][0]
+
+    # unknown fluid properties
+    fluid = single_fluid(flow[3])
+    if fluid is None:
+        # calculate the fluid properties for fluid mixtures
+        val = visc_mix_pT(flow, T_mix_ph(flow, T0=T0))
+    else:
+        # calculate the fluid properties for pure fluids
+        val = visc_ph(flow[1], flow[2], fluid)
+
+    if memorisation:
+        # memorise the newly calculated value
+        new = np.asarray(
+            [[flow[1], flow[2]] + list(flow[3].values()) + [val, 0]])
+        Memorise.visc_ph[fl] = np.append(Memorise.visc_ph[fl], new, axis=0)
+    return val
+
+
+def visc_ph(p, h, fluid):
+    r"""
+    Calculate dynamic viscosity from pressure and enthalpy for a pure fluid.
+
+    Parameters
+    ----------
+    p : float
+        Pressure p / Pa.
+
+    h : float
+        Specific enthalpy h / (J/kg).
+
+    fluid : str
+        Fluid name.
+
+    Returns
+    -------
+    visc : float
+        Viscosity visc / Pa s.
+    """
+    if Memorise.back_end[fluid] == 'IF97':
+        return entropy_iteration_IF97(p, h, fluid, 'visc')
+    else:
+        Memorise.state[fluid].update(CP.HmassP_INPUTS, h, p)
+        return Memorise.state[fluid].viscosity()
+
+
+def visc_mix_pT(flow, T):
+    r"""
+    Calculate dynamic viscosity from pressure and temperature.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    T : float
+        Temperature T / K.
+
+    Returns
+    -------
+    visc : float
+        Dynamic viscosity visc / Pa s.
+
+    Note
+    ----
+    Calculation for fluid mixtures.
+
+    .. math::
+
+        \eta_{mix}(p,T)=\frac{\sum_{i} \left( \eta(p,T,fluid_{i}) \cdot y_{i}
+        \cdot \sqrt{M_{i}} \right)}
+        {\sum_{i} \left(y_{i} \cdot \sqrt{M_{i}} \right)}\;
+        \forall i \in \text{fluid components}\\
+        y: \text{volume fraction}\\
+        M: \text{molar mass}
+
+    Reference: :cite:`Herning1936`.
+    """
+    n = molar_mass_flow(flow[3])
+
+    a = 0
+    b = 0
+    for fluid, x in flow[3].items():
+        if x > err:
+            bi = x * np.sqrt(molar_masses[fluid]) / (molar_masses[fluid] * n)
+            b += bi
+            a += bi * visc_pT(flow[1], T, fluid)
+
+    return a / b
+
+
+def visc_pT(p, T, fluid):
+    r"""
+    Calculate dynamic viscosity from pressure and temperature for a pure fluid.
+
+    Parameters
+    ----------
+    p : float
+        Pressure p / Pa.
+
+    T : float
+        Temperature T / K.
+
+    fluid : str
+        Fluid name.
+
+    Returns
+    -------
+    visc : float
+        Viscosity visc / Pa s.
+    """
+    Memorise.state[fluid].update(CP.PT_INPUTS, p, T)
+    return Memorise.state[fluid].viscosity()
+
+
+def s_mix_ph(flow, T0=675):
+    r"""
+    Calculate the entropy from pressure and enthalpy.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    Returns
+    -------
+    s : float
+        Specific entropy s / (J/(kgK)).
+
+    Note
+    ----
+    First, check if fluid property has been memorised already.
+    If this is the case, return stored value, otherwise calculate value and
+    store it in the memorisation class.
+
+    Uses CoolProp interface for pure fluids, newton algorithm for mixtures:
+
+    .. math::
+
+        s_{mix}\left(p,h\right) = s\left(p,T_{mix}(p,h)\right)
+    """
+    # check if fluid properties have been calculated before
+    fl = tuple(flow[3].keys())
+    memorisation = fl in Memorise.s_ph
+    if memorisation:
+        a = Memorise.s_ph[fl][:, :-2]
+        b = np.asarray([flow[1], flow[2]] + list(flow[3].values()))
+        ix = np.where(np.all(abs(a - b) <= err, axis=1))[0]
+        if ix.size == 1:
+            # known fluid properties
+            Memorise.s_ph[fl][ix, -1] += 1
+            return Memorise.s_ph[fl][ix, -2][0]
+
+    # unknown fluid properties
+    fluid = single_fluid(flow[3])
+    if fluid is None:
+        # calculate the fluid properties for fluid mixtures
+        val = s_mix_pT(flow, T_mix_ph(flow, T0=T0))
+    else:
+        # calculate fluid property for pure fluids
+        val = s_ph(flow[1], flow[2], fluid)
+
+    if memorisation:
+        # memorise the newly calculated value
+        new = np.asarray(
+            [[flow[1], flow[2]] + list(flow[3].values()) + [val, 0]])
+        Memorise.s_ph[fl] = np.append(Memorise.s_ph[fl], new, axis=0)
+
+    return val
+
+
+def s_ph(p, h, fluid):
+    r"""
+    Calculate the entropy from pressure and enthalpy for a pure fluid.
+
+    Parameters
+    ----------
+    p : float
+        Pressure p / Pa.
+
+    h : float
+        Specific enthalpy h / (J/kg).
+
+    fluid : str
+        Fluid name.
+
+    Returns
+    -------
+    s : float
+        Specific entropy s / (J/(kgK)).
+    """
+    if Memorise.back_end[fluid] == 'IF97':
+        return entropy_iteration_IF97(p, h, fluid, 's')
+    else:
+        Memorise.state[fluid].update(CP.HmassP_INPUTS, h, p)
+        return Memorise.state[fluid].smass()
+
+
+def s_mix_pT(flow, T, force_gas=False):
+    r"""
+    Calculate the entropy from pressure and temperature.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    T : float
+        Temperature T / K.
+
+    Returns
+    -------
+    s : float
+        Specific entropy s / (J/(kgK)).
+
+    Note
+    ----
+    Calculation for fluid mixtures.
+
+    .. math::
+
+        s_{mix}(p,T)=\sum_{i} x_{i} \cdot s(pp_{i},T,fluid_{i})-
+        \sum_{i} x_{i} \cdot R_{i} \cdot \ln \frac{pp_{i}}{p}\;
+        \forall i \in \text{fluid components}\\
+        pp: \text{partial pressure}\\
+        R: \text{gas constant}
+    """
+    n = molar_mass_flow(flow[3])
+    s = 0
+
+    fluid_name = single_fluid(flow[3])
+    if fluid_name is None:
+
+        x_i = {
+            fluid: y / (molar_masses[fluid] * n)
+            for fluid, y in flow[3].items()
+        }
+
+        water = Memorise.water
+        if (water is not None and not force_gas and flow[3][water] > err):
+            y_i_gas, x_i_gas, y_water_liq, x_water_liq = (
+                cond_check(flow[3], x_i, flow[1], n, T)
+            )
+
+        else:
+            y_i_gas = flow[3]
+            y_water_liq = 0
+            x_i_gas = x_i
+
+        for fluid, y in y_i_gas.items():
+            if y > err:
+                if fluid == water and y_water_liq > 0:
+                    Memorise.state[water].update(CP.QT_INPUTS, 1, T)
+                    s += Memorise.state[water].smass() * y * (
+                        1 - y_water_liq
+                    )
+                    Memorise.state[water].update(CP.QT_INPUTS, 0, T)
+                    s += Memorise.state[water].smass() * y_water_liq
+
+                else:
+                    pp = flow[1] * x_i_gas[fluid]
+                    s += y * (1 - y_water_liq) * s_pT(pp, T, fluid, force_gas)
+
+    else:
+        s = s_pT(flow[1], T, fluid_name, force_gas)
+
+    return s
+
+
+def s_pT(p, T, fluid, force_gas):
+    r"""
+    Calculate the entropy from pressure and temperature for a pure fluid.
+
+    Parameters
+    ----------
+    p : float
+        Pressure p / Pa.
+
+    T : float
+        Temperature T / K.
+
+    fluid : str
+        Fluid name.
+
+    Returns
+    -------
+    s : float
+        Specific entropy s / (J/(kgK)).
+    """
+    if force_gas:
+        if T < get_T_crit(fluid):
+            Memorise.state[fluid].update(CP.PT_INPUTS, p, T)
+            s = Memorise.state[fluid].smass()
+            Memorise.state[fluid].update(CP.QT_INPUTS, 1, T)
+            s_sat = Memorise.state[fluid].smass()
+            return max(s, s_sat)
+
+    Memorise.state[fluid].update(CP.PT_INPUTS, p, T)
+    return Memorise.state[fluid].smass()
+
+
+def ds_mix_pdT(flow, T):
+    r"""
+    Calculate partial derivate of entropy to temperature.
+
+    Parameters
+    ----------
+    flow : list
+        Fluid property vector containing mass flow, pressure, enthalpy and
+        fluid composition.
+
+    T : float
+        Temperature T / K.
+
+    Returns
+    -------
+    ds / dT : float
+        Partial derivative of specific entropy to temperature
+        ds / dT / (J/(kg :math:`\mathrm{K}^2`)).
+
+        .. math::
+
+            \frac{\partial s_{mix}}{\partial T} =
+            \frac{s_{mix}(p,T+d)-s_{mix}(p,T-d)}{2 \cdot d}
+    """
+    d = 0.01
+    return (s_mix_pT(flow, T + d) - s_mix_pT(flow, T - d)) / (2 * d)
+
+
+def isentropic(inflow, outflow, T0=675):
+    r"""
+    Calculate the enthalpy at the outlet after isentropic process.
+
+    Parameters
+    ----------
+    inflow : list
+        Inflow fluid property vector containing mass flow, pressure, enthalpy
+        and fluid composition.
+
+    outflow : list
+        Outflow fluid property vector containing mass flow, pressure, enthalpy
+        and fluid composition.
+
+    Returns
+    -------
+    h_s : float
+        Enthalpy after isentropic state change.
+
+        .. math::
+
+            h_\mathrm{s} = \begin{cases}
+            h\left(p_{out}, s\left(p_{in}, h_{in}\right) \right) &
+            \text{pure fluids}\\
+            h\left(p_{out}, s\left(p_{in}, T_{in}\right) \right) &
+            \text{mixtures}\\
+            \end{cases}
+    """
+    fluid = single_fluid(inflow[3])
+    if fluid is not None:
+        return h_ps(outflow[1], s_ph(inflow[1], inflow[2], fluid), fluid)
+    else:
+        s_mix = s_mix_ph(inflow)
+        return h_mix_ps(outflow, s_mix, T0=T0)
+
+
+def calc_physical_exergy(conn, p0, T0):
+    r"""
+    Calculate specific physical exergy.
+
+    Physical exergy is allocated to a thermal and a mechanical share according
+    to :cite:`Morosuk2019`.
+
+    Parameters
+    ----------
+    conn : tespy.connections.connection.Connection
+        Connection to calculate specific physical exergy for.
+
+    p0 : float
+        Ambient pressure p0 / Pa.
+
+    T0 : float
+        Ambient temperature T0 / K.
+
+    Returns
+    -------
+    e_ph : tuple
+        Specific thermal and mechanical exergy
+        (:math:`e^\mathrm{T}`, :math:`e^\mathrm{M}`) in J / kg.
+
+        .. math::
+
+            e^\mathrm{T} = \left( h - h \left( p, T_0 \right) \right) -
+            T_0 \cdot \left(s - s\left(p, T_0\right)\right)
+
+            e^\mathrm{M}=\left(h\left(p,T_0\right)-h\left(p_0,T_0\right)\right)
+            -T_0\cdot\left(s\left(p, T_0\right)-s\left(p_0,T_0\right)\right)
+
+            e^\mathrm{PH} = e^\mathrm{T} + e^\mathrm{M}
+    """
+    h_T0_p = h_mix_pT([0, conn.p.val_SI, 0, conn.fluid.val], T0)
+    s_T0_p = s_mix_pT([0, conn.p.val_SI, 0, conn.fluid.val], T0)
+    ex_therm = (conn.h.val_SI - h_T0_p) - T0 * (conn.s.val_SI - s_T0_p)
+    h0 = h_mix_pT([0, p0, 0, conn.fluid.val], T0)
+    s0 = s_mix_pT([0, p0, 0, conn.fluid.val], T0)
+    ex_mech = (h_T0_p - h0) - T0 * (s_T0_p - s0)
+    return ex_therm, ex_mech
+
+
+def calc_chemical_exergy(conn, p0, T0, Chem_Ex):
+    """
+    Calculate specific chemical exergy.
+
+    Parameters
+    ----------
+    conn : tespy.connections.connection.Connection
+        Connection to calculate specific chemical exergy for.
+
+    p0 : float
+        Ambient pressure p0 / Pa.
+
+    T0 : float
+        Ambient temperature T0 / K.
+
+    Chem_Ex : dict
+        Lookup table for standard specific chemical exergy.
+
+    Returns
+    -------
+    e_ch : float
+        Specific chemical exergy in J / kg.
+    """
+    fluid_name = single_fluid(conn.fluid.val)
+
+    if fluid_name is None:
+
+        n = molar_mass_flow(conn.fluid.val)
+        x = {
+                fluid: y / (molar_masses[fluid] * n)
+                for fluid, y in conn.fluid.val.items()
+            }
+
+        molar_mass_mixture = sum(
+            [x * molar_masses[fluid] for fluid, x in x.items()]
+        )
+
+        y_i_gas, x_i_gas, y_water_liq, x_water_liq = (
+            cond_check(conn.fluid.val, x, p0, n, T0)
+        )
+
+    else:
+
+        fluid_aliases = CP.CoolProp.get_aliases(fluid_name)
+        y = [Chem_Ex[k][Chem_Ex[k][4]] for k in fluid_aliases if k in Chem_Ex]
+        return y[0] / molar_masses[fluid_name] * 1e3
+
+    ex_cond = 0
+    ex_dry = 0
+    for fluid, x in x_i_gas.items():
+        if x == 0:
+            continue
+
+        fluid_aliases = CP.CoolProp.get_aliases(fluid)
+        if fluid in CP.CoolProp.get_aliases('H2O') and x_water_liq > 0:
+
+            y = [Chem_Ex[k][2] for k in fluid_aliases if k in Chem_Ex]
+            ex_cond += x_water_liq * y[0]
+
+        y = [Chem_Ex[k][3] for k in fluid_aliases if k in Chem_Ex]
+        ex_dry += x * y[0] + T0 * gas_constants['uni'] * 1e-3 * x * np.log(x)
+
+    ex_chemical = ex_cond + ex_dry * (1 - x_water_liq)
+    ex_chemical *= 1 / molar_mass_mixture
+
+    return ex_chemical * 1e3  # Data from Chem_Ex are in kJ / mol
+
+
+def entropy_iteration_IF97(p, h, fluid, output):
+    r"""
+    Calculate state in IF97 back-end via entropy iteration.
+
+    Parameters
+    ----------
+    p : float
+        Pressure p / Pa.
+
+    h : float
+        Specific enthalpy h / (J/kg).
+
+    fluid : str
+        Fluid name.
+
+    Returns
+    -------
+    T : float
+        Temperature T / K.
+    """
+    # region 1 exclusive issue!
+    Memorise.state[fluid].update(CP.HmassP_INPUTS, h, p)
+    if p <= 16.529164252605 * 1e6:
+        h_at_ph = Memorise.state[fluid].hmass()
+        deviation = abs(h_at_ph - h)
+        if deviation / h > 0.001:
+            # region 1, where isenthalpic lines are tangent to saturation dome
+            if p > 1e6 and p < 1e7 and h > 2700000 and h < 2850000:
+                smin = 5750
+                smax = 6500
+            # bottom left corner in Ts diagram
+            elif h < 10000:
+                smin = 0
+                smax = 50
+            else:
+                # proximity to saturated liquid
+                Memorise.state[fluid].update(CP.PQ_INPUTS, p, 0)
+                h_sat_l = Memorise.state[fluid].hmass()
+                if abs(h - h_sat_l) / h_sat_l < 1e-1:
+                    if p < 1000:
+                        smin = 0
+                    elif p < 60000:
+                        smin = Memorise.state[fluid].smass() * 0.9
+                    else:
+                        smin = Memorise.state[fluid].smass() * 0.95
+
+                    Memorise.state[fluid].update(CP.PQ_INPUTS, p, 0.3)
+                    smax = Memorise.state[fluid].smass()
+                # all others
+                else:
+                    Memorise.state[fluid].update(CP.HmassP_INPUTS, h, p)
+                    s0 = Memorise.state[fluid].smass()
+                    smin = 0.8 * s0
+                    smax = 1.2 * s0
+
+            s0 = (smax + smin) / 2
+            s = newton(func=h_ps_IF97, deriv=dh_pds_IF97, params=[fluid, p],
+                       y=h, val0=s0, valmin=smin, valmax=smax, max_iter=5,
+                       tol_rel=1e-3, tol_mode='rel')
+            Memorise.state[fluid].update(CP.PSmass_INPUTS, p, s)
+
+    if output == 'T':
+        return Memorise.state[fluid].T()
+    elif output == 's':
+        return Memorise.state[fluid].smass()
+    elif output == 'rho':
+        return Memorise.state[fluid].rhomass()
+    else:
+        return Memorise.state[fluid].viscosity()
```

### Comparing `TESPy-0.6.2/src/tespy/tools/global_vars.py` & `TESPy-0.6.3/src/tespy/tools/global_vars.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,101 +1,103 @@
-# -*- coding: utf-8
-
-"""Module for global variables used by other modules of the tespy package.
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location tespy/tools/global_vars.py
-
-SPDX-License-Identifier: MIT
-"""
-
-err = 1e-6
-molar_masses = {}
-gas_constants = {}
-gas_constants['uni'] = 8.314462618
-
-fluid_property_data = {
-    'm': {
-        'text': 'mass flow',
-        'SI_unit': 'kg / s',
-        'units': {
-            'kg / s': 1, 'kg / min': 1 / 60, 'kg / h': 1 / 3.6e3,
-            't / h': 1 / 3.6, 'g / s': 1 / 1e3
-        },
-        'latex_eq': r'0 = \dot{m} - \dot{m}_\mathrm{spec}',
-        'documentation': {'float_fmt': '{:,.3f}'}
-    },
-    'v': {
-        'text': 'volumetric flow',
-        'SI_unit': 'm3 / s',
-        'units': {
-            'm3 / s': 1, 'm3 / min': 1 / 60, 'm3 / h': 1 / 3.6e3,
-            'l / s': 1 / 1e3, 'l / min': 1 / 60e3, 'l / h': 1 / 3.6e6
-        },
-        'latex_eq': (
-            r'0 = \dot{m} \cdot v \left(p,h\right)- \dot{V}_\mathrm{spec}'),
-        'documentation': {'float_fmt': '{:,.3f}'}
-    },
-    'p': {
-        'text': 'pressure',
-        'SI_unit': 'Pa',
-        'units': {
-            'Pa': 1, 'kPa': 1e3, 'psi': 6.8948e3,
-            'bar': 1e5, 'atm': 1.01325e5, 'MPa': 1e6
-        },
-        'latex_eq': r'0 = p - p_\mathrm{spec}',
-        'documentation': {'float_fmt': '{:,.3f}'}
-    },
-    'h': {
-        'text': 'enthalpy',
-        'SI_unit': 'J / kg',
-        'units': {
-            'J / kg': 1, 'kJ / kg': 1e3, 'MJ / kg': 1e6,
-            'cal / kg': 4.184, 'kcal / kg': 4.184e3,
-            'Wh / kg': 3.6e3, 'kWh / kg': 3.6e6
-        },
-        'latex_eq': r'0 = h - h_\mathrm{spec}',
-        'documentation': {'float_fmt': '{:,.3f}'}
-    },
-    'T': {
-        'text': 'temperature',
-        'SI_unit': 'K',
-        'units': {
-            'K': [0, 1], 'R': [0, 5 / 9],
-            'C': [273.15, 1], 'F': [459.67, 5 / 9]
-        },
-        'latex_eq': r'0 = T \left(p, h \right) - T_\mathrm{spec}',
-        'documentation': {'float_fmt': '{:,.1f}'}
-    },
-    'Td_bp': {
-        'text': 'temperature difference to boiling point',
-        'SI_unit': 'K',
-        'units': {
-            'K': 1, 'R': 5 / 9, 'C': 1, 'F': 5 / 9
-        },
-        'latex_eq': r'0 = \Delta T_\mathrm{spec}- T_\mathrm{sat}\left(p\right)',
-        'documentation': {'float_fmt': '{:,.1f}'}
-    },
-    'vol': {
-        'text': 'specific volume',
-        'SI_unit': 'm3 / kg',
-        'units': {'m3 / kg': 1, 'l / kg': 1e-3},
-        'latex_eq': (
-            r'0 = v\left(p,h\right) \cdot \dot{m} - \dot{V}_\mathrm{spec}'),
-        'documentation': {'float_fmt': '{:,.3f}'}
-    },
-    'x': {
-        'text': 'vapor mass fraction',
-        'SI_unit': '-',
-        'units': {'-': 1, '%': 1e-2, 'ppm': 1e-6},
-        'latex_eq': r'0 = h - h\left(p, x_\mathrm{spec}\right)',
-        'documentation': {'float_fmt': '{:,.2f}'}
-    },
-    's': {
-        'text': 'entropy',
-        'SI_unit': 'J / kgK',
-        'units': {'J / kgK': 1, 'kJ / kgK': 1e3, 'MJ / kgK': 1e6},
-        'latex_eq': r'0 = s_\mathrm{spec} - s\left(p, h \right)',
-        'documentation': {'float_fmt': '{:,.2f}'}
-    }
-}
+# -*- coding: utf-8
+
+"""Module for global variables used by other modules of the tespy package.
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location tespy/tools/global_vars.py
+
+SPDX-License-Identifier: MIT
+"""
+
+err = 1e-6
+molar_masses = {}
+gas_constants = {}
+gas_constants['uni'] = 8.314462618
+
+fluid_property_data = {
+    'm': {
+        'text': 'mass flow',
+        'SI_unit': 'kg / s',
+        'units': {
+            'kg / s': 1, 'kg / min': 1 / 60, 'kg / h': 1 / 3.6e3,
+            't / h': 1 / 3.6, 'g / s': 1 / 1e3
+        },
+        'latex_eq': r'0 = \dot{m} - \dot{m}_\mathrm{spec}',
+        'documentation': {'float_fmt': '{:,.3f}'}
+    },
+    'v': {
+        'text': 'volumetric flow',
+        'SI_unit': 'm3 / s',
+        'units': {
+            'm3 / s': 1, 'm3 / min': 1 / 60, 'm3 / h': 1 / 3.6e3,
+            'l / s': 1 / 1e3, 'l / min': 1 / 60e3, 'l / h': 1 / 3.6e6
+        },
+        'latex_eq': (
+            r'0 = \dot{m} \cdot v \left(p,h\right)- \dot{V}_\mathrm{spec}'),
+        'documentation': {'float_fmt': '{:,.3f}'}
+    },
+    'p': {
+        'text': 'pressure',
+        'SI_unit': 'Pa',
+        'units': {
+            'Pa': 1, 'kPa': 1e3, 'psi': 6.8948e3,
+            'bar': 1e5, 'atm': 1.01325e5, 'MPa': 1e6
+        },
+        'latex_eq': r'0 = p - p_\mathrm{spec}',
+        'documentation': {'float_fmt': '{:,.3f}'}
+    },
+    'h': {
+        'text': 'enthalpy',
+        'SI_unit': 'J / kg',
+        'units': {
+            'J / kg': 1, 'kJ / kg': 1e3, 'MJ / kg': 1e6,
+            'cal / kg': 4.184, 'kcal / kg': 4.184e3,
+            'Wh / kg': 3.6e3, 'kWh / kg': 3.6e6
+        },
+        'latex_eq': r'0 = h - h_\mathrm{spec}',
+        'documentation': {'float_fmt': '{:,.3f}'}
+    },
+    'T': {
+        'text': 'temperature',
+        'SI_unit': 'K',
+        'units': {
+            'K': [0, 1], 'R': [0, 5 / 9],
+            'C': [273.15, 1], 'F': [459.67, 5 / 9]
+        },
+        'latex_eq': r'0 = T \left(p, h \right) - T_\mathrm{spec}',
+        'documentation': {'float_fmt': '{:,.1f}'}
+    },
+    'Td_bp': {
+        'text': 'temperature difference to boiling point',
+        'SI_unit': 'K',
+        'units': {
+            'K': 1, 'R': 5 / 9, 'C': 1, 'F': 5 / 9
+        },
+        'latex_eq': r'0 = \Delta T_\mathrm{spec}- T_\mathrm{sat}\left(p\right)',
+        'documentation': {'float_fmt': '{:,.1f}'}
+    },
+    'vol': {
+        'text': 'specific volume',
+        'SI_unit': 'm3 / kg',
+        'units': {'m3 / kg': 1, 'l / kg': 1e-3},
+        'latex_eq': (
+            r'0 = v\left(p,h\right) \cdot \dot{m} - \dot{V}_\mathrm{spec}'),
+        'documentation': {'float_fmt': '{:,.3f}'}
+    },
+    'x': {
+        'text': 'vapor mass fraction',
+        'SI_unit': '-',
+        'units': {'-': 1, '%': 1e-2, 'ppm': 1e-6},
+        'latex_eq': r'0 = h - h\left(p, x_\mathrm{spec}\right)',
+        'documentation': {'float_fmt': '{:,.2f}'}
+    },
+    's': {
+        'text': 'entropy',
+        'SI_unit': 'J / kgK',
+        'units': {'J / kgK': 1, 'kJ / kgK': 1e3, 'MJ / kgK': 1e6},
+        'latex_eq': r'0 = s_\mathrm{spec} - s\left(p, h \right)',
+        'documentation': {'float_fmt': '{:,.2f}'}
+    }
+}
+
+combustion_gases = ['methane', 'ethane', 'propane', 'butane', 'hydrogen', 'nDodecane']
```

### Comparing `TESPy-0.6.2/src/tespy/tools/helpers.py` & `TESPy-0.6.3/src/tespy/tools/helpers.py`

 * *Files 2% similar despite different names*

```diff
@@ -4,28 +4,43 @@
 
 This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
 by the contributors recorded in the version control history of the file,
 available from its original location tespy/tools/helpers.py
 
 SPDX-License-Identifier: MIT
 """
-import logging
+
+import json
 import os
 from collections import OrderedDict
 from collections.abc import Mapping
 from copy import deepcopy
 
-import CoolProp as CP
+import CoolProp.CoolProp as CP
 import numpy as np
 
+from tespy import __datapath__
+from tespy.tools import logger
 from tespy.tools.global_vars import err
 from tespy.tools.global_vars import fluid_property_data
 from tespy.tools.global_vars import molar_masses
 
 
+def get_chem_ex_lib(name):
+    """Return a new dictionary by merging two dictionaries recursively."""
+    path = os.path.join(__datapath__, "ChemEx", f"{name}.json")
+    with open(path, "r") as f:
+        return json.load(f)
+
+
+def fluidalias_in_list(fluid, fluid_list):
+    aliases = [alias.replace(' ', '') for alias in CP.get_aliases(fluid)]
+    return any(alias in fluid_list for alias in aliases)
+
+
 def merge_dicts(dict1, dict2):
     """Return a new dictionary by merging two dictionaries recursively."""
 
     result = deepcopy(dict1)
 
     for key, value in dict2.items():
         if isinstance(value, Mapping):
@@ -313,46 +328,46 @@
         >>> round(inflow.v.val, 3)
         0.067
         """
         if isinstance(label, str):
             self.label = label
         else:
             msg = 'Label of UserDefinedEquation object must be of type String.'
-            logging.error(msg)
+            logger.error(msg)
             raise TypeError(msg)
 
         if isinstance(conns, list):
             self.conns = conns
         else:
             msg = (
                 'Parameter conns must be a list of '
                 'tespy.connections.connection.Connection objects.')
-            logging.error(msg)
+            logger.error(msg)
             raise TypeError(msg)
 
         self.func = func
         self.deriv = deriv
 
         if isinstance(params, dict):
             self.params = params
         else:
             msg = 'The parameter params must be passed as dictionary.'
-            logging.error(msg)
+            logger.error(msg)
             raise TypeError(msg)
 
         self.latex = {
             'equation': r'\text{equation string not available}',
             'lines': [],
             'maps': []
         }
         if isinstance(latex, dict):
             self.latex.update(latex)
         else:
             msg = 'The parameter latex must be passed as dictionary.'
-            logging.error(msg)
+            logger.error(msg)
             raise TypeError(msg)
 
     def numeric_deriv(self, param, idx):
         r"""
         Calculate partial derivative of the function func to dx numerically.
 
         Parameters
@@ -408,15 +423,15 @@
 
             deriv = exp / (2 * d)
 
         else:
             msg = (
                 'Can only calculate numerical derivative to primary variables.'
                 'Please specify "m", "p", "h" or "fluid" as param.')
-            logging.error(msg)
+            logger.error(msg)
             raise ValueError(msg)
 
         return deriv
 
 
 def newton(func, deriv, params, y, **kwargs):
     r"""
@@ -502,15 +517,15 @@
         i += 1
 
         if i > max_iter:
             msg = ('Newton algorithm was not able to find a feasible value '
                    'for function ' + str(func) + '. Current value with x=' +
                    str(x) + ' is ' + str(func(params, x)) +
                    ', target value is ' + str(y) + '.')
-            logging.debug(msg)
+            logger.debug(msg)
 
             break
         if tol_mode == 'abs':
             expr = abs(res) >= tol_abs
         elif tol_mode == 'rel':
             expr = abs(res / y) >= tol_rel
         else:
@@ -712,15 +727,15 @@
 
     >>> from tespy.tools.helpers import fluid_structure
     >>> elements = fluid_structure('methane')
     >>> elements['C'], elements['H']
     (1, 4)
     """
     parts = {}
-    for element in CP.CoolProp.get_fluid_param_string(
+    for element in CP.get_fluid_param_string(
             fluid, 'formula').split('}'):
         if element != '':
             el = element.split('_{')
             parts[el[0]] = int(el[1])
 
     return parts
```

### Comparing `TESPy-0.6.2/src/tespy/tools/optimization.py` & `TESPy-0.6.3/src/tespy/tools/optimization.py`

 * *Files 1% similar despite different names*

```diff
@@ -285,15 +285,17 @@
                 print(
                     self.variable_list[i] + ': {}'.format(
                         round(pop.champion_x[i], 4)
                     )
                 )
             pop = algo.evolve(pop)
 
-        gen += 1
+        if num_gen > 1:
+            gen += 1
+
         self._process_generation_data(gen, pop)
 
         print('Final evolution: {}'.format(gen))
         for i in range(len(self.objective_list)):
             print(
                 self.objective_list[i] + ': {}'.format(
                     round(pop.champion_f[i], 4)
```

### Comparing `TESPy-0.6.2/tests/test_analyses/test_entropy_analysis.py` & `TESPy-0.6.3/tests/test_analyses/test_entropy_analysis.py`

 * *Files 13% similar despite different names*

```diff
@@ -1,113 +1,107 @@
-# -*- coding: utf-8
-
-"""Module for testing network properties.
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location
-tests/test_networks/test_exergy_and_entropy_analysis.py
-
-SPDX-License-Identifier: MIT
-"""
-from tespy.components import CycleCloser
-from tespy.components import HeatExchangerSimple
-from tespy.components import Merge
-from tespy.components import Pump
-from tespy.components import Splitter
-from tespy.components import Turbine
-from tespy.connections import Bus
-from tespy.connections import Connection
-from tespy.networks import Network
-
-
-def convergence_check(lin_dep):
-    """Check convergence status of a simulation."""
-    msg = 'Calculation did not converge!'
-    assert lin_dep is False, msg
-
-
-class TestClausiusRankine:
-
-    def setup(self):
-        """Set up clausis rankine cycle with turbine driven feed water pump."""
-        self.Tamb = 20
-        self.pamb = 1
-        fluids = ['water']
-        self.nw = Network(fluids=fluids)
-        self.nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg')
-
-        # create components
-        splitter1 = Splitter('splitter 1')
-        merge1 = Merge('merge 1')
-        turb = Turbine('turbine')
-        fwp_turb = Turbine('feed water pump turbine')
-        condenser = HeatExchangerSimple('condenser')
-        fwp = Pump('pump')
-        steam_generator = HeatExchangerSimple('steam generator')
-        cycle_close = CycleCloser('cycle closer')
-
-        # create busses
-        # power output bus
-        self.power = Bus('power_output')
-        self.power.add_comps({'comp': turb, 'char': 1})
-        # turbine driven feed water pump internal bus
-        self.fwp_power = Bus('feed water pump power', P=0)
-        self.fwp_power.add_comps(
-            {'comp': fwp_turb, 'char': 1},
-            {'comp': fwp, 'char': 1, 'base': 'bus'})
-        # heat input bus
-        self.heat = Bus('heat_input')
-        self.heat.add_comps({'comp': steam_generator, 'base': 'bus'})
-        self.nw.add_busses(self.power, self.fwp_power, self.heat)
-
-        # create connections
-        fs_in = Connection(cycle_close, 'out1', splitter1, 'in1', label='fs')
-        fs_fwpt = Connection(splitter1, 'out1', fwp_turb, 'in1')
-        fs_t = Connection(splitter1, 'out2', turb, 'in1')
-        fwpt_ws = Connection(fwp_turb, 'out1', merge1, 'in1')
-        t_ws = Connection(turb, 'out1', merge1, 'in2')
-        ws = Connection(merge1, 'out1', condenser, 'in1')
-        cond = Connection(condenser, 'out1', fwp, 'in1', label='cond')
-        fw = Connection(fwp, 'out1', steam_generator, 'in1', label='fw')
-        fs_out = Connection(steam_generator, 'out1', cycle_close, 'in1')
-        self.nw.add_conns(fs_in, fs_fwpt, fs_t, fwpt_ws, t_ws, ws, cond, fw,
-                          fs_out)
-
-        # component parameters
-        turb.set_attr(eta_s=1)
-        fwp_turb.set_attr(eta_s=1)
-        condenser.set_attr(pr=1)
-        fwp.set_attr(eta_s=1)
-        steam_generator.set_attr(pr=1)
-
-        # connection parameters
-        fs_in.set_attr(m=10, p=120, T=600, fluid={'water': 1})
-        cond.set_attr(T=self.Tamb, x=0)
-
-        # solve network
-        self.nw.solve('design')
-        for cp in self.nw.comps['object']:
-            cp.entropy_balance()
-        convergence_check(self.nw.lin_dep)
-
-    def test_entropy_perfect_cycle(self):
-        """Test entropy values in the perfect clausius rankine cycle."""
-        labels = [
-            'turbine', 'feed water pump turbine', 'condenser',
-            'steam generator', 'pump'
-        ]
-        for label in labels:
-            cp = self.nw.get_comp(label)
-            msg = (
-                'Entropy production due to irreversibility must be 0 for all '
-                'components in this test but is ' + str(round(cp.S_irr, 4)) +
-                ' at component ' + label + ' of type ' + cp.component() + '.')
-            assert round(cp.S_irr, 4) == 0, msg
-        sg = self.nw.get_comp('steam generator')
-        cd = self.nw.get_comp('condenser')
-        msg = (
-            'Value of entropy production due to heat input at steam generator '
-            '(S_Q=' + str(round(sg.S_Q, 4)) + ') must equal the negative '
-            'value of entropy reduction in condenser (S_Q=' +
-            str(round(cd.S_Q, 4)) + ').')
-        assert round(sg.S_Q, 4) == -round(cd.S_Q, 4), msg
+# -*- coding: utf-8
+
+"""Module for testing network properties.
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location
+tests/test_networks/test_exergy_and_entropy_analysis.py
+
+SPDX-License-Identifier: MIT
+"""
+from tespy.components import CycleCloser
+from tespy.components import Merge
+from tespy.components import Pump
+from tespy.components import SimpleHeatExchanger
+from tespy.components import Splitter
+from tespy.components import Turbine
+from tespy.connections import Bus
+from tespy.connections import Connection
+from tespy.networks import Network
+
+
+class TestClausiusRankine:
+
+    def setup_method(self):
+        """Set up clausis rankine cycle with turbine driven feed water pump."""
+        self.Tamb = 20
+        self.pamb = 1
+        fluids = ['water']
+        self.nw = Network(fluids=fluids)
+        self.nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg')
+
+        # create components
+        splitter1 = Splitter('splitter 1')
+        merge1 = Merge('merge 1')
+        turb = Turbine('turbine')
+        fwp_turb = Turbine('feed water pump turbine')
+        condenser = SimpleHeatExchanger('condenser')
+        fwp = Pump('pump')
+        steam_generator = SimpleHeatExchanger('steam generator')
+        cycle_close = CycleCloser('cycle closer')
+
+        # create busses
+        # power output bus
+        self.power = Bus('power_output')
+        self.power.add_comps({'comp': turb, 'char': 1})
+        # turbine driven feed water pump internal bus
+        self.fwp_power = Bus('feed water pump power', P=0)
+        self.fwp_power.add_comps(
+            {'comp': fwp_turb, 'char': 1},
+            {'comp': fwp, 'char': 1, 'base': 'bus'})
+        # heat input bus
+        self.heat = Bus('heat_input')
+        self.heat.add_comps({'comp': steam_generator, 'base': 'bus'})
+        self.nw.add_busses(self.power, self.fwp_power, self.heat)
+
+        # create connections
+        fs_in = Connection(cycle_close, 'out1', splitter1, 'in1', label='fs')
+        fs_fwpt = Connection(splitter1, 'out1', fwp_turb, 'in1')
+        fs_t = Connection(splitter1, 'out2', turb, 'in1')
+        fwpt_ws = Connection(fwp_turb, 'out1', merge1, 'in1')
+        t_ws = Connection(turb, 'out1', merge1, 'in2')
+        ws = Connection(merge1, 'out1', condenser, 'in1')
+        cond = Connection(condenser, 'out1', fwp, 'in1', label='cond')
+        fw = Connection(fwp, 'out1', steam_generator, 'in1', label='fw')
+        fs_out = Connection(steam_generator, 'out1', cycle_close, 'in1')
+        self.nw.add_conns(fs_in, fs_fwpt, fs_t, fwpt_ws, t_ws, ws, cond, fw,
+                          fs_out)
+
+        # component parameters
+        turb.set_attr(eta_s=1)
+        fwp_turb.set_attr(eta_s=1)
+        condenser.set_attr(pr=1)
+        fwp.set_attr(eta_s=1)
+        steam_generator.set_attr(pr=1)
+
+        # connection parameters
+        fs_in.set_attr(m=10, p=120, T=600, fluid={'water': 1})
+        cond.set_attr(T=self.Tamb, x=0)
+
+        # solve network
+        self.nw.solve('design')
+        for cp in self.nw.comps['object']:
+            cp.entropy_balance()
+        self.nw._convergence_check()
+
+    def test_entropy_perfect_cycle(self):
+        """Test entropy values in the perfect clausius rankine cycle."""
+        labels = [
+            'turbine', 'feed water pump turbine', 'condenser',
+            'steam generator', 'pump'
+        ]
+        for label in labels:
+            cp = self.nw.get_comp(label)
+            msg = (
+                'Entropy production due to irreversibility must be 0 for all '
+                'components in this test but is ' + str(round(cp.S_irr, 4)) +
+                ' at component ' + label + ' of type ' + cp.component() + '.')
+            assert round(cp.S_irr, 4) == 0, msg
+        sg = self.nw.get_comp('steam generator')
+        cd = self.nw.get_comp('condenser')
+        msg = (
+            'Value of entropy production due to heat input at steam generator '
+            '(S_Q=' + str(round(sg.S_Q, 4)) + ') must equal the negative '
+            'value of entropy reduction in condenser (S_Q=' +
+            str(round(cd.S_Q, 4)) + ').')
+        assert round(sg.S_Q, 4) == -round(cd.S_Q, 4), msg
```

### Comparing `TESPy-0.6.2/tests/test_analyses/test_exergy_analysis.py` & `TESPy-0.6.3/tests/test_analyses/test_exergy_analysis.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,631 +1,641 @@
-# -*- coding: utf-8
-
-"""Module for testing network properties.
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location
-tests/test_networks/test_exergy_and_entropy_analysis.py
-
-SPDX-License-Identifier: MIT
-"""
-
-from pytest import raises
-
-from tespy.components import Compressor
-from tespy.components import CycleCloser
-from tespy.components import HeatExchangerSimple
-from tespy.components import Merge
-from tespy.components import Pump
-from tespy.components import Sink
-from tespy.components import Source
-from tespy.components import Splitter
-from tespy.components import Turbine
-from tespy.components import Valve
-from tespy.connections import Bus
-from tespy.connections import Connection
-from tespy.networks import Network
-from tespy.tools import ExergyAnalysis
-from tespy.tools.global_vars import err
-from tespy.tools.helpers import TESPyNetworkError
-
-
-def convergence_check(lin_dep):
-    """Check convergence status of a simulation."""
-    msg = 'Calculation did not converge!'
-    assert lin_dep is False, msg
-
-
-class TestClausiusRankine:
-
-    def setup(self):
-        """Set up clausis rankine cycle with turbine driven feed water pump."""
-        self.Tamb = 20
-        self.pamb = 1
-        fluids = ['water']
-        self.nw = Network(fluids=fluids)
-        self.nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg')
-
-        # create components
-        splitter1 = Splitter('splitter 1')
-        merge1 = Merge('merge 1')
-        turb = Turbine('turbine')
-        fwp_turb = Turbine('feed water pump turbine')
-        condenser = HeatExchangerSimple('condenser')
-        fwp = Pump('pump')
-        steam_generator = HeatExchangerSimple('steam generator')
-        cycle_close = CycleCloser('cycle closer')
-
-        # create busses
-        # power output bus
-        self.power = Bus('power_output')
-        self.power.add_comps({'comp': turb, 'char': 1})
-        # turbine driven feed water pump internal bus
-        self.fwp_power = Bus('feed water pump power', P=0)
-        self.fwp_power.add_comps(
-            {'comp': fwp_turb, 'char': 1},
-            {'comp': fwp, 'char': 1, 'base': 'bus'})
-        # heat input bus
-        self.heat = Bus('heat_input')
-        self.heat.add_comps({'comp': steam_generator, 'base': 'bus'})
-        self.nw.add_busses(self.power, self.fwp_power, self.heat)
-
-        # create connections
-        fs_in = Connection(cycle_close, 'out1', splitter1, 'in1', label='fs')
-        fs_fwpt = Connection(splitter1, 'out1', fwp_turb, 'in1')
-        fs_t = Connection(splitter1, 'out2', turb, 'in1')
-        fwpt_ws = Connection(fwp_turb, 'out1', merge1, 'in1')
-        t_ws = Connection(turb, 'out1', merge1, 'in2')
-        ws = Connection(merge1, 'out1', condenser, 'in1')
-        cond = Connection(condenser, 'out1', fwp, 'in1', label='cond')
-        fw = Connection(fwp, 'out1', steam_generator, 'in1', label='fw')
-        fs_out = Connection(steam_generator, 'out1', cycle_close, 'in1')
-        self.nw.add_conns(fs_in, fs_fwpt, fs_t, fwpt_ws, t_ws, ws, cond, fw,
-                          fs_out)
-
-        # component parameters
-        turb.set_attr(eta_s=1)
-        fwp_turb.set_attr(eta_s=1)
-        condenser.set_attr(pr=1)
-        fwp.set_attr(eta_s=1)
-        steam_generator.set_attr(pr=1)
-
-        # connection parameters
-        fs_in.set_attr(m=10, p=120, T=600, fluid={'water': 1})
-        cond.set_attr(T=self.Tamb, x=0)
-
-        # solve network
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-
-    def test_exergy_analysis_perfect_cycle(self):
-        """Test exergy analysis in the perfect clausius rankine cycle."""
-        ean = ExergyAnalysis(
-            self.nw, E_P=[self.power], E_F=[self.heat],
-            internal_busses=[self.fwp_power])
-        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
-        msg = (
-            'Exergy destruction of this network must be 0 (smaller than ' +
-            str(err ** 0.5) + ') for this test but is ' +
-            str(round(abs(ean.network_data.E_D), 4)) + ' .')
-        assert abs(ean.network_data.E_D) <= err ** 0.5, msg
-
-        msg = (
-            'Exergy efficiency of this network must be 1 for this test but '
-            'is ' + str(round(ean.network_data.epsilon, 4)) + ' .')
-        assert round(ean.network_data.epsilon, 4) == 1, msg
-
-        exergy_balance = (
-            ean.network_data.E_F - ean.network_data.E_P -
-            ean.network_data.E_L - ean.network_data.E_D)
-        msg = (
-            'Exergy balance must be closed (residual value smaller than ' +
-            str(err ** 0.5) + ') for this test but is ' +
-            str(round(abs(exergy_balance), 4)) + ' .')
-        assert abs(exergy_balance) <= err ** 0.5, msg
-
-        msg = (
-            'Fuel exergy and product exergy must be identical for this test. '
-            'Fuel exergy value: ' + str(round(ean.network_data.E_F, 4)) +
-            '. Product exergy value: ' + str(round(ean.network_data.E_P, 4)) +
-            '.')
-        delta = round(abs(ean.network_data.E_F - ean.network_data.E_P), 4)
-        assert delta < err ** 0.5, msg
-
-    def test_exergy_analysis_plotting_data(self):
-        """Test exergy analysis plotting."""
-        self.nw.get_comp('steam generator').set_attr(pr=0.9)
-        self.nw.get_comp('turbine').set_attr(eta_s=0.9)
-        self.nw.get_comp('feed water pump turbine').set_attr(eta_s=0.85)
-        self.nw.get_comp('pump').set_attr(eta_s=0.75)
-        self.nw.get_conn('cond').set_attr(T=self.Tamb + 3)
-
-        # specify efficiency values for the internal bus and power bus
-        self.nw.del_busses(self.fwp_power, self.power)
-
-        self.fwp_power = Bus('feed water pump power', P=0)
-        self.fwp_power.add_comps(
-            {'comp': self.nw.get_comp('feed water pump turbine'),
-             'char': 0.99},
-            {'comp': self.nw.get_comp('pump'), 'char': 0.98, 'base': 'bus'})
-        self.power = Bus('power_output')
-        self.power.add_comps(
-            {'comp': self.nw.get_comp('turbine'), 'char': 0.98})
-
-        self.nw.add_busses(self.fwp_power, self.power)
-
-        # solve network
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        ean = ExergyAnalysis(
-            self.nw, E_P=[self.power], E_F=[self.heat],
-            internal_busses=[self.fwp_power])
-        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
-
-        exergy_balance = (
-            ean.network_data.E_F - ean.network_data.E_P -
-            ean.network_data.E_L - ean.network_data.E_D)
-        msg = (
-            'Exergy balance must be closed (residual value smaller than ' +
-            str(err ** 0.5) + ') for this test but is ' +
-            str(round(abs(exergy_balance), 4)) + ' .')
-        assert abs(exergy_balance) <= err ** 0.5, msg
-
-        nodes = [
-            'E_F', 'steam generator', 'splitter 1', 'feed water pump turbine',
-            'turbine', 'merge 1', 'condenser', 'pump', 'E_D', 'E_P']
-
-        links, nodes = ean.generate_plotly_sankey_input(node_order=nodes)
-        # checksum for targets and source
-        checksum = sum(links['target'] + links['source'])
-        msg = (
-            'The checksum of all target and source values in the link lists'
-            'must be 148, but is ' + str(checksum) + '.')
-        assert 148 == checksum, msg
-
-    def test_exergy_analysis_violated_balance(self):
-        """Test exergy analysis with violated balance."""
-        # specify efficiency values for the internal bus
-        self.nw.del_busses(self.fwp_power)
-        self.fwp_power = Bus('feed water pump power', P=0)
-        self.fwp_power.add_comps(
-            {'comp': self.nw.get_comp('feed water pump turbine'),
-             'char': 0.99},
-            {'comp': self.nw.get_comp('pump'), 'char': 0.98, 'base': 'bus'})
-        self.nw.add_busses(self.fwp_power)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        # miss out on internal bus in exergy_analysis
-        ean = ExergyAnalysis(
-            self.nw, E_P=[self.power], E_F=[self.heat])
-        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
-
-        exergy_balance = (
-            ean.network_data.E_F - ean.network_data.E_P -
-            ean.network_data.E_L - ean.network_data.E_D)
-        msg = (
-            'Exergy balance must be violated for this test (larger than ' +
-            str(err ** 0.5) + ') but is ' +
-            str(round(abs(exergy_balance), 4)) + ' .')
-        assert abs(exergy_balance) > err ** 0.5, msg
-
-    def test_exergy_analysis_bus_conversion(self):
-        """Test exergy analysis bus conversion factors."""
-        # specify efficiency values for the internal bus
-        self.nw.del_busses(self.fwp_power)
-        self.fwp_power = Bus('feed water pump power', P=0)
-        self.fwp_power.add_comps(
-            {'comp': self.nw.get_comp('feed water pump turbine'),
-             'char': 0.99},
-            {'comp': self.nw.get_comp('pump'), 'char': 0.98, 'base': 'bus'})
-        self.nw.add_busses(self.fwp_power)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        # no exergy losses in this case
-        ean = ExergyAnalysis(
-            self.nw, E_P=[self.power], E_F=[self.heat],
-            internal_busses=[self.fwp_power])
-        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
-
-        label = 'pump'
-        eps = ean.bus_data.loc[label, 'epsilon']
-        msg = (
-            'Pump exergy efficiency must be 0.98 but is ' +
-            str(round(eps, 4)) + ' .')
-        assert round(eps, 4) == 0.98, msg
-
-        label = 'feed water pump turbine'
-        eps = ean.bus_data.loc[label, 'epsilon']
-        msg = (
-            'Feed water pump turbine exergy efficiency must be 0.99 but is ' +
-            str(round(eps, 4)) + ' .')
-        assert round(eps, 4) == 0.99, msg
-
-    def test_exergy_analysis_missing_E_F_E_P_information(self):
-        """Test exergy analysis errors with missing information."""
-        with raises(TESPyNetworkError):
-            ExergyAnalysis(self.nw, E_P=[self.power], E_F=[])
-
-        with raises(TESPyNetworkError):
-            ExergyAnalysis(self.nw, E_P=[], E_F=[self.heat])
-
-    def test_exergy_analysis_component_on_two_busses(self):
-        """Test exergy analysis errors with components on more than one bus."""
-        with raises(TESPyNetworkError):
-            ean = ExergyAnalysis(
-                self.nw, E_P=[self.power], E_F=[self.heat, self.power])
-            ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
-
-
-class TestRefrigerator:
-
-    def setup(self):
-        """Set up simple refrigerator."""
-        self.Tamb = 20
-        self.pamb = 1
-        fluids = ['R134a']
-        self.nw = Network(fluids=fluids)
-        self.nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg')
-
-        # create components
-        va = Valve('expansion valve')
-        cp = Compressor('compressor')
-        cond = HeatExchangerSimple('condenser')
-        eva = HeatExchangerSimple('evaporator')
-        cc = CycleCloser('cycle closer')
-
-        # create busses
-        # power output bus
-        self.power = Bus('power input')
-        self.power.add_comps({'comp': cp, 'char': 1, 'base': 'bus'})
-        # cooling bus
-        self.cool = Bus('heat from fridge')
-        self.cool.add_comps({'comp': eva})
-        # heat input bus
-        self.heat = Bus('heat to ambient')
-        self.heat.add_comps({'comp': cond})
-        self.nw.add_busses(self.power, self.cool, self.heat)
-
-        # create connections
-        cc_cp = Connection(cc, 'out1', cp, 'in1', label='from eva')
-        cp_cond = Connection(cp, 'out1', cond, 'in1', label='to cond')
-        cond_va = Connection(cond, 'out1', va, 'in1', label='from cond')
-        va_eva = Connection(va, 'out1', eva, 'in1', label='to eva')
-        eva_cc = Connection(eva, 'out1', cc, 'in1')
-        self.nw.add_conns(cc_cp, cp_cond, cond_va, va_eva, eva_cc)
-
-        # component parameters
-        cp.set_attr(eta_s=0.9)
-        cond.set_attr(pr=0.97)
-        eva.set_attr(pr=0.96)
-
-        # connection parameters
-        cc_cp.set_attr(m=1, x=1, T=-25, fluid={'R134a': 1})
-        cond_va.set_attr(x=0, T=self.Tamb + 1)
-
-        # solve network
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-
-    def test_exergy_analysis_bus_conversion(self):
-        """Test exergy analysis at product exergy with T < Tamb."""
-        # no exergy losses in this case
-        ean = ExergyAnalysis(self.nw, E_P=[self.cool], E_F=[self.power])
-        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
-
-        exergy_balance = (
-            ean.network_data.E_F - ean.network_data.E_P -
-            ean.network_data.E_L - ean.network_data.E_D)
-        msg = (
-            'Exergy balance must be closed (residual value smaller than ' +
-            str(err ** 0.5) + ') for this test but is ' +
-            str(round(abs(exergy_balance), 4)) + ' .')
-        assert abs(exergy_balance) <= err ** 0.5, msg
-
-
-class TestCompressedAirIn:
-
-    def setup(self):
-        """Set up air compressor."""
-        self.Tamb = 20
-        self.pamb = 1
-        fluids = ['Air']
-
-        # compressor part
-        self.nw = Network(fluids=fluids)
-        self.nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg')
-
-        # components
-        amb = Source('air intake')
-        cp = Compressor('compressor')
-        cooler = HeatExchangerSimple('cooling')
-        cas = Sink('compressed air storage')
-
-        # power input bus
-        self.power_in = Bus('power input')
-        self.power_in.add_comps({'comp': cp, 'char': 1, 'base': 'bus'})
-        # compressed air bus (not sure about this!)
-        self.cas_in = Bus('massflow into storage')
-        self.cas_in.add_comps({'comp': cas}, {'comp': amb, 'base': 'bus'})
-        self.nw.add_busses(self.power_in, self.cas_in)
-
-        # create connections
-        amb_cp = Connection(amb, 'out1', cp, 'in1')
-        cp_cool = Connection(cp, 'out1', cooler, 'in1')
-        cool_cas = Connection(cooler, 'out1', cas, 'in1')
-        self.nw.add_conns(amb_cp, cp_cool, cool_cas)
-
-        # component parameters
-        cp.set_attr(eta_s=1)
-        cooler.set_attr(pr=1)
-
-        # connection parameters
-        amb_cp.set_attr(m=2, T=self.Tamb, p=self.pamb, fluid={'Air': 1})
-        cool_cas.set_attr(T=self.Tamb, p=10)
-
-        # solve network
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-
-    def test_exergy_analysis_bus_conversion(self):
-        """Test exergy analysis at product exergy with T < Tamb."""
-        ean = ExergyAnalysis(self.nw, E_P=[self.cas_in], E_F=[self.power_in])
-        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
-
-        exergy_balance = (
-            ean.network_data.E_F - ean.network_data.E_P -
-            ean.network_data.E_L - ean.network_data.E_D)
-        msg = (
-            'Exergy balance must be closed (residual value smaller than ' +
-            str(err ** 0.5) + ') for this test but is ' +
-            str(round(abs(exergy_balance), 4)) + ' .')
-        assert abs(exergy_balance) <= err ** 0.5, msg
-
-
-class TestCompressedAirOut:
-
-    def setup(self):
-        """Set up air compressed air turbine."""
-        self.Tamb = 20
-        self.pamb = 1
-        fluids = ['Air']
-
-        # turbine part
-        self.nw = Network(fluids=fluids)
-        self.nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg')
-
-        # components
-        cas = Source('compressed air storage')
-        reheater = HeatExchangerSimple('reheating')
-        turb = Turbine('turbine')
-        amb = Sink('air outlet')
-
-        # power ouput bus
-        self.power_out = Bus('power output')
-        self.power_out.add_comps({'comp': turb, 'char': 1})
-        # compressed air bus
-        self.cas_out = Bus('exergy in')
-        self.cas_out.add_comps(
-            {'comp': cas, 'base': 'bus'},
-            {'comp': reheater, 'base': 'bus'})
-        # exergy loss bus
-        self.ex_loss = Bus('exergy loss')
-        self.ex_loss.add_comps({'comp': amb, 'base': 'component'})
-        self.nw.add_busses(self.power_out, self.cas_out)
-
-        # create connections
-        cas_reheater = Connection(cas, 'out1', reheater, 'in1')
-        reheater_turb = Connection(reheater, 'out1', turb, 'in1')
-        turb_amb = Connection(turb, 'out1', amb, 'in1', label='outlet')
-        self.nw.add_conns(cas_reheater, reheater_turb, turb_amb)
-
-        # component parameters
-        turb.set_attr(eta_s=1)
-        reheater.set_attr(pr=1)
-
-        # connection parameters
-        cas_reheater.set_attr(m=2, T=self.Tamb, p=10, fluid={'Air': 1})
-        reheater_turb.set_attr()
-        turb_amb.set_attr(p=self.pamb, T=self.Tamb)
-
-        # solve network
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-
-    def test_exergy_analysis_bus_conversion(self):
-        """Test exergy analysis at product exergy with T < Tamb."""
-        ean = ExergyAnalysis(
-            self.nw, E_P=[self.power_out], E_F=[self.cas_out],
-            E_L=[self.ex_loss])
-        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
-
-        exergy_balance = (
-            ean.network_data.E_F - ean.network_data.E_P -
-            ean.network_data.E_L - ean.network_data.E_D)
-        msg = (
-            'Exergy balance must be closed (residual value smaller than ' +
-            str(err ** 0.5) + ') for this test but is ' +
-            str(round(abs(exergy_balance), 4)) + '.')
-        assert abs(exergy_balance) <= err ** 0.5, msg
-
-        msg = (
-            'Exergy efficiency must be equal to 1.0 for this test but is ' +
-            str(round(ean.network_data.epsilon, 4)) + '.')
-        assert round(ean.network_data.epsilon, 4) == 1, msg
-
-        c = self.nw.get_conn('outlet')
-        c.set_attr(T=self.Tamb - 20)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-
-        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
-
-        msg = (
-            'Exergy destruction must be equal to 0.0 for this test but is ' +
-            str(round(ean.network_data.E_D, 4)) + '.')
-        assert round(ean.network_data.E_D, 4) == 0, msg
-
-        msg = (
-            'Exergy loss must be equal to ' + str(round(c.Ex_physical, 4)) +
-            ' for this test but is ' + str(round(ean.network_data.E_L, 4)) +
-            '.')
-        assert round(ean.network_data.E_L, 4) == round(c.Ex_physical, 4), msg
-
-
-class TestCompression:
-
-    def setup(self):
-        self.Tamb = 20
-        self.pamb = 1
-        fluids = ['Air']
-
-        # turbine part
-        self.nw = Network(fluids=fluids)
-        self.nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg')
-
-        # components
-        so = Source('inlet')
-        cp = Compressor('compressor')
-        si = Sink('outlet')
-
-        # fuel exergy bus
-        self.exergy_fuel = Bus('fuel exergy')
-        self.exergy_fuel.add_comps({'comp': cp, 'char': 0.9, 'base': 'bus'})
-        # product exergy bus
-        self.exergy_prod = Bus('product exergy')
-        self.exergy_prod.add_comps({'comp': si}, {'comp': so, 'base': 'bus'})
-
-        # create connections
-        c1 = Connection(so, 'out1', cp, 'in1', '1')
-        c2 = Connection(cp, 'out1', si, 'in1', '2')
-        self.nw.add_conns(c1, c2)
-
-        # component parameters
-        cp.set_attr(eta_s=0.85, pr=5)
-
-        # connection parameters
-        c1.set_attr(m=2, T=self.Tamb, p=self.pamb, fluid={'Air': 1})
-
-        # solve network
-        self.nw.solve('design')
-
-    def test_larger_T0(self):
-        self.nw.get_conn('1').set_attr(T=self.Tamb + 10)
-        self.nw.solve('design')
-        self.run_analysis()
-
-    def test_T0_cross(self):
-        self.nw.get_conn('1').set_attr(T=self.Tamb - 30)
-        self.nw.solve('design')
-        self.run_analysis()
-
-    def test_smaller_T0(self):
-
-        self.nw.get_conn('1').set_attr(T=None)
-        self.nw.get_conn('2').set_attr(T=self.Tamb - 10)
-        self.nw.solve('design')
-        self.run_analysis()
-
-    def run_analysis(self):
-
-        ean = ExergyAnalysis(
-            self.nw, E_P=[self.exergy_prod], E_F=[self.exergy_fuel])
-        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
-
-        exergy_balance = (
-            ean.network_data.E_F - ean.network_data.E_P -
-            ean.network_data.E_L - ean.network_data.E_D)
-        msg = (
-            'Exergy balance must be closed (residual value smaller than ' +
-            str(err ** 0.5) + ') for this test but is ' +
-            str(round(abs(exergy_balance), 4)) + '.')
-        assert abs(exergy_balance) <= err ** 0.5, msg
-
-        E_D_agg = ean.aggregation_data['E_D'].sum()
-        E_D_nw = ean.network_data.loc['E_D']
-        msg = (
-            'The exergy destruction of the aggregated components and '
-            'respective busses (' + str(round(E_D_agg)) + ') must be equal to '
-            'the exergy destruction of the network (' + str(round(E_D_nw)) +
-            ').')
-        assert E_D_agg == E_D_nw, msg
-
-
-class TestExpansion:
-
-    def setup(self):
-        self.Tamb = 20
-        self.pamb = 1
-        fluids = ['Air']
-
-        # turbine part
-        self.nw = Network(fluids=fluids)
-        self.nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg')
-
-        # components
-        so = Source('inlet')
-        tu = Turbine('compressor')
-        si = Sink('outlet')
-
-        # fuel exergy bus
-        self.exergy_fuel = Bus('fuel exergy')
-        self.exergy_fuel.add_comps({'comp': si}, {'comp': so, 'base': 'bus'})
-        # product exergy bus
-        self.exergy_prod = Bus('product exergy')
-        self.exergy_prod.add_comps({'comp': tu, 'char': 0.9})
-
-        # create connections
-        c1 = Connection(so, 'out1', tu, 'in1', '1')
-        c2 = Connection(tu, 'out1', si, 'in1', '2')
-        self.nw.add_conns(c1, c2)
-
-        # component parameters
-        tu.set_attr(eta_s=0.85, pr=1 / 5)
-
-        # connection parameters
-        c1.set_attr(m=2, p=10, fluid={'Air': 1})
-        c2.set_attr(T=self.Tamb)
-
-        # solve network
-        self.nw.solve('design')
-
-    def test_larger_T0(self):
-        self.nw.get_conn('2').set_attr(T=self.Tamb + 10)
-        self.nw.solve('design')
-        self.run_analysis()
-
-    def test_T0_cross(self):
-        self.nw.get_conn('2').set_attr(T=self.Tamb - 30)
-        self.nw.solve('design')
-        self.run_analysis()
-
-    def test_smaller_T0(self):
-
-        self.nw.get_conn('1').set_attr(T=self.Tamb - 10)
-        self.nw.get_conn('2').set_attr(T=None)
-        self.nw.solve('design')
-        self.run_analysis()
-
-    def run_analysis(self):
-
-        ean = ExergyAnalysis(
-            self.nw, E_P=[self.exergy_prod], E_F=[self.exergy_fuel])
-        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
-
-        exergy_balance = (
-            ean.network_data.E_F - ean.network_data.E_P -
-            ean.network_data.E_L - ean.network_data.E_D)
-        msg = (
-            'Exergy balance must be closed (residual value smaller than ' +
-            str(err ** 0.5) + ') for this test but is ' +
-            str(round(abs(exergy_balance), 4)) + '.')
-        assert abs(exergy_balance) <= err ** 0.5, msg
-
-        E_D_agg = ean.aggregation_data['E_D'].sum()
-        E_D_nw = ean.network_data.loc['E_D']
-        msg = (
-            'The exergy destruction of the aggregated components and '
-            'respective busses (' + str(round(E_D_agg)) + ') must be equal to '
-            'the exergy destruction of the network (' + str(round(E_D_nw)) +
-            ').')
-        assert E_D_agg == E_D_nw, msg
+# -*- coding: utf-8
+
+"""Module for testing network properties.
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location
+tests/test_networks/test_exergy_and_entropy_analysis.py
+
+SPDX-License-Identifier: MIT
+"""
+
+from pytest import raises
+
+from tespy.components import Compressor
+from tespy.components import CycleCloser
+from tespy.components import Merge
+from tespy.components import Pump
+from tespy.components import SimpleHeatExchanger
+from tespy.components import Sink
+from tespy.components import Source
+from tespy.components import Splitter
+from tespy.components import Turbine
+from tespy.components import Valve
+from tespy.connections import Bus
+from tespy.connections import Connection
+from tespy.networks import Network
+from tespy.tools import ExergyAnalysis
+from tespy.tools.global_vars import err
+from tespy.tools.helpers import TESPyNetworkError
+
+
+class TestClausiusRankine:
+
+    def setup_method(self):
+        """Set up clausis rankine cycle with turbine driven feed water pump."""
+        self.Tamb = 20
+        self.pamb = 1
+        fluids = ['water']
+        self.nw = Network(fluids=fluids)
+        self.nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg')
+
+        # create components
+        splitter1 = Splitter('splitter 1')
+        merge1 = Merge('merge 1')
+        turb = Turbine('turbine')
+        fwp_turb = Turbine('feed water pump turbine')
+        condenser = SimpleHeatExchanger('condenser')
+        fwp = Pump('pump')
+        steam_generator = SimpleHeatExchanger('steam generator')
+        cycle_close = CycleCloser('cycle closer')
+
+        # create busses
+        # power output bus
+        self.power = Bus('power_output')
+        self.power.add_comps({'comp': turb, 'char': 1})
+        # turbine driven feed water pump internal bus
+        self.fwp_power = Bus('feed water pump power', P=0)
+        self.fwp_power.add_comps(
+            {'comp': fwp_turb, 'char': 1},
+            {'comp': fwp, 'char': 1, 'base': 'bus'})
+        # heat input bus
+        self.heat = Bus('heat_input')
+        self.heat.add_comps({'comp': steam_generator, 'base': 'bus'})
+        self.nw.add_busses(self.power, self.fwp_power, self.heat)
+
+        # create connections
+        fs_in = Connection(cycle_close, 'out1', splitter1, 'in1', label='fs')
+        fs_fwpt = Connection(splitter1, 'out1', fwp_turb, 'in1')
+        fs_t = Connection(splitter1, 'out2', turb, 'in1')
+        fwpt_ws = Connection(fwp_turb, 'out1', merge1, 'in1')
+        t_ws = Connection(turb, 'out1', merge1, 'in2')
+        ws = Connection(merge1, 'out1', condenser, 'in1')
+        cond = Connection(condenser, 'out1', fwp, 'in1', label='cond')
+        fw = Connection(fwp, 'out1', steam_generator, 'in1', label='fw')
+        fs_out = Connection(steam_generator, 'out1', cycle_close, 'in1')
+        self.nw.add_conns(fs_in, fs_fwpt, fs_t, fwpt_ws, t_ws, ws, cond, fw,
+                          fs_out)
+
+        # component parameters
+        turb.set_attr(eta_s=1)
+        fwp_turb.set_attr(eta_s=1)
+        condenser.set_attr(pr=1)
+        fwp.set_attr(eta_s=1)
+        steam_generator.set_attr(pr=1)
+
+        # connection parameters
+        fs_in.set_attr(m=10, p=120, T=600, fluid={'water': 1})
+        cond.set_attr(T=self.Tamb, x=0)
+
+        # solve network
+        self.nw.solve('design')
+        self.nw._convergence_check()
+
+    def test_exergy_analysis_perfect_cycle(self):
+        """Test exergy analysis in the perfect clausius rankine cycle."""
+        ean = ExergyAnalysis(
+            self.nw, E_P=[self.power], E_F=[self.heat],
+            internal_busses=[self.fwp_power])
+        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
+        msg = (
+            'Exergy destruction of this network must be 0 (smaller than ' +
+            str(err ** 0.5) + ') for this test but is ' +
+            str(round(abs(ean.network_data.E_D), 4)) + ' .')
+        assert abs(ean.network_data.E_D) <= err ** 0.5, msg
+
+        msg = (
+            'Exergy efficiency of this network must be 1 for this test but '
+            'is ' + str(round(ean.network_data.epsilon, 4)) + ' .')
+        assert round(ean.network_data.epsilon, 4) == 1, msg
+
+        exergy_balance = (
+            ean.network_data.E_F - ean.network_data.E_P -
+            ean.network_data.E_L - ean.network_data.E_D)
+        msg = (
+            'Exergy balance must be closed (residual value smaller than ' +
+            str(err ** 0.5) + ') for this test but is ' +
+            str(round(abs(exergy_balance), 4)) + ' .')
+        assert abs(exergy_balance) <= err ** 0.5, msg
+
+        msg = (
+            'Fuel exergy and product exergy must be identical for this test. '
+            'Fuel exergy value: ' + str(round(ean.network_data.E_F, 4)) +
+            '. Product exergy value: ' + str(round(ean.network_data.E_P, 4)) +
+            '.')
+        delta = round(abs(ean.network_data.E_F - ean.network_data.E_P), 4)
+        assert delta < err ** 0.5, msg
+
+    def test_exergy_analysis_plotting_data(self):
+        """Test exergy analysis plotting."""
+        self.nw.get_comp('steam generator').set_attr(pr=0.9)
+        self.nw.get_comp('turbine').set_attr(eta_s=0.9)
+        self.nw.get_comp('feed water pump turbine').set_attr(eta_s=0.85)
+        self.nw.get_comp('pump').set_attr(eta_s=0.75)
+        # to make a beautiful graph we need positive exergy of the condensate
+        self.nw.get_conn('cond').set_attr(T=self.Tamb + 5)
+
+        # specify efficiency values for the internal bus and power bus
+        self.nw.del_busses(self.fwp_power, self.power)
+
+        self.fwp_power = Bus('feed water pump power', P=0)
+        self.fwp_power.add_comps(
+            {'comp': self.nw.get_comp('feed water pump turbine'), 'char': 0.99},
+            {'comp': self.nw.get_comp('pump'), 'char': 0.98, 'base': 'bus'}
+        )
+        self.power = Bus('power_output')
+        self.power.add_comps(
+            {'comp': self.nw.get_comp('turbine'), 'char': 0.98}
+        )
+
+        self.nw.add_busses(self.fwp_power, self.power)
+
+        # solve network
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        ean = ExergyAnalysis(
+            self.nw, E_P=[self.power], E_F=[self.heat],
+            internal_busses=[self.fwp_power])
+        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
+
+        exergy_balance = (
+            ean.network_data.E_F - ean.network_data.E_P -
+            ean.network_data.E_L - ean.network_data.E_D
+        )
+        msg = (
+            'Exergy balance must be closed (residual value smaller than ' +
+            str(err ** 0.5) + ') for this test but is ' +
+            str(round(abs(exergy_balance), 4)) + ' .')
+        assert abs(exergy_balance) <= err ** 0.5, msg
+
+        nodes = [
+            'E_F', 'heat_input', 'steam generator', 'splitter 1',
+            'feed water pump turbine', 'turbine', 'merge 1', 'condenser',
+            'feed water pump power', 'pump', 'power_output', 'E_D', 'E_P', 'E_L'
+        ]
+
+        links, nodes = ean.generate_plotly_sankey_input(node_order=nodes)
+        # checksum for targets and source
+        checksum = sum(links['target'] + links['source'])
+        check = 233
+        msg = (
+            'The checksum of all target and source values in the link lists'
+            f'must be {check}, but is {checksum}.'
+        )
+        assert check == checksum, msg
+
+    def test_exergy_analysis_violated_balance(self):
+        """Test exergy analysis with violated balance."""
+        # specify efficiency values for the internal bus
+        self.nw.del_busses(self.fwp_power)
+        self.fwp_power = Bus('feed water pump power', P=0)
+        self.fwp_power.add_comps(
+            {'comp': self.nw.get_comp('feed water pump turbine'),
+             'char': 0.99},
+            {'comp': self.nw.get_comp('pump'), 'char': 0.98, 'base': 'bus'})
+        self.nw.add_busses(self.fwp_power)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        # miss out on internal bus in exergy_analysis
+        ean = ExergyAnalysis(
+            self.nw, E_P=[self.power], E_F=[self.heat])
+        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
+
+        exergy_balance = (
+            ean.network_data.E_F - ean.network_data.E_P -
+            ean.network_data.E_L - ean.network_data.E_D)
+        msg = (
+            'Exergy balance must be violated for this test (larger than ' +
+            str(err ** 0.5) + ') but is ' +
+            str(round(abs(exergy_balance), 4)) + ' .')
+        assert abs(exergy_balance) > err ** 0.5, msg
+
+    def test_exergy_analysis_bus_conversion(self):
+        """Test exergy analysis bus conversion factors."""
+        # specify efficiency values for the internal bus
+        self.nw.del_busses(self.fwp_power)
+        self.fwp_power = Bus('feed water pump power', P=0)
+        self.fwp_power.add_comps(
+            {'comp': self.nw.get_comp('feed water pump turbine'), 'char': 0.99},
+            {'comp': self.nw.get_comp('pump'), 'char': 0.98, 'base': 'bus'}
+        )
+        self.nw.add_busses(self.fwp_power)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        # no exergy losses in this case
+        ean = ExergyAnalysis(
+            self.nw, E_P=[self.power], E_F=[self.heat],
+            internal_busses=[self.fwp_power])
+        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
+
+        label = 'pump'
+        eps = ean.bus_data.loc[label, 'epsilon']
+        msg = (
+            'Pump exergy efficiency must be 0.98 but is ' +
+            str(round(eps, 4)) + ' .')
+        assert round(eps, 4) == 0.98, msg
+
+        label = 'feed water pump turbine'
+        eps = ean.bus_data.loc[label, 'epsilon']
+        msg = (
+            'Feed water pump turbine exergy efficiency must be 0.99 but is ' +
+            str(round(eps, 4)) + ' .')
+        assert round(eps, 4) == 0.99, msg
+
+    def test_exergy_analysis_missing_E_F_E_P_information(self):
+        """Test exergy analysis errors with missing information."""
+        with raises(TESPyNetworkError):
+            ExergyAnalysis(self.nw, E_P=[self.power], E_F=[])
+
+        with raises(TESPyNetworkError):
+            ExergyAnalysis(self.nw, E_P=[], E_F=[self.heat])
+
+    def test_exergy_analysis_component_on_two_busses(self):
+        """Test exergy analysis errors with components on more than one bus."""
+        with raises(TESPyNetworkError):
+            ean = ExergyAnalysis(
+                self.nw, E_P=[self.power], E_F=[self.heat, self.power])
+            ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
+
+    def test_exergy_analysis_invalid_bus_name(self):
+        """Test exergy analysis errors with components on more than one bus."""
+        with raises(ValueError):
+            self.power.label = "E_P"
+            ean = ExergyAnalysis(
+                self.nw, E_P=[self.power], E_F=[self.heat]
+            )
+            ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
+
+
+class TestRefrigerator:
+
+    def setup_method(self):
+        """Set up simple refrigerator."""
+        self.Tamb = 20
+        self.pamb = 1
+        fluids = ['R134a']
+        self.nw = Network(fluids=fluids)
+        self.nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg')
+
+        # create components
+        va = Valve('expansion valve')
+        cp = Compressor('compressor')
+        cond = SimpleHeatExchanger('condenser')
+        eva = SimpleHeatExchanger('evaporator', dissipative=False)
+        cc = CycleCloser('cycle closer')
+
+        # create busses
+        # power output bus
+        self.power = Bus('power input')
+        self.power.add_comps({'comp': cp, 'char': 1, 'base': 'bus'})
+        # cooling bus
+        self.cool = Bus('heat from fridge')
+        self.cool.add_comps({'comp': eva})
+        # heat input bus
+        self.heat = Bus('heat to ambient')
+        self.heat.add_comps({'comp': cond})
+        self.nw.add_busses(self.power, self.cool, self.heat)
+
+        # create connections
+        cc_cp = Connection(cc, 'out1', cp, 'in1', label='from eva')
+        cp_cond = Connection(cp, 'out1', cond, 'in1', label='to cond')
+        cond_va = Connection(cond, 'out1', va, 'in1', label='from cond')
+        va_eva = Connection(va, 'out1', eva, 'in1', label='to eva')
+        eva_cc = Connection(eva, 'out1', cc, 'in1')
+        self.nw.add_conns(cc_cp, cp_cond, cond_va, va_eva, eva_cc)
+
+        # component parameters
+        cp.set_attr(eta_s=0.9)
+        cond.set_attr(pr=0.97)
+        eva.set_attr(pr=0.96)
+
+        # connection parameters
+        cc_cp.set_attr(m=1, x=1, T=-25, fluid={'R134a': 1})
+        cond_va.set_attr(x=0, T=self.Tamb + 1)
+
+        # solve network
+        self.nw.solve('design')
+        self.nw._convergence_check()
+
+    def test_exergy_analysis_bus_conversion(self):
+        """Test exergy analysis at product exergy with T < Tamb."""
+        # no exergy losses in this case
+        ean = ExergyAnalysis(self.nw, E_P=[self.cool], E_F=[self.power])
+        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
+
+        exergy_balance = (
+            ean.network_data.E_F - ean.network_data.E_P -
+            ean.network_data.E_L - ean.network_data.E_D)
+        msg = (
+            'Exergy balance must be closed (residual value smaller than ' +
+            str(err ** 0.5) + ') for this test but is ' +
+            str(round(abs(exergy_balance), 4)) + ' .')
+        assert abs(exergy_balance) <= err ** 0.5, msg
+
+
+class TestCompressedAirIn:
+
+    def setup_method(self):
+        """Set up air compressor."""
+        self.Tamb = 20
+        self.pamb = 1
+        fluids = ['Air']
+
+        # compressor part
+        self.nw = Network(fluids=fluids)
+        self.nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg')
+
+        # components
+        amb = Source('air intake')
+        cp = Compressor('compressor')
+        cooler = SimpleHeatExchanger('cooling')
+        cas = Sink('compressed air storage')
+
+        # power input bus
+        self.power_in = Bus('power input')
+        self.power_in.add_comps({'comp': cp, 'char': 1, 'base': 'bus'})
+        # compressed air bus (not sure about this!)
+        self.cas_in = Bus('massflow into storage')
+        self.cas_in.add_comps({'comp': cas}, {'comp': amb, 'base': 'bus'})
+        self.nw.add_busses(self.power_in, self.cas_in)
+
+        # create connections
+        amb_cp = Connection(amb, 'out1', cp, 'in1')
+        cp_cool = Connection(cp, 'out1', cooler, 'in1')
+        cool_cas = Connection(cooler, 'out1', cas, 'in1')
+        self.nw.add_conns(amb_cp, cp_cool, cool_cas)
+
+        # component parameters
+        cp.set_attr(eta_s=1)
+        cooler.set_attr(pr=1)
+
+        # connection parameters
+        amb_cp.set_attr(m=2, T=self.Tamb, p=self.pamb, fluid={'Air': 1})
+        cool_cas.set_attr(T=self.Tamb, p=10)
+
+        # solve network
+        self.nw.solve('design')
+        self.nw._convergence_check()
+
+    def test_exergy_analysis_bus_conversion(self):
+        """Test exergy analysis at product exergy with T < Tamb."""
+        ean = ExergyAnalysis(self.nw, E_P=[self.cas_in], E_F=[self.power_in])
+        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
+
+        exergy_balance = (
+            ean.network_data.E_F - ean.network_data.E_P -
+            ean.network_data.E_L - ean.network_data.E_D)
+        msg = (
+            'Exergy balance must be closed (residual value smaller than ' +
+            str(err ** 0.5) + ') for this test but is ' +
+            str(round(abs(exergy_balance), 4)) + ' .')
+        assert abs(exergy_balance) <= err ** 0.5, msg
+
+
+class TestCompressedAirOut:
+
+    def setup_method(self):
+        """Set up air compressed air turbine."""
+        self.Tamb = 20
+        self.pamb = 1
+        fluids = ['Air']
+
+        # turbine part
+        self.nw = Network(fluids=fluids)
+        self.nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg')
+
+        # components
+        cas = Source('compressed air storage')
+        reheater = SimpleHeatExchanger('reheating')
+        turb = Turbine('turbine')
+        amb = Sink('air outlet')
+
+        # power ouput bus
+        self.power_out = Bus('power output')
+        self.power_out.add_comps({'comp': turb, 'char': 1})
+        # compressed air bus
+        self.cas_out = Bus('exergy in')
+        self.cas_out.add_comps(
+            {'comp': cas, 'base': 'bus'},
+            {'comp': reheater, 'base': 'bus'})
+        # exergy loss bus
+        self.ex_loss = Bus('exergy loss')
+        self.ex_loss.add_comps({'comp': amb, 'base': 'component'})
+        self.nw.add_busses(self.power_out, self.cas_out)
+
+        # create connections
+        cas_reheater = Connection(cas, 'out1', reheater, 'in1')
+        reheater_turb = Connection(reheater, 'out1', turb, 'in1')
+        turb_amb = Connection(turb, 'out1', amb, 'in1', label='outlet')
+        self.nw.add_conns(cas_reheater, reheater_turb, turb_amb)
+
+        # component parameters
+        turb.set_attr(eta_s=1)
+        reheater.set_attr(pr=1)
+
+        # connection parameters
+        cas_reheater.set_attr(m=2, T=self.Tamb, p=10, fluid={'Air': 1})
+        reheater_turb.set_attr()
+        turb_amb.set_attr(p=self.pamb, T=self.Tamb)
+
+        # solve network
+        self.nw.solve('design')
+        self.nw._convergence_check()
+
+    def test_exergy_analysis_bus_conversion(self):
+        """Test exergy analysis at product exergy with T < Tamb."""
+        ean = ExergyAnalysis(
+            self.nw, E_P=[self.power_out], E_F=[self.cas_out],
+            E_L=[self.ex_loss])
+        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
+
+        exergy_balance = (
+            ean.network_data.E_F - ean.network_data.E_P -
+            ean.network_data.E_L - ean.network_data.E_D)
+        msg = (
+            'Exergy balance must be closed (residual value smaller than ' +
+            str(err ** 0.5) + ') for this test but is ' +
+            str(round(abs(exergy_balance), 4)) + '.')
+        assert abs(exergy_balance) <= err ** 0.5, msg
+
+        msg = (
+            'Exergy efficiency must be equal to 1.0 for this test but is ' +
+            str(round(ean.network_data.epsilon, 4)) + '.')
+        assert round(ean.network_data.epsilon, 4) == 1, msg
+
+        c = self.nw.get_conn('outlet')
+        c.set_attr(T=self.Tamb - 20)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+
+        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
+
+        msg = (
+            'Exergy destruction must be equal to 0.0 for this test but is ' +
+            str(round(ean.network_data.E_D, 4)) + '.')
+        assert round(ean.network_data.E_D, 4) == 0, msg
+
+        msg = (
+            'Exergy loss must be equal to ' + str(round(c.Ex_physical, 4)) +
+            ' for this test but is ' + str(round(ean.network_data.E_L, 4)) +
+            '.')
+        assert round(ean.network_data.E_L, 4) == round(c.Ex_physical, 4), msg
+
+
+class TestCompression:
+
+    def setup_method(self):
+        self.Tamb = 20
+        self.pamb = 1
+        fluids = ['Air']
+
+        # turbine part
+        self.nw = Network(fluids=fluids)
+        self.nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg')
+
+        # components
+        so = Source('inlet')
+        cp = Compressor('compressor')
+        si = Sink('outlet')
+
+        # fuel exergy bus
+        self.exergy_fuel = Bus('fuel exergy')
+        self.exergy_fuel.add_comps({'comp': cp, 'char': 0.9, 'base': 'bus'})
+        # product exergy bus
+        self.exergy_prod = Bus('product exergy')
+        self.exergy_prod.add_comps({'comp': si}, {'comp': so, 'base': 'bus'})
+
+        # create connections
+        c1 = Connection(so, 'out1', cp, 'in1', '1')
+        c2 = Connection(cp, 'out1', si, 'in1', '2')
+        self.nw.add_conns(c1, c2)
+
+        # component parameters
+        cp.set_attr(eta_s=0.85, pr=5)
+
+        # connection parameters
+        c1.set_attr(m=2, T=self.Tamb, p=self.pamb, fluid={'Air': 1})
+
+        # solve network
+        self.nw.solve('design')
+
+    def test_larger_T0(self):
+        self.nw.get_conn('1').set_attr(T=self.Tamb + 10)
+        self.nw.solve('design')
+        self.run_analysis()
+
+    def test_T0_cross(self):
+        self.nw.get_conn('1').set_attr(T=self.Tamb - 30)
+        self.nw.solve('design')
+        self.run_analysis()
+
+    def test_smaller_T0(self):
+
+        self.nw.get_conn('1').set_attr(T=None)
+        self.nw.get_conn('2').set_attr(T=self.Tamb - 10)
+        self.nw.solve('design')
+        self.run_analysis()
+
+    def run_analysis(self):
+
+        ean = ExergyAnalysis(
+            self.nw, E_P=[self.exergy_prod], E_F=[self.exergy_fuel])
+        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
+
+        exergy_balance = (
+            ean.network_data.E_F - ean.network_data.E_P -
+            ean.network_data.E_L - ean.network_data.E_D)
+        msg = (
+            'Exergy balance must be closed (residual value smaller than ' +
+            str(err ** 0.5) + ') for this test but is ' +
+            str(round(abs(exergy_balance), 4)) + '.')
+        assert abs(exergy_balance) <= err ** 0.5, msg
+
+        E_D_agg = ean.aggregation_data['E_D'].sum()
+        E_D_nw = ean.network_data.loc['E_D']
+        msg = (
+            'The exergy destruction of the aggregated components and '
+            'respective busses (' + str(round(E_D_agg)) + ') must be equal to '
+            'the exergy destruction of the network (' + str(round(E_D_nw)) +
+            ').')
+        assert E_D_agg == E_D_nw, msg
+
+
+class TestExpansion:
+
+    def setup_method(self):
+        self.Tamb = 20
+        self.pamb = 1
+        fluids = ['Air']
+
+        # turbine part
+        self.nw = Network(fluids=fluids)
+        self.nw.set_attr(p_unit='bar', T_unit='C', h_unit='kJ / kg')
+
+        # components
+        so = Source('inlet')
+        tu = Turbine('compressor')
+        si = Sink('outlet')
+
+        # fuel exergy bus
+        self.exergy_fuel = Bus('fuel exergy')
+        self.exergy_fuel.add_comps({'comp': si}, {'comp': so, 'base': 'bus'})
+        # product exergy bus
+        self.exergy_prod = Bus('product exergy')
+        self.exergy_prod.add_comps({'comp': tu, 'char': 0.9})
+
+        # create connections
+        c1 = Connection(so, 'out1', tu, 'in1', '1')
+        c2 = Connection(tu, 'out1', si, 'in1', '2')
+        self.nw.add_conns(c1, c2)
+
+        # component parameters
+        tu.set_attr(eta_s=0.85, pr=1 / 5)
+
+        # connection parameters
+        c1.set_attr(m=2, p=10, fluid={'Air': 1})
+        c2.set_attr(T=self.Tamb)
+
+        # solve network
+        self.nw.solve('design')
+
+    def test_larger_T0(self):
+        self.nw.get_conn('2').set_attr(T=self.Tamb + 10)
+        self.nw.solve('design')
+        self.run_analysis()
+
+    def test_T0_cross(self):
+        self.nw.get_conn('2').set_attr(T=self.Tamb - 30)
+        self.nw.solve('design')
+        self.run_analysis()
+
+    def test_smaller_T0(self):
+
+        self.nw.get_conn('1').set_attr(T=self.Tamb - 10)
+        self.nw.get_conn('2').set_attr(T=None)
+        self.nw.solve('design')
+        self.run_analysis()
+
+    def run_analysis(self):
+
+        ean = ExergyAnalysis(
+            self.nw, E_P=[self.exergy_prod], E_F=[self.exergy_fuel])
+        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
+
+        exergy_balance = (
+            ean.network_data.E_F - ean.network_data.E_P -
+            ean.network_data.E_L - ean.network_data.E_D)
+        msg = (
+            'Exergy balance must be closed (residual value smaller than ' +
+            str(err ** 0.5) + ') for this test but is ' +
+            str(round(abs(exergy_balance), 4)) + '.')
+        assert abs(exergy_balance) <= err ** 0.5, msg
+
+        E_D_agg = ean.aggregation_data['E_D'].sum()
+        E_D_nw = ean.network_data.loc['E_D']
+        msg = (
+            'The exergy destruction of the aggregated components and '
+            'respective busses (' + str(round(E_D_agg)) + ') must be equal to '
+            'the exergy destruction of the network (' + str(round(E_D_nw)) +
+            ').')
+        assert E_D_agg == E_D_nw, msg
```

### Comparing `TESPy-0.6.2/tests/test_busses.py` & `TESPy-0.6.3/tests/test_busses.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,249 +1,249 @@
-# -*- coding: utf-8
-
-"""Module for testing busses.
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location
-tests/test_busses.py
-
-SPDX-License-Identifier: MIT
-"""
-import shutil
-
-import numpy as np
-
-from tespy.components import CombustionChamber
-from tespy.components import Compressor
-from tespy.components import Sink
-from tespy.components import Source
-from tespy.components import Turbine
-from tespy.connections import Bus
-from tespy.connections import Connection
-from tespy.networks import Network
-from tespy.tools.characteristics import CharLine
-
-
-class TestBusses:
-
-    def setup(self):
-        """Set up the model."""
-        # %% network setup
-        fluid_list = ['Ar', 'N2', 'O2', 'CO2', 'CH4', 'H2O']
-        self.nw = Network(
-            fluids=fluid_list, p_unit='bar', T_unit='C', p_range=[0.5, 20])
-
-        # %% components
-        amb = Source('ambient')
-        sf = Source('fuel')
-        cc = CombustionChamber('combustion')
-        cp = Compressor('compressor')
-        gt = Turbine('turbine')
-        fg = Sink('flue gas outlet')
-
-        # %% connections
-        amb_cp = Connection(amb, 'out1', cp, 'in1', label='ambient air flow')
-        cp_cc = Connection(cp, 'out1', cc, 'in1')
-        sf_cc = Connection(sf, 'out1', cc, 'in2')
-        cc_gt = Connection(cc, 'out1', gt, 'in1')
-        gt_fg = Connection(gt, 'out1', fg, 'in1')
-
-        self.nw.add_conns(amb_cp, cp_cc, sf_cc, cc_gt, gt_fg)
-
-        # %% component parameters
-        cc.set_attr(lamb=3)
-        cp.set_attr(eta_s=0.9, pr=15)
-        gt.set_attr(eta_s=0.9)
-
-        # %% connection parameters
-        amb_cp.set_attr(
-            T=20, p=1, m=100,
-            fluid={'Ar': 0.0129, 'N2': 0.7553, 'H2O': 0, 'CH4': 0,
-                   'CO2': 0.0004, 'O2': 0.2314})
-        sf_cc.set_attr(
-            T=20, fluid={'CO2': 0.04, 'Ar': 0, 'N2': 0,
-                         'O2': 0, 'H2O': 0, 'CH4': 0.96})
-        gt_fg.set_attr(p=1)
-
-        # motor efficiency
-        x = np.array(
-            [0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55,
-             0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1, 1.05, 1.1, 1.15,
-             1.2, 10])
-        y = np.array(
-            [0.01, 0.3148, 0.5346, 0.6843, 0.7835, 0.8477, 0.8885, 0.9145,
-             0.9318, 0.9443, 0.9546, 0.9638, 0.9724, 0.9806, 0.9878, 0.9938,
-             0.9982, 0.999, 0.9995, 0.9999, 1, 0.9977, 0.9947, 0.9909, 0.9853,
-             0.9644]) * 0.975
-        self.motor_bus_based = CharLine(x=x, y=y)
-        self.motor_comp_based = CharLine(x=x, y=1 / y)
-
-        # generator efficiency
-        x = np.array(
-            [0.100, 0.345, 0.359, 0.383, 0.410, 0.432, 0.451, 0.504, 0.541,
-             0.600, 0.684, 0.805, 1.000, 1.700, 10])
-        y = np.array(
-            [0.976, 0.989, 0.990, 0.991, 0.992, 0.993, 0.994, 0.995, 0.996,
-             0.997, 0.998, 0.999, 1.000, 0.999, 0.99]) * 0.975
-        self.generator = CharLine(x=x, y=y)
-
-        power_bus_total = Bus('total power output')
-        power_bus_total.add_comps(
-            {'comp': cp, 'char': self.motor_bus_based, 'base': 'bus'},
-            {'comp': gt, 'char': self.generator})
-
-        thermal_input = Bus('thermal input')
-        thermal_input.add_comps({'comp': cc})
-
-        compressor_power_comp = Bus('compressor power input')
-        compressor_power_comp.add_comps(
-            {'comp': cp, 'char': self.motor_comp_based})
-
-        compressor_power_bus = Bus('compressor power input bus based')
-        compressor_power_bus.add_comps(
-            {'comp': cp, 'char': self.motor_bus_based, 'base': 'bus'})
-
-        self.nw.add_busses(
-            power_bus_total, thermal_input, compressor_power_comp,
-            compressor_power_bus)
-
-        # %% solving
-        self.nw.solve('design')
-        self.nw.save('tmp')
-
-    def test_model(self):
-        """Test the bus functionalities in a gas turbine model."""
-        tpo = self.nw.busses['total power output']
-        ti = self.nw.busses['thermal input']
-        cpi = self.nw.busses['compressor power input']
-        cpibb = self.nw.busses['compressor power input bus based']
-
-        cp = self.nw.get_comp('compressor')
-        gt = self.nw.get_comp('turbine')
-        cc = self.nw.get_comp('combustion')
-
-        # test results of design case
-
-        eta_cpi = round(1 / cp.calc_bus_efficiency(cpi), 6)
-        eta_cp_tpo = round(cp.calc_bus_efficiency(tpo), 6)
-        msg = (
-            'The efficiency value of the compressor on the bus ' + tpo.label +
-            ' (' + str(eta_cp_tpo) + ') must be identical to the efficiency '
-            'on the bus ' + cpi.label + ' (' + str(eta_cpi) + ').')
-        assert eta_cp_tpo == eta_cpi, msg
-
-        P_cp_tpo = cp.calc_bus_value(tpo)
-        eta_cp_tpo = cp.calc_bus_efficiency(tpo)
-        P_cp = round(P_cp_tpo * eta_cp_tpo, 0)
-        msg = (
-            'The compressor power must be ' + str(round(cp.P.val, 0)) + ' on '
-            'the bus ' + tpo.label + ' but is ' + str(P_cp) + ').')
-        assert round(cp.P.val, 0) == P_cp, msg
-
-        P_cp_tpo = round(
-            cp.calc_bus_value(tpo) * cp.calc_bus_efficiency(tpo), 0)
-        P_cp_cpi = round(
-            cp.calc_bus_value(cpi) / cp.calc_bus_efficiency(cpi), 0)
-        P_cp_cpibb = round(
-            cp.calc_bus_value(cpibb) * cp.calc_bus_efficiency(cpibb), 0)
-        msg = (
-            'The busses\' component power value for the compressor on bus ' +
-            tpo.label + ' (' + str(P_cp_tpo) + ') must be equal to the '
-            'component power on all other busses. Bus ' + cpi.label + ' (' +
-            str(P_cp_cpi) + ') and bus ' + cpibb.label + ' (' +
-            str(P_cp_cpibb) + ').')
-        assert P_cp_tpo == P_cp_cpi and P_cp_tpo == P_cp_cpibb, msg
-
-        eta_gt_tpo = gt.calc_bus_efficiency(tpo)
-        msg = (
-            'The efficiency value of the turbine on the bus ' + tpo.label +
-            ' (' + str(eta_gt_tpo) + ') must be equal to 0.975.')
-        assert eta_gt_tpo == 0.975, msg
-
-        eta_ti = cc.calc_bus_efficiency(ti)
-        msg = (
-            'The efficiency value of the combustion chamber on the bus ' +
-            ti.label + ' (' + str(eta_ti) + ') must be equal to 1.0.')
-        assert eta_ti == 1.0, msg
-
-        # test partload for bus functions
-        # first test in identical conditions
-
-        self.nw.get_conn('ambient air flow').set_attr(m=None)
-        P_design = cpibb.P.val
-        cpibb.set_attr(P=P_design)
-        self.nw.solve('offdesign', design_path='tmp')
-
-        eta_cpi = round(1 / cp.calc_bus_efficiency(cpi), 6)
-        eta_cp_tpo = round(cp.calc_bus_efficiency(tpo), 6)
-        msg = (
-            'The efficiency value of the compressor on the bus ' + tpo.label +
-            ' (' + str(eta_cp_tpo) + ') must be identical to the efficiency '
-            'on the bus ' + cpi.label + ' (' + str(eta_cpi) + ').')
-        assert eta_cp_tpo == eta_cpi, msg
-
-        eta_gt_tpo = gt.calc_bus_efficiency(tpo)
-        msg = (
-            'The efficiency value of the turbine on the bus ' + tpo.label +
-            ' (' + str(eta_gt_tpo) + ') must be equal to 0.975.')
-        assert eta_gt_tpo == 0.975, msg
-
-        P_cp_tpo = round(
-            cp.calc_bus_value(tpo) * cp.calc_bus_efficiency(tpo), 0)
-        P_cp_cpi = round(
-            cp.calc_bus_value(cpi) / cp.calc_bus_efficiency(cpi), 0)
-        P_cp_cpibb = round(
-            cp.calc_bus_value(cpibb) * cp.calc_bus_efficiency(cpibb), 0)
-        msg = (
-            'The busses\' component power value for the compressor on bus ' +
-            tpo.label + ' (' + str(P_cp_tpo) + ') must be equal to the '
-            'component power on all other busses. Bus ' + cpi.label + ' (' +
-            str(P_cp_cpi) + ') and bus ' + cpibb.label + ' (' +
-            str(P_cp_cpibb) + ').')
-        assert P_cp_tpo == P_cp_cpi and P_cp_tpo == P_cp_cpibb, msg
-
-        # 60 % load
-        load = 0.6
-        cpibb.set_attr(P=P_design * load)
-        self.nw.solve('offdesign', design_path='tmp')
-
-        eta_cp_tpo = round(cp.calc_bus_efficiency(tpo), 6)
-        eta_cp_char = self.motor_bus_based.evaluate(load)
-        msg = (
-            'The efficiency value of the compressor on the bus ' + tpo.label +
-            ' (' + str(eta_cp_tpo) + ') must be identical to the efficiency '
-            'on the characteristic line (' + str(eta_cp_char) + ').')
-        assert eta_cp_tpo == eta_cp_char, msg
-
-        load_frac = round(
-            cp.calc_bus_value(tpo) / tpo.comps.loc[cp, 'P_ref'], 6)
-        msg = (
-            'The load fraction value of the compressor on the bus ' +
-            tpo.label + ' (' + str(load_frac) + ') must be identical to the '
-            'load fraction value on the bus ' + cpibb.label + ' (' +
-            str(load) + ').')
-        assert load == load_frac, msg
-
-        eta_cpi = round(1 / cp.calc_bus_efficiency(cpi), 6)
-        eta_cp_tpo = round(cp.calc_bus_efficiency(tpo), 6)
-        msg = (
-            'The efficiency value of the compressor on the bus ' + tpo.label +
-            ' (' + str(eta_cp_tpo) + ') must be higher than the efficiency '
-            'on the bus ' + cpi.label + ' (' + str(eta_cpi) + ').')
-        assert eta_cp_tpo > eta_cpi, msg
-
-        P_cp_tpo = round(
-            cp.calc_bus_value(tpo) * cp.calc_bus_efficiency(tpo), 0)
-        P_cp_cpi = round(
-            cp.calc_bus_value(cpi) / cp.calc_bus_efficiency(cpi), 0)
-        P_cp_cpibb = round(
-            cp.calc_bus_value(cpibb) * cp.calc_bus_efficiency(cpibb), 0)
-        msg = (
-            'The busses\' component power value for the compressor on bus ' +
-            tpo.label + ' (' + str(P_cp_tpo) + ') must be equal to the '
-            'component power on all other busses. Bus ' + cpi.label + ' (' +
-            str(P_cp_cpi) + ') and bus ' + cpibb.label + ' (' +
-            str(P_cp_cpibb) + ').')
-        assert P_cp_tpo == P_cp_cpi and P_cp_tpo == P_cp_cpibb, msg
-
-        shutil.rmtree('tmp', ignore_errors=True)
+# -*- coding: utf-8
+
+"""Module for testing busses.
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location
+tests/test_busses.py
+
+SPDX-License-Identifier: MIT
+"""
+import shutil
+
+import numpy as np
+
+from tespy.components import CombustionChamber
+from tespy.components import Compressor
+from tespy.components import Sink
+from tespy.components import Source
+from tespy.components import Turbine
+from tespy.connections import Bus
+from tespy.connections import Connection
+from tespy.networks import Network
+from tespy.tools.characteristics import CharLine
+
+
+class TestBusses:
+
+    def setup_method(self):
+        """Set up the model."""
+        # %% network setup
+        fluid_list = ['Ar', 'N2', 'O2', 'CO2', 'CH4', 'H2O']
+        self.nw = Network(
+            fluids=fluid_list, p_unit='bar', T_unit='C', p_range=[0.5, 20])
+
+        # %% components
+        amb = Source('ambient')
+        sf = Source('fuel')
+        cc = CombustionChamber('combustion')
+        cp = Compressor('compressor')
+        gt = Turbine('turbine')
+        fg = Sink('flue gas outlet')
+
+        # %% connections
+        amb_cp = Connection(amb, 'out1', cp, 'in1', label='ambient air flow')
+        cp_cc = Connection(cp, 'out1', cc, 'in1')
+        sf_cc = Connection(sf, 'out1', cc, 'in2')
+        cc_gt = Connection(cc, 'out1', gt, 'in1')
+        gt_fg = Connection(gt, 'out1', fg, 'in1')
+
+        self.nw.add_conns(amb_cp, cp_cc, sf_cc, cc_gt, gt_fg)
+
+        # %% component parameters
+        cc.set_attr(lamb=3)
+        cp.set_attr(eta_s=0.9, pr=15)
+        gt.set_attr(eta_s=0.9)
+
+        # %% connection parameters
+        amb_cp.set_attr(
+            T=20, p=1, m=100,
+            fluid={'Ar': 0.0129, 'N2': 0.7553, 'H2O': 0, 'CH4': 0,
+                   'CO2': 0.0004, 'O2': 0.2314})
+        sf_cc.set_attr(
+            T=20, fluid={'CO2': 0.04, 'Ar': 0, 'N2': 0,
+                         'O2': 0, 'H2O': 0, 'CH4': 0.96})
+        gt_fg.set_attr(p=1)
+
+        # motor efficiency
+        x = np.array(
+            [0, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5, 0.55,
+             0.6, 0.65, 0.7, 0.75, 0.8, 0.85, 0.9, 0.95, 1, 1.05, 1.1, 1.15,
+             1.2, 10])
+        y = np.array(
+            [0.01, 0.3148, 0.5346, 0.6843, 0.7835, 0.8477, 0.8885, 0.9145,
+             0.9318, 0.9443, 0.9546, 0.9638, 0.9724, 0.9806, 0.9878, 0.9938,
+             0.9982, 0.999, 0.9995, 0.9999, 1, 0.9977, 0.9947, 0.9909, 0.9853,
+             0.9644]) * 0.975
+        self.motor_bus_based = CharLine(x=x, y=y)
+        self.motor_comp_based = CharLine(x=x, y=1 / y)
+
+        # generator efficiency
+        x = np.array(
+            [0.100, 0.345, 0.359, 0.383, 0.410, 0.432, 0.451, 0.504, 0.541,
+             0.600, 0.684, 0.805, 1.000, 1.700, 10])
+        y = np.array(
+            [0.976, 0.989, 0.990, 0.991, 0.992, 0.993, 0.994, 0.995, 0.996,
+             0.997, 0.998, 0.999, 1.000, 0.999, 0.99]) * 0.975
+        self.generator = CharLine(x=x, y=y)
+
+        power_bus_total = Bus('total power output')
+        power_bus_total.add_comps(
+            {'comp': cp, 'char': self.motor_bus_based, 'base': 'bus'},
+            {'comp': gt, 'char': self.generator})
+
+        thermal_input = Bus('thermal input')
+        thermal_input.add_comps({'comp': cc})
+
+        compressor_power_comp = Bus('compressor power input')
+        compressor_power_comp.add_comps(
+            {'comp': cp, 'char': self.motor_comp_based})
+
+        compressor_power_bus = Bus('compressor power input bus based')
+        compressor_power_bus.add_comps(
+            {'comp': cp, 'char': self.motor_bus_based, 'base': 'bus'})
+
+        self.nw.add_busses(
+            power_bus_total, thermal_input, compressor_power_comp,
+            compressor_power_bus)
+
+        # %% solving
+        self.nw.solve('design')
+        self.nw.save('tmp')
+
+    def test_model(self):
+        """Test the bus functionalities in a gas turbine model."""
+        tpo = self.nw.busses['total power output']
+        ti = self.nw.busses['thermal input']
+        cpi = self.nw.busses['compressor power input']
+        cpibb = self.nw.busses['compressor power input bus based']
+
+        cp = self.nw.get_comp('compressor')
+        gt = self.nw.get_comp('turbine')
+        cc = self.nw.get_comp('combustion')
+
+        # test results of design case
+
+        eta_cpi = round(1 / cp.calc_bus_efficiency(cpi), 6)
+        eta_cp_tpo = round(cp.calc_bus_efficiency(tpo), 6)
+        msg = (
+            'The efficiency value of the compressor on the bus ' + tpo.label +
+            ' (' + str(eta_cp_tpo) + ') must be identical to the efficiency '
+            'on the bus ' + cpi.label + ' (' + str(eta_cpi) + ').')
+        assert eta_cp_tpo == eta_cpi, msg
+
+        P_cp_tpo = cp.calc_bus_value(tpo)
+        eta_cp_tpo = cp.calc_bus_efficiency(tpo)
+        P_cp = round(P_cp_tpo * eta_cp_tpo, 0)
+        msg = (
+            'The compressor power must be ' + str(round(cp.P.val, 0)) + ' on '
+            'the bus ' + tpo.label + ' but is ' + str(P_cp) + ').')
+        assert round(cp.P.val, 0) == P_cp, msg
+
+        P_cp_tpo = round(
+            cp.calc_bus_value(tpo) * cp.calc_bus_efficiency(tpo), 0)
+        P_cp_cpi = round(
+            cp.calc_bus_value(cpi) / cp.calc_bus_efficiency(cpi), 0)
+        P_cp_cpibb = round(
+            cp.calc_bus_value(cpibb) * cp.calc_bus_efficiency(cpibb), 0)
+        msg = (
+            'The busses\' component power value for the compressor on bus ' +
+            tpo.label + ' (' + str(P_cp_tpo) + ') must be equal to the '
+            'component power on all other busses. Bus ' + cpi.label + ' (' +
+            str(P_cp_cpi) + ') and bus ' + cpibb.label + ' (' +
+            str(P_cp_cpibb) + ').')
+        assert P_cp_tpo == P_cp_cpi and P_cp_tpo == P_cp_cpibb, msg
+
+        eta_gt_tpo = gt.calc_bus_efficiency(tpo)
+        msg = (
+            'The efficiency value of the turbine on the bus ' + tpo.label +
+            ' (' + str(eta_gt_tpo) + ') must be equal to 0.975.')
+        assert round(eta_gt_tpo, 3) == 0.975, msg
+
+        eta_ti = cc.calc_bus_efficiency(ti)
+        msg = (
+            'The efficiency value of the combustion chamber on the bus ' +
+            ti.label + ' (' + str(eta_ti) + ') must be equal to 1.0.')
+        assert eta_ti == 1.0, msg
+
+        # test partload for bus functions
+        # first test in identical conditions
+
+        self.nw.get_conn('ambient air flow').set_attr(m=None)
+        P_design = cpibb.P.val
+        cpibb.set_attr(P=P_design)
+        self.nw.solve('offdesign', design_path='tmp')
+
+        eta_cpi = round(1 / cp.calc_bus_efficiency(cpi), 6)
+        eta_cp_tpo = round(cp.calc_bus_efficiency(tpo), 6)
+        msg = (
+            'The efficiency value of the compressor on the bus ' + tpo.label +
+            ' (' + str(eta_cp_tpo) + ') must be identical to the efficiency '
+            'on the bus ' + cpi.label + ' (' + str(eta_cpi) + ').')
+        assert eta_cp_tpo == eta_cpi, msg
+
+        eta_gt_tpo = gt.calc_bus_efficiency(tpo)
+        msg = (
+            'The efficiency value of the turbine on the bus ' + tpo.label +
+            ' (' + str(eta_gt_tpo) + ') must be equal to 0.975.')
+        assert eta_gt_tpo == 0.975, msg
+
+        P_cp_tpo = round(
+            cp.calc_bus_value(tpo) * cp.calc_bus_efficiency(tpo), 0)
+        P_cp_cpi = round(
+            cp.calc_bus_value(cpi) / cp.calc_bus_efficiency(cpi), 0)
+        P_cp_cpibb = round(
+            cp.calc_bus_value(cpibb) * cp.calc_bus_efficiency(cpibb), 0)
+        msg = (
+            'The busses\' component power value for the compressor on bus ' +
+            tpo.label + ' (' + str(P_cp_tpo) + ') must be equal to the '
+            'component power on all other busses. Bus ' + cpi.label + ' (' +
+            str(P_cp_cpi) + ') and bus ' + cpibb.label + ' (' +
+            str(P_cp_cpibb) + ').')
+        assert P_cp_tpo == P_cp_cpi and P_cp_tpo == P_cp_cpibb, msg
+
+        # 60 % load
+        load = 0.6
+        cpibb.set_attr(P=P_design * load)
+        self.nw.solve('offdesign', design_path='tmp')
+
+        eta_cp_tpo = round(cp.calc_bus_efficiency(tpo), 6)
+        eta_cp_char = self.motor_bus_based.evaluate(load)
+        msg = (
+            'The efficiency value of the compressor on the bus ' + tpo.label +
+            ' (' + str(eta_cp_tpo) + ') must be identical to the efficiency '
+            'on the characteristic line (' + str(eta_cp_char) + ').')
+        assert eta_cp_tpo == eta_cp_char, msg
+
+        load_frac = round(
+            cp.calc_bus_value(tpo) / tpo.comps.loc[cp, 'P_ref'], 6)
+        msg = (
+            'The load fraction value of the compressor on the bus ' +
+            tpo.label + ' (' + str(load_frac) + ') must be identical to the '
+            'load fraction value on the bus ' + cpibb.label + ' (' +
+            str(load) + ').')
+        assert load == load_frac, msg
+
+        eta_cpi = round(1 / cp.calc_bus_efficiency(cpi), 6)
+        eta_cp_tpo = round(cp.calc_bus_efficiency(tpo), 6)
+        msg = (
+            'The efficiency value of the compressor on the bus ' + tpo.label +
+            ' (' + str(eta_cp_tpo) + ') must be higher than the efficiency '
+            'on the bus ' + cpi.label + ' (' + str(eta_cpi) + ').')
+        assert eta_cp_tpo > eta_cpi, msg
+
+        P_cp_tpo = round(
+            cp.calc_bus_value(tpo) * cp.calc_bus_efficiency(tpo), 0)
+        P_cp_cpi = round(
+            cp.calc_bus_value(cpi) / cp.calc_bus_efficiency(cpi), 0)
+        P_cp_cpibb = round(
+            cp.calc_bus_value(cpibb) * cp.calc_bus_efficiency(cpibb), 0)
+        msg = (
+            'The busses\' component power value for the compressor on bus ' +
+            tpo.label + ' (' + str(P_cp_tpo) + ') must be equal to the '
+            'component power on all other busses. Bus ' + cpi.label + ' (' +
+            str(P_cp_cpi) + ') and bus ' + cpibb.label + ' (' +
+            str(P_cp_cpibb) + ').')
+        assert P_cp_tpo == P_cp_cpi and P_cp_tpo == P_cp_cpibb, msg
+
+        shutil.rmtree('tmp', ignore_errors=True)
```

### Comparing `TESPy-0.6.2/tests/test_components/test_combustion.py` & `TESPy-0.6.3/tests/test_components/test_combustion.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,225 +1,272 @@
-# -*- coding: utf-8
-
-"""Module for testing components of type combustion.
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location
-tests/test_components/test_combustion.py
-
-SPDX-License-Identifier: MIT
-"""
-
-import shutil
-
-import numpy as np
-
-from tespy.components import CombustionChamber
-from tespy.components import CombustionEngine
-from tespy.components import Sink
-from tespy.components import Source
-from tespy.connections import Bus
-from tespy.connections import Connection
-from tespy.networks import Network
-
-
-def convergence_check(lin_dep):
-    """Check convergence status of a simulation."""
-    msg = 'Calculation did not converge!'
-    assert lin_dep is False, msg
-
-
-class TestCombustion:
-
-    def setup(self):
-
-        self.nw = Network(['H2O', 'N2', 'O2', 'Ar', 'CO2', 'CH4'],
-                          T_unit='C', p_unit='bar', v_unit='m3 / s')
-        self.fuel = Source('fuel')
-        self.air = Source('ambient air')
-        self.fg = Sink('flue gas')
-
-    def setup_CombustionChamber_network(self, instance):
-
-        self.c1 = Connection(self.air, 'out1', instance, 'in1')
-        self.c2 = Connection(self.fuel, 'out1', instance, 'in2')
-        self.c3 = Connection(instance, 'out1', self.fg, 'in1')
-        self.nw.add_conns(self.c1, self.c2, self.c3)
-
-    def setup_CombustionEngine_network(self, instance):
-
-        self.cw1_in = Source('cooling water 1 source')
-        self.cw2_in = Source('cooling water 2 source')
-        self.cw1_out = Sink('cooling water 1 sink')
-        self.cw2_out = Sink('cooling water 2 sink')
-
-        self.c1 = Connection(self.air, 'out1', instance, 'in3')
-        self.c2 = Connection(self.fuel, 'out1', instance, 'in4')
-        self.c3 = Connection(instance, 'out3', self.fg, 'in1')
-        self.c4 = Connection(self.cw1_in, 'out1', instance, 'in1')
-        self.c5 = Connection(self.cw2_in, 'out1', instance, 'in2')
-        self.c6 = Connection(instance, 'out1', self.cw1_out, 'in1')
-        self.c7 = Connection(instance, 'out2', self.cw2_out, 'in1')
-        self.nw.add_conns(self.c1, self.c2, self.c3, self.c4, self.c5, self.c6,
-                          self.c7)
-
-    def test_CombustionChamber(self):
-        """
-        Test component properties of combustion chamber.
-        """
-        instance = CombustionChamber('combustion chamber')
-        self.setup_CombustionChamber_network(instance)
-
-        # connection parameter specification
-        air = {'N2': 0.7556, 'O2': 0.2315, 'Ar': 0.0129, 'H2O': 0, 'CO2': 0,
-               'CH4': 0}
-        fuel = {'N2': 0, 'O2': 0, 'Ar': 0, 'H2O': 0, 'CO2': 0.04, 'CH4': 0.96}
-        self.c1.set_attr(fluid=air, p=1, T=30)
-        self.c2.set_attr(fluid=fuel, T=30)
-        self.c3.set_attr(T=1200)
-
-        # test specified bus value on CombustionChamber (must be equal to ti)
-        b = Bus('thermal input', P=1e6)
-        b.add_comps({'comp': instance})
-        self.nw.add_busses(b)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of thermal input must be ' + str(b.P.val) + ', is ' +
-               str(instance.ti.val) + '.')
-        assert round(b.P.val, 1) == round(instance.ti.val, 1), msg
-        b.set_attr(P=np.nan)
-
-        # test specified thermal input for CombustionChamber
-        instance.set_attr(ti=1e6)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        ti = (self.c2.m.val_SI * self.c2.fluid.val['CH4'] *
-              instance.fuels['CH4']['LHV'])
-        msg = ('Value of thermal input must be ' + str(instance.ti.val) +
-               ', is ' + str(ti) + '.')
-        assert round(ti, 1) == round(instance.ti.val, 1), msg
-
-        # test specified lamb for CombustionChamber
-        self.c3.set_attr(T=np.nan)
-        instance.set_attr(lamb=1)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of oxygen in flue gas must be 0.0, is ' +
-               str(round(self.c3.fluid.val['O2'], 4)) + '.')
-        assert 0.0 == round(self.c3.fluid.val['O2'], 4), msg
-
-    def test_CombustionEngine(self):
-        """Test component properties of combustion engine."""
-        instance = CombustionEngine('combustion engine')
-        self.setup_CombustionEngine_network(instance)
-
-        air = {'N2': 0.7556, 'O2': 0.2315, 'Ar': 0.0129, 'H2O': 0, 'CO2': 0,
-               'CH4': 0}
-        fuel = {'N2': 0, 'O2': 0, 'Ar': 0, 'H2O': 0, 'CO2': 0.04, 'CH4': 0.96}
-        water1 = {'N2': 0, 'O2': 0, 'Ar': 0, 'H2O': 1, 'CO2': 0, 'CH4': 0}
-        water2 = {'N2': 0, 'O2': 0, 'Ar': 0, 'H2O': 1, 'CO2': 0, 'CH4': 0}
-
-        # connection parametrisation
-        instance.set_attr(pr1=0.99, pr2=0.99, lamb=1.0,
-                          design=['pr1', 'pr2'], offdesign=['zeta1', 'zeta2'])
-        self.c1.set_attr(p=5, T=30, fluid=air)
-        self.c2.set_attr(T=30, fluid=fuel)
-        self.c4.set_attr(p=3, T=60, m=50, fluid=water1)
-        self.c5.set_attr(p=3, T=80, m=50, fluid=water2)
-
-        # create busses
-        TI = Bus('thermal input')
-        Q1 = Bus('heat output 1')
-        Q2 = Bus('heat output 2')
-        Q = Bus('heat output')
-        Qloss = Bus('thermal heat loss')
-
-        TI.add_comps({'comp': instance, 'param': 'TI'})
-        Q1.add_comps({'comp': instance, 'param': 'Q1'})
-        Q2.add_comps({'comp': instance, 'param': 'Q2'})
-        Q.add_comps({'comp': instance, 'param': 'Q'})
-        Qloss.add_comps({'comp': instance, 'param': 'Qloss'})
-
-        self.nw.add_busses(TI, Q1, Q2, Q, Qloss)
-
-        # test specified thermal input bus value
-        ti = 1e6
-        TI.set_attr(P=ti)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        self.nw.save('tmp')
-        # calculate in offdesign mode
-        self.nw.solve('offdesign', init_path='tmp', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of thermal input must be ' + str(TI.P.val) + ', is ' +
-               str(instance.ti.val) + '.')
-        assert round(TI.P.val, 1) == round(instance.ti.val, 1), msg
-
-        # test specified thermal input in component
-        TI.set_attr(P=np.nan)
-        instance.set_attr(ti=ti)
-        self.nw.solve('offdesign', init_path='tmp', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of thermal input must be ' + str(ti) + ', is ' +
-               str(instance.ti.val) + '.')
-        assert round(ti, 1) == round(instance.ti.val, 1), msg
-        instance.set_attr(ti=None)
-
-        # test specified heat output 1 bus value
-        Q1.set_attr(P=instance.Q1.val)
-        self.nw.solve('offdesign', init_path='tmp', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        # heat output is at design point value, thermal input must therefore
-        # not have changed
-        msg = ('Value of thermal input must be ' + str(ti) + ', is ' +
-               str(instance.ti.val) + '.')
-        assert round(ti, 1) == round(instance.ti.val, 1), msg
-
-        # calculate heat output over cooling loop
-        heat1 = self.c4.m.val_SI * (self.c6.h.val_SI - self.c4.h.val_SI)
-        msg = ('Value of heat output 1 must be ' + str(-heat1) + ', is ' +
-               str(instance.Q1.val) + '.')
-        assert round(heat1, 1) == -round(instance.Q1.val, 1), msg
-        Q1.set_attr(P=np.nan)
-
-        # test specified heat output 2 bus value
-        Q2.set_attr(P=1.2 * instance.Q2.val)
-        self.nw.solve('offdesign', init_path='tmp', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-
-        # calculate heat output over cooling loop
-        heat2 = self.c5.m.val_SI * (self.c7.h.val_SI - self.c5.h.val_SI)
-        msg = ('Value of heat output 2 must be ' + str(-heat2) + ', is ' +
-               str(instance.Q2.val) + '.')
-        assert round(heat2, 1) == -round(instance.Q2.val, 1), msg
-
-        # test specified heat output 2 in component
-        Q2.set_attr(P=np.nan)
-        instance.set_attr(Q2=-heat2)
-        self.nw.solve('offdesign', init_path='tmp', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        heat2 = self.c5.m.val_SI * (self.c7.h.val_SI - self.c5.h.val_SI)
-        msg = ('Value of heat output 2 must be ' + str(-heat2) + ', is ' +
-               str(instance.Q2.val) + '.')
-        assert round(heat2, 1) == -round(instance.Q2.val, 1), msg
-
-        # test total heat output bus value
-        instance.set_attr(Q2=np.nan)
-        Q.set_attr(P=1.5 * instance.Q1.val)
-        self.nw.solve('offdesign', init_path='tmp', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        heat = (self.c4.m.val_SI * (self.c6.h.val_SI - self.c4.h.val_SI) +
-                self.c5.m.val_SI * (self.c7.h.val_SI - self.c5.h.val_SI))
-        msg = ('Value of total heat output must be ' + str(Q.P.val) +
-               ', is ' + str(-heat) + '.')
-        assert round(Q.P.val, 1) == -round(heat, 1), msg
-
-        # test specified heat loss bus value
-        Q.set_attr(P=np.nan)
-        Qloss.set_attr(P=-1e5)
-        self.nw.solve('offdesign', init_path='tmp', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of heat loss must be ' + str(Qloss.P.val) + ', is ' +
-               str(instance.Qloss.val) + '.')
-        assert round(Qloss.P.val, 1) == round(instance.Qloss.val, 1), msg
-        shutil.rmtree('./tmp', ignore_errors=True)
+# -*- coding: utf-8
+
+"""Module for testing components of type combustion.
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location
+tests/test_components/test_combustion.py
+
+SPDX-License-Identifier: MIT
+"""
+
+import shutil
+
+import numpy as np
+
+from tespy.components import CombustionChamber
+from tespy.components import CombustionEngine
+from tespy.components import DiabaticCombustionChamber
+from tespy.components import Sink
+from tespy.components import Source
+from tespy.connections import Bus
+from tespy.connections import Connection
+from tespy.networks import Network
+
+
+class TestCombustion:
+
+    def setup_method(self):
+
+        self.nw = Network(['H2O', 'N2', 'O2', 'Ar', 'CO2', 'CH4'],
+                          T_unit='C', p_unit='bar', v_unit='m3 / s')
+        self.fuel = Source('fuel')
+        self.air = Source('ambient air')
+        self.fg = Sink('flue gas')
+
+    def setup_CombustionChamber_network(self, instance):
+
+        self.c1 = Connection(self.air, 'out1', instance, 'in1')
+        self.c2 = Connection(self.fuel, 'out1', instance, 'in2')
+        self.c3 = Connection(instance, 'out1', self.fg, 'in1')
+        self.nw.add_conns(self.c1, self.c2, self.c3)
+
+    def setup_CombustionEngine_network(self, instance):
+
+        self.cw1_in = Source('cooling water 1 source')
+        self.cw2_in = Source('cooling water 2 source')
+        self.cw1_out = Sink('cooling water 1 sink')
+        self.cw2_out = Sink('cooling water 2 sink')
+
+        self.c1 = Connection(self.air, 'out1', instance, 'in3')
+        self.c2 = Connection(self.fuel, 'out1', instance, 'in4')
+        self.c3 = Connection(instance, 'out3', self.fg, 'in1')
+        self.c4 = Connection(self.cw1_in, 'out1', instance, 'in1')
+        self.c5 = Connection(self.cw2_in, 'out1', instance, 'in2')
+        self.c6 = Connection(instance, 'out1', self.cw1_out, 'in1')
+        self.c7 = Connection(instance, 'out2', self.cw2_out, 'in1')
+        self.nw.add_conns(
+            self.c1, self.c2, self.c3, self.c4, self.c5, self.c6, self.c7
+        )
+
+    def test_CombustionChamber(self):
+        """
+        Test component properties of combustion chamber.
+        """
+        instance = CombustionChamber('combustion chamber')
+        self.setup_CombustionChamber_network(instance)
+
+        # connection parameter specification
+        air = {'N2': 0.7556, 'O2': 0.2315, 'Ar': 0.0129, 'H2O': 0, 'CO2': 0,
+               'CH4': 0}
+        fuel = {'N2': 0, 'O2': 0, 'Ar': 0, 'H2O': 0, 'CO2': 0.04, 'CH4': 0.96}
+        self.c1.set_attr(fluid=air, p=1, T=30)
+        self.c2.set_attr(fluid=fuel, T=30)
+        self.c3.set_attr(T=1200)
+
+        # test specified bus value on CombustionChamber (must be equal to ti)
+        b = Bus('thermal input', P=1e6)
+        b.add_comps({'comp': instance})
+        self.nw.add_busses(b)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of thermal input must be ' + str(b.P.val) + ', is ' +
+               str(instance.ti.val) + '.')
+        assert round(b.P.val, 1) == round(instance.ti.val, 1), msg
+        b.set_attr(P=np.nan)
+
+        # test specified thermal input for CombustionChamber
+        instance.set_attr(ti=1e6)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        ti = (self.c2.m.val_SI * self.c2.fluid.val['CH4'] *
+              instance.fuels['CH4']['LHV'])
+        msg = ('Value of thermal input must be ' + str(instance.ti.val) +
+               ', is ' + str(ti) + '.')
+        assert round(ti, 1) == round(instance.ti.val, 1), msg
+
+        # test specified lamb for CombustionChamber
+        self.c3.set_attr(T=np.nan)
+        instance.set_attr(lamb=1)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of oxygen in flue gas must be 0.0, is ' +
+               str(round(self.c3.fluid.val['O2'], 4)) + '.')
+        assert 0.0 == round(self.c3.fluid.val['O2'], 4), msg
+
+    def test_DiabaticCombustionChamber(self):
+        """
+        Test component properties of diabatic combustion chamber.
+        """
+        instance = DiabaticCombustionChamber('combustion chamber')
+        self.setup_CombustionChamber_network(instance)
+
+        # connection parameter specification
+        air = {'N2': 0.7556, 'O2': 0.2315, 'Ar': 0.0129, 'H2O': 0, 'CO2': 0,
+               'CH4': 0}
+        fuel = {'N2': 0, 'O2': 0, 'Ar': 0, 'H2O': 0, 'CO2': 0.04, 'CH4': 0.96}
+        self.c1.set_attr(fluid=air, p=1.2, T=30)
+        self.c2.set_attr(fluid=fuel, T=30, p=1.5)
+        self.c3.set_attr(T=1200)
+
+        pr = 0.97
+        instance.set_attr(pr=pr, eta=0.95, ti=1e6)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+
+        valid = round(self.c1.p.val * pr, 2)
+        check = round(self.c3.p.val, 2)
+
+        # test outlet pressure value
+        msg = (
+            f'Value of outlet pressure must be {valid}, the actual value is '
+            f'{check}.'
+        )
+        assert valid == check, msg
+
+        # test invalid pressure specification -> leading to linear dependency
+        self.c2.set_attr(p=None)
+        self.c3.set_attr(p=1.3)
+        self.nw.solve('design')
+        assert self.nw.lin_dep, "Calculation must not converge in this case."
+
+        # test invalid pressure ratio
+        instance.set_attr(pr=None)
+        self.c1.set_attr(p=1.2)
+        self.c2.set_attr(p=1.5)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+
+        valid = round(self.c3.p.val / self.c1.p.val, 2)
+        check = round(instance.pr.val, 2)
+        msg = (
+            f'Value of pressure ratio must be {valid}, the actual value is '
+            f'{check}.'
+        )
+        assert valid == check, msg
+
+    def test_CombustionEngine(self):
+        """Test component properties of combustion engine."""
+        instance = CombustionEngine('combustion engine')
+        self.setup_CombustionEngine_network(instance)
+
+        air = {'N2': 0.7556, 'O2': 0.2315, 'Ar': 0.0129, 'H2O': 0, 'CO2': 0,
+               'CH4': 0}
+        fuel = {'N2': 0, 'O2': 0, 'Ar': 0, 'H2O': 0, 'CO2': 0.04, 'CH4': 0.96}
+        water1 = {'N2': 0, 'O2': 0, 'Ar': 0, 'H2O': 1, 'CO2': 0, 'CH4': 0}
+        water2 = {'N2': 0, 'O2': 0, 'Ar': 0, 'H2O': 1, 'CO2': 0, 'CH4': 0}
+
+        # connection parametrisation
+        instance.set_attr(pr1=0.99, pr2=0.99, lamb=1.0,
+                          design=['pr1', 'pr2'], offdesign=['zeta1', 'zeta2'])
+        self.c1.set_attr(p=5, T=30, fluid=air)
+        self.c2.set_attr(T=30, fluid=fuel)
+        self.c4.set_attr(p=3, T=60, m=50, fluid=water1)
+        self.c5.set_attr(p=3, T=80, m=50, fluid=water2)
+
+        # create busses
+        TI = Bus('thermal input')
+        Q1 = Bus('heat output 1')
+        Q2 = Bus('heat output 2')
+        Q = Bus('heat output')
+        Qloss = Bus('thermal heat loss')
+
+        TI.add_comps({'comp': instance, 'param': 'TI'})
+        Q1.add_comps({'comp': instance, 'param': 'Q1'})
+        Q2.add_comps({'comp': instance, 'param': 'Q2'})
+        Q.add_comps({'comp': instance, 'param': 'Q'})
+        Qloss.add_comps({'comp': instance, 'param': 'Qloss'})
+
+        self.nw.add_busses(TI, Q1, Q2, Q, Qloss)
+
+        # test specified thermal input bus value
+        ti = 1e6
+        TI.set_attr(P=ti)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        self.nw.save('tmp')
+        # calculate in offdesign mode
+        self.nw.solve('offdesign', init_path='tmp', design_path='tmp')
+        self.nw._convergence_check()
+        msg = ('Value of thermal input must be ' + str(TI.P.val) + ', is ' +
+               str(instance.ti.val) + '.')
+        assert round(TI.P.val, 1) == round(instance.ti.val, 1), msg
+
+        # test specified thermal input in component
+        TI.set_attr(P=np.nan)
+        instance.set_attr(ti=ti)
+        self.nw.solve('offdesign', init_path='tmp', design_path='tmp')
+        self.nw._convergence_check()
+        msg = ('Value of thermal input must be ' + str(ti) + ', is ' +
+               str(instance.ti.val) + '.')
+        assert round(ti, 1) == round(instance.ti.val, 1), msg
+        instance.set_attr(ti=None)
+
+        # test specified heat output 1 bus value
+        Q1.set_attr(P=instance.Q1.val)
+        self.nw.solve('offdesign', init_path='tmp', design_path='tmp')
+        self.nw._convergence_check()
+        # heat output is at design point value, thermal input must therefore
+        # not have changed
+        msg = ('Value of thermal input must be ' + str(ti) + ', is ' +
+               str(instance.ti.val) + '.')
+        assert round(ti, 1) == round(instance.ti.val, 1), msg
+
+        # calculate heat output over cooling loop
+        heat1 = self.c4.m.val_SI * (self.c6.h.val_SI - self.c4.h.val_SI)
+        msg = ('Value of heat output 1 must be ' + str(-heat1) + ', is ' +
+               str(instance.Q1.val) + '.')
+        assert round(heat1, 1) == -round(instance.Q1.val, 1), msg
+        Q1.set_attr(P=np.nan)
+
+        # test specified heat output 2 bus value
+        Q2.set_attr(P=1.2 * instance.Q2.val)
+        self.nw.solve('offdesign', init_path='tmp', design_path='tmp')
+        self.nw._convergence_check()
+
+        # calculate heat output over cooling loop
+        heat2 = self.c5.m.val_SI * (self.c7.h.val_SI - self.c5.h.val_SI)
+        msg = ('Value of heat output 2 must be ' + str(-heat2) + ', is ' +
+               str(instance.Q2.val) + '.')
+        assert round(heat2, 1) == -round(instance.Q2.val, 1), msg
+
+        # test specified heat output 2 in component
+        Q2.set_attr(P=np.nan)
+        instance.set_attr(Q2=-heat2)
+        self.nw.solve('offdesign', init_path='tmp', design_path='tmp')
+        self.nw._convergence_check()
+        heat2 = self.c5.m.val_SI * (self.c7.h.val_SI - self.c5.h.val_SI)
+        msg = ('Value of heat output 2 must be ' + str(-heat2) + ', is ' +
+               str(instance.Q2.val) + '.')
+        assert round(heat2, 1) == -round(instance.Q2.val, 1), msg
+
+        # test total heat output bus value
+        instance.set_attr(Q2=np.nan)
+        Q.set_attr(P=1.5 * instance.Q1.val)
+        self.nw.solve('offdesign', init_path='tmp', design_path='tmp')
+        self.nw._convergence_check()
+        heat = (self.c4.m.val_SI * (self.c6.h.val_SI - self.c4.h.val_SI) +
+                self.c5.m.val_SI * (self.c7.h.val_SI - self.c5.h.val_SI))
+        msg = ('Value of total heat output must be ' + str(Q.P.val) +
+               ', is ' + str(-heat) + '.')
+        assert round(Q.P.val, 1) == -round(heat, 1), msg
+
+        # test specified heat loss bus value
+        Q.set_attr(P=np.nan)
+        Qloss.set_attr(P=-1e5)
+        self.nw.solve('offdesign', init_path='tmp', design_path='tmp')
+        self.nw._convergence_check()
+        msg = ('Value of heat loss must be ' + str(Qloss.P.val) + ', is ' +
+               str(instance.Qloss.val) + '.')
+        assert round(Qloss.P.val, 1) == round(instance.Qloss.val, 1), msg
+        shutil.rmtree('./tmp', ignore_errors=True)
```

### Comparing `TESPy-0.6.2/tests/test_components/test_customs.py` & `TESPy-0.6.3/tests/test_components/test_customs.py`

 * *Files 12% similar despite different names*

```diff
@@ -1,149 +1,143 @@
-# -*- coding: utf-8
-
-"""Module for testing components of type orc evaporator.
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location
-tests/test_components/test_customs.py
-SPDX-License-Identifier: MIT
-"""
-import shutil
-
-import numpy as np
-
-from tespy.components import ORCEvaporator
-from tespy.components import Sink
-from tespy.components import Source
-from tespy.connections import Bus
-from tespy.connections import Connection
-from tespy.networks import Network
-from tespy.tools.fluid_properties import T_bp_p
-
-
-def convergence_check(lin_dep):
-    """Check convergence status of a simulation."""
-    msg = 'Calculation did not converge!'
-    assert lin_dep is False, msg
-
-
-class TestOrcEvaporator:
-
-    def setup(self):
-        self.nw = Network(['water', 'Isopentane'], T_unit='C', p_unit='bar',
-                          h_unit='kJ / kg')
-        self.inl1 = Source('inlet 1')
-        self.outl1 = Sink('outlet 1')
-
-        self.inl2 = Source('inlet 2')
-        self.outl2 = Sink('outlet 2')
-
-        self.inl3 = Source('inlet 3')
-        self.outl3 = Sink('outlet 3')
-
-        self.instance = ORCEvaporator('orc evaporator')
-
-        self.c1 = Connection(self.inl1, 'out1', self.instance, 'in1')
-        self.c2 = Connection(self.instance, 'out1', self.outl1, 'in1')
-        self.c3 = Connection(self.inl2, 'out1', self.instance, 'in2')
-        self.c4 = Connection(self.instance, 'out2', self.outl2, 'in1')
-        self.c5 = Connection(self.inl3, 'out1', self.instance, 'in3')
-        self.c6 = Connection(self.instance, 'out3', self.outl3, 'in1')
-
-        self.nw.add_conns(self.c1, self.c2, self.c3, self.c4, self.c5, self.c6)
-
-    def test_ORCEvaporator(self):
-        """Test component properties of orc evaporator."""
-        # design specification
-        self.instance.set_attr(pr1=0.95, pr2=0.975, pr3=0.975,
-                               design=['pr1', 'pr2', 'pr3'],
-                               offdesign=['zeta1', 'zeta2', 'zeta3'])
-        self.c1.set_attr(T=146.6, p=4.34, m=20.4, state='g',
-                         fluid={'water': 1, 'Isopentane': 0})
-        self.c3.set_attr(T=146.6, p=10.2,
-                         fluid={'water': 1, 'Isopentane': 0})
-        self.c4.set_attr(T=118.6)
-        self.c5.set_attr(T=111.6, p=10.8,
-                         fluid={'water': 0, 'Isopentane': 1})
-
-        # test heat transfer
-        Q = -6.64e+07
-        self.instance.set_attr(Q=Q)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        Q_is = -self.c5.m.val_SI * (self.c6.h.val_SI - self.c5.h.val_SI)
-        msg = ('Value of heat flow must be ' + str(round(Q, 0)) +
-               ', is ' + str(round(Q_is, 0)) + '.')
-        assert round(Q, 0) == round(Q_is, 0), msg
-
-        # test bus
-        self.instance.set_attr(Q=np.nan)
-        P = -6.64e+07
-        b = Bus('heat transfer', P=P)
-        b.add_comps({'comp': self.instance})
-        self.nw.add_busses(b)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        self.nw.save('tmp')
-
-        Q_is = -self.c5.m.val_SI * (self.c6.h.val_SI - self.c5.h.val_SI)
-        msg = ('Value of heat flow must be ' + str(round(P, 0)) +
-               ', is ' + str(round(Q_is, 0)) + '.')
-        assert round(P, 0) == round(Q_is, 0), msg
-
-        # Check the state of the steam and working fluid outlet:
-        x_outl1_calc = self.c2.x.val
-        x_outl3_calc = self.c6.x.val
-        zeta1 = self.instance.zeta1.val
-        zeta2 = self.instance.zeta2.val
-        zeta3 = self.instance.zeta3.val
-
-        msg = ('Vapor mass fraction of steam outlet must be 0.0, is ' +
-               str(round(x_outl1_calc, 1)) + '.')
-        assert round(x_outl1_calc, 1) == 0.0, msg
-
-        msg = ('Vapor mass fraction of working fluid outlet must be 1.0, is ' +
-               str(round(x_outl3_calc, 1)) + '.')
-        assert round(x_outl3_calc, 1) == 1.0, msg
-
-        # Check offdesign by zeta values
-        # geometry independent friction coefficient
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-
-        msg = ('Geometry independent friction coefficient '
-               'at hot side 1 (steam) '
-               'must be ' + str(round(zeta1, 1)) + ', is ' +
-               str(round(self.instance.zeta1.val, 1)) + '.')
-        assert round(self.instance.zeta1.val, 1) == round(zeta1, 1), msg
-        msg = ('Geometry independent friction coefficient at '
-               'hot side 2 (brine) '
-               'must be ' + str(round(zeta2, 1)) + ', is ' +
-               str(round(self.instance.zeta2.val, 1)) + '.')
-        assert round(self.instance.zeta2.val, 1) == round(zeta2, 1), msg
-        msg = ('Geometry independent friction coefficient at cold side '
-               '(Isopentane) must be ' + str(round(zeta3, 1)) + ', is ' +
-               str(round(self.instance.zeta3.val, 1)) + '.')
-        assert round(self.instance.zeta3.val, 1) == round(zeta3, 1), msg
-
-        # test parameters of 'subcooling' and 'overheating'
-        self.instance.set_attr(subcooling=True, overheating=True)
-        dT = 0.5
-        self.c2.set_attr(Td_bp=-dT)
-        self.c6.set_attr(Td_bp=dT)
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-
-        T_steam = T_bp_p(self.c2.get_flow()) - dT
-        T_isop = T_bp_p(self.c6.get_flow()) + dT
-
-        msg = ('Temperature of working fluid outlet must be ' +
-               str(round(T_isop, 1)) + ', is ' +
-               str(round(self.c6.T.val_SI, 1)) + '.')
-        assert round(T_isop, 1) == round(self.c6.T.val_SI, 1), msg
-
-        msg = ('Temperature of steam outlet must be ' +
-               str(round(T_steam, 1)) + ', is ' +
-               str(round(self.c2.T.val_SI, 1)) + '.')
-        assert round(T_steam, 1) == round(self.c2.T.val_SI, 1), msg
-
-        shutil.rmtree('./tmp', ignore_errors=True)
+# -*- coding: utf-8
+
+"""Module for testing components of type orc evaporator.
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location
+tests/test_components/test_customs.py
+SPDX-License-Identifier: MIT
+"""
+import shutil
+
+import numpy as np
+
+from tespy.components import ORCEvaporator
+from tespy.components import Sink
+from tespy.components import Source
+from tespy.connections import Bus
+from tespy.connections import Connection
+from tespy.networks import Network
+from tespy.tools.fluid_properties import T_bp_p
+
+
+class TestOrcEvaporator:
+
+    def setup_method(self):
+        self.nw = Network(['water', 'Isopentane'], T_unit='C', p_unit='bar',
+                          h_unit='kJ / kg')
+        self.inl1 = Source('inlet 1')
+        self.outl1 = Sink('outlet 1')
+
+        self.inl2 = Source('inlet 2')
+        self.outl2 = Sink('outlet 2')
+
+        self.inl3 = Source('inlet 3')
+        self.outl3 = Sink('outlet 3')
+
+        self.instance = ORCEvaporator('orc evaporator')
+
+        self.c1 = Connection(self.inl1, 'out1', self.instance, 'in1')
+        self.c2 = Connection(self.instance, 'out1', self.outl1, 'in1')
+        self.c3 = Connection(self.inl2, 'out1', self.instance, 'in2')
+        self.c4 = Connection(self.instance, 'out2', self.outl2, 'in1')
+        self.c5 = Connection(self.inl3, 'out1', self.instance, 'in3')
+        self.c6 = Connection(self.instance, 'out3', self.outl3, 'in1')
+
+        self.nw.add_conns(self.c1, self.c2, self.c3, self.c4, self.c5, self.c6)
+
+    def test_ORCEvaporator(self):
+        """Test component properties of orc evaporator."""
+        # design specification
+        self.instance.set_attr(pr1=0.95, pr2=0.975, pr3=0.975,
+                               design=['pr1', 'pr2', 'pr3'],
+                               offdesign=['zeta1', 'zeta2', 'zeta3'])
+        self.c1.set_attr(T=146.6, p=4.34, m=20.4, state='g',
+                         fluid={'water': 1, 'Isopentane': 0})
+        self.c3.set_attr(T=146.6, p=10.2,
+                         fluid={'water': 1, 'Isopentane': 0})
+        self.c4.set_attr(T=118.6)
+        self.c5.set_attr(T=111.6, p=10.8,
+                         fluid={'water': 0, 'Isopentane': 1})
+
+        # test heat transfer
+        Q = -6.64e+07
+        self.instance.set_attr(Q=Q)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        Q_is = -self.c5.m.val_SI * (self.c6.h.val_SI - self.c5.h.val_SI)
+        msg = ('Value of heat flow must be ' + str(round(Q, 0)) +
+               ', is ' + str(round(Q_is, 0)) + '.')
+        assert round(Q, 0) == round(Q_is, 0), msg
+
+        # test bus
+        self.instance.set_attr(Q=np.nan)
+        P = -6.64e+07
+        b = Bus('heat transfer', P=P)
+        b.add_comps({'comp': self.instance})
+        self.nw.add_busses(b)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        self.nw.save('tmp')
+
+        Q_is = -self.c5.m.val_SI * (self.c6.h.val_SI - self.c5.h.val_SI)
+        msg = ('Value of heat flow must be ' + str(round(P, 0)) +
+               ', is ' + str(round(Q_is, 0)) + '.')
+        assert round(P, 0) == round(Q_is, 0), msg
+
+        # Check the state of the steam and working fluid outlet:
+        x_outl1_calc = self.c2.x.val
+        x_outl3_calc = self.c6.x.val
+        zeta1 = self.instance.zeta1.val
+        zeta2 = self.instance.zeta2.val
+        zeta3 = self.instance.zeta3.val
+
+        msg = ('Vapor mass fraction of steam outlet must be 0.0, is ' +
+               str(round(x_outl1_calc, 1)) + '.')
+        assert round(x_outl1_calc, 1) == 0.0, msg
+
+        msg = ('Vapor mass fraction of working fluid outlet must be 1.0, is ' +
+               str(round(x_outl3_calc, 1)) + '.')
+        assert round(x_outl3_calc, 1) == 1.0, msg
+
+        # Check offdesign by zeta values
+        # geometry independent friction coefficient
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+
+        msg = ('Geometry independent friction coefficient '
+               'at hot side 1 (steam) '
+               'must be ' + str(round(zeta1, 1)) + ', is ' +
+               str(round(self.instance.zeta1.val, 1)) + '.')
+        assert round(self.instance.zeta1.val, 1) == round(zeta1, 1), msg
+        msg = ('Geometry independent friction coefficient at '
+               'hot side 2 (brine) '
+               'must be ' + str(round(zeta2, 1)) + ', is ' +
+               str(round(self.instance.zeta2.val, 1)) + '.')
+        assert round(self.instance.zeta2.val, 1) == round(zeta2, 1), msg
+        msg = ('Geometry independent friction coefficient at cold side '
+               '(Isopentane) must be ' + str(round(zeta3, 1)) + ', is ' +
+               str(round(self.instance.zeta3.val, 1)) + '.')
+        assert round(self.instance.zeta3.val, 1) == round(zeta3, 1), msg
+
+        # test parameters of 'subcooling' and 'overheating'
+        self.instance.set_attr(subcooling=True, overheating=True)
+        dT = 0.5
+        self.c2.set_attr(Td_bp=-dT)
+        self.c6.set_attr(Td_bp=dT)
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+
+        T_steam = T_bp_p(self.c2.get_flow()) - dT
+        T_isop = T_bp_p(self.c6.get_flow()) + dT
+
+        msg = ('Temperature of working fluid outlet must be ' +
+               str(round(T_isop, 1)) + ', is ' +
+               str(round(self.c6.T.val_SI, 1)) + '.')
+        assert round(T_isop, 1) == round(self.c6.T.val_SI, 1), msg
+
+        msg = ('Temperature of steam outlet must be ' +
+               str(round(T_steam, 1)) + ', is ' +
+               str(round(self.c2.T.val_SI, 1)) + '.')
+        assert round(T_steam, 1) == round(self.c2.T.val_SI, 1), msg
+
+        shutil.rmtree('./tmp', ignore_errors=True)
```

### Comparing `TESPy-0.6.2/tests/test_components/test_heat_exchangers.py` & `TESPy-0.6.3/tests/test_components/test_heat_exchangers.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,519 +1,554 @@
-# -*- coding: utf-8
-
-"""Module for testing components of type heat exchanger.
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location
-tests/test_components/test_heat_exchangers.py
-
-SPDX-License-Identifier: MIT
-"""
-import shutil
-
-import numpy as np
-
-from tespy.components import Condenser
-from tespy.components import HeatExchanger
-from tespy.components import HeatExchangerSimple
-from tespy.components import ParabolicTrough
-from tespy.components import Sink
-from tespy.components import SolarCollector
-from tespy.components import Source
-from tespy.connections import Bus
-from tespy.connections import Connection
-from tespy.networks import Network
-from tespy.tools.fluid_properties import T_bp_p
-
-
-def convergence_check(lin_dep):
-    """Check convergence status of a simulation."""
-    msg = 'Calculation did not converge!'
-    assert lin_dep is False, msg
-
-
-class TestHeatExchangers:
-
-    def setup(self):
-
-        self.nw = Network(
-            ['H2O', 'Ar', 'INCOMP::S800'], T_unit='C', p_unit='bar',
-            v_unit='m3 / s')
-        self.inl1 = Source('inlet 1')
-        self.outl1 = Sink('outlet 1')
-
-    def setup_HeatExchangerSimple_network(self, instance):
-
-        self.c1 = Connection(self.inl1, 'out1', instance, 'in1')
-        self.c2 = Connection(instance, 'out1', self.outl1, 'in1')
-
-        self.nw.add_conns(self.c1, self.c2)
-
-    def setup_HeatExchanger_network(self, instance):
-
-        self.inl2 = Source('inlet 2')
-        self.outl2 = Sink('outlet 2')
-
-        self.c1 = Connection(self.inl1, 'out1', instance, 'in1')
-        self.c2 = Connection(instance, 'out1', self.outl1, 'in1')
-        self.c3 = Connection(self.inl2, 'out1', instance, 'in2')
-        self.c4 = Connection(instance, 'out2', self.outl2, 'in1')
-
-        self.nw.add_conns(self.c1, self.c2, self.c3, self.c4)
-
-    def test_HeatExchangerSimple(self):
-        """Test component properties of simple heat exchanger."""
-        instance = HeatExchangerSimple('heat exchanger')
-        self.setup_HeatExchangerSimple_network(instance)
-        fl = {'Ar': 0, 'H2O': 1, 'S800': 0}
-        self.c1.set_attr(fluid=fl, m=1, p=10, T=100)
-        # trigger heat exchanger parameter groups
-        instance.set_attr(hydro_group='HW', L=100, ks=100, pr=0.99, Tamb=20)
-
-        # test grouped parameter settings with missing parameters
-        instance.hydro_group.is_set = True
-        instance.kA_group.is_set = True
-        instance.kA_char_group.is_set = True
-        self.nw.solve('design', init_only=True)
-        msg = ('Hydro group must no be set, if one parameter is missing!')
-        assert instance.hydro_group.is_set is False, msg
-        msg = ('kA group must no be set, if one parameter is missing!')
-        assert instance.kA_group.is_set is False, msg
-        msg = ('kA char group must no be set, if one parameter is missing!')
-        assert instance.kA_char_group.is_set is False, msg
-
-        # test diameter calculation from specified dimensions (as pipe)
-        # with Hazen-Williams method
-        instance.set_attr(hydro_group='HW', D='var', L=100,
-                          ks=100, pr=0.99, Tamb=20)
-        b = Bus('heat', P=-1e5)
-        b.add_comps({'comp': instance})
-        self.nw.add_busses(b)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        pr = round(self.c2.p.val_SI / self.c1.p.val_SI, 3)
-        msg = ('Value of pressure ratio must be ' + str(pr) + ', is ' +
-               str(instance.pr.val) + '.')
-        assert pr == round(instance.pr.val, 3), msg
-
-        # make zeta system variable and use previously calculated diameter
-        # to calculate zeta. The value for zeta must not change
-        zeta = round(instance.zeta.val, 0)
-        instance.set_attr(D=instance.D.val, zeta='var', pr=np.nan)
-        instance.D.is_var = False
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of zeta must be ' + str(zeta) + ', is ' +
-               str(round(instance.zeta.val, 0)) + '.')
-        assert zeta == round(instance.zeta.val, 0), msg
-
-        # same test with pressure ratio as sytem variable
-        pr = round(instance.pr.val, 3)
-        instance.set_attr(zeta=np.nan, pr='var')
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of pressure ratio must be ' + str(pr) +
-               ', is ' + str(round(instance.pr.val, 3)) + '.')
-        assert pr == round(instance.pr.val, 3), msg
-
-        # test heat transfer coefficient as variable of the system (ambient
-        # temperature required)
-        instance.set_attr(kA='var', pr=np.nan)
-        b.set_attr(P=-5e4)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-
-        # due to heat output being half of reference (for Tamb) kA should be
-        # somewhere near to that (actual value is 677)
-        msg = ('Value of heat transfer coefficient must be 677, is ' +
-               str(instance.kA.val) + '.')
-        assert 677 == round(instance.kA.val, 0), msg
-
-        # test heat transfer as variable of the system
-        instance.set_attr(Q='var', kA=np.nan)
-        Q = -5e4
-        b.set_attr(P=Q)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of heat transfer must be ' + str(Q) +
-               ', is ' + str(instance.Q.val) + '.')
-        assert Q == round(instance.Q.val, 0), msg
-
-        # test kA as network results parameter
-        instance.set_attr(Q=-5e4, Tamb=None)
-        b.set_attr(P=None)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        kA_network = self.nw.results['HeatExchangerSimple'].loc[
-            instance.label, 'kA']
-        print(kA_network)
-        msg = 'kA value must not be included in network results.'
-        expr = not instance.kA.is_result and np.isnan(kA_network)
-        assert expr, msg
-
-        # test kA as network results parameter
-        instance.set_attr(Tamb=20)
-        self.nw.solve('design')
-        kA_network = self.nw.results['HeatExchangerSimple'].loc[
-            instance.label, 'kA']
-        kA_comp = instance.kA.val
-        msg = 'kA value needs to be identical on network and component level.'
-        assert kA_network == kA_comp, msg
-
-    def test_ParabolicTrough(self):
-        """Test component properties of parabolic trough."""
-        instance = ParabolicTrough('parabolic trough')
-        self.setup_HeatExchangerSimple_network(instance)
-        fl = {'Ar': 0, 'H2O': 0, 'S800': 1}
-        self.c1.set_attr(fluid=fl, p=2, T=200)
-        self.c2.set_attr(T=350)
-
-        # test grouped parameter settings with missing parameters
-        instance.hydro_group.is_set = True
-        instance.energy_group.is_set = True
-        self.nw.solve('design', init_only=True)
-        msg = ('Hydro group must no be set, if one parameter is missing!')
-        assert instance.hydro_group.is_set is False, msg
-        msg = ('Energy group must no be set, if one parameter is missing!')
-        assert instance.energy_group.is_set is False, msg
-
-        # test solar collector params as system variables
-        instance.set_attr(
-            pr=1, aoi=10, doc=0.95, Q=1e6, Tamb=25, A='var', eta_opt=0.816,
-            c_1=0.0622, c_2=0.00023, E=8e2, iam_1=-1.59e-3, iam_2=9.77e-5)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        # heat loss must be identical to E * A - Q (internal heat loss
-        # calculation)
-        T_diff = (self.c2.T.val + self.c1.T.val) / 2 - instance.Tamb.val
-        iam = (
-            1 - instance.iam_1.val * abs(instance.aoi.val) -
-            instance.iam_2.val * instance.aoi.val ** 2)
-
-        Q_loss = -round(instance.A.val * (
-            instance.E.val * (
-                1 - instance.eta_opt.val * instance.doc.val ** 1.5 * iam
-            ) + T_diff * instance.c_1.val + T_diff ** 2 * instance.c_2.val), 0)
-        msg = (
-            'Value for heat loss of parabolic trough must be ' + str(Q_loss) +
-            ', is ' + str(round(instance.Q_loss.val, 0)) + '.')
-        assert Q_loss == round(instance.Q_loss.val, 0), msg
-
-        # test all parameters of the energy group: E
-        # going to a different operating point first
-        area = instance.A.val
-        instance.set_attr(A=area * 1.2, E='var')
-        self.nw.solve('design')
-        instance.set_attr(A=area)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        assert Q_loss == round(instance.Q_loss.val, 0), msg
-
-        # test all parameters of the energy group: eta_opt
-        instance.set_attr(E=5e2, eta_opt='var')
-        self.nw.solve('design')
-        instance.set_attr(E=8e2)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        assert Q_loss == round(instance.Q_loss.val, 0), msg
-
-        # test all parameters of the energy group: c_1
-        instance.set_attr(E=5e2, eta_opt=instance.eta_opt.val, c_1='var')
-        self.nw.solve('design')
-        instance.set_attr(E=8e2)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        assert Q_loss == round(instance.Q_loss.val, 0), msg
-
-        # test all parameters of the energy group: c_2
-        instance.set_attr(E=5e2, c_1=instance.c_1.val, c_2='var')
-        self.nw.solve('design')
-        instance.set_attr(E=8e2)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        assert Q_loss == round(instance.Q_loss.val, 0), msg
-
-        # test all parameters of the energy group: iam_1
-        instance.set_attr(E=5e2, c_2=instance.c_2.val, iam_1='var')
-        self.nw.solve('design')
-        instance.set_attr(E=8e2)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        assert Q_loss == round(instance.Q_loss.val, 0), msg
-
-        # test all parameters of the energy group: iam_2
-        instance.set_attr(E=5e2, iam_1=instance.iam_1.val, iam_2='var')
-        self.nw.solve('design')
-        instance.set_attr(E=8e2)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        assert Q_loss == round(instance.Q_loss.val, 0), msg
-
-        # test all parameters of the energy group: aoi
-        instance.set_attr(E=5e2, iam_2=instance.iam_2.val, aoi='var')
-        self.nw.solve('design')
-        instance.set_attr(E=8e2)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        assert Q_loss == round(instance.Q_loss.val, 0), msg
-
-        # test all parameters of the energy group: doc
-        instance.set_attr(E=5e2, aoi=instance.aoi.val, doc='var')
-        self.nw.solve('design')
-        instance.set_attr(E=8e2)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        assert Q_loss == round(instance.Q_loss.val, 0), msg
-
-    def test_SolarCollector(self):
-        """Test component properties of solar collector."""
-        instance = SolarCollector('solar collector')
-        self.setup_HeatExchangerSimple_network(instance)
-        fl = {'Ar': 0, 'H2O': 1, 'S800': 0}
-        self.c1.set_attr(fluid=fl, p=10, T=30)
-        self.c2.set_attr(T=70)
-
-        # test grouped parameter settings with missing parameters
-        instance.hydro_group.is_set = True
-        instance.energy_group.is_set = True
-        self.nw.solve('design', init_only=True)
-        msg = ('Hydro group must no be set, if one parameter is missing!')
-        assert instance.hydro_group.is_set is False, msg
-        msg = ('Energy group must no be set, if one parameter is missing!')
-        assert instance.energy_group.is_set is False, msg
-
-        # test solar collector params as system variables
-        instance.set_attr(E=1e3, lkf_lin=1.0, lkf_quad=0.005, A='var',
-                          eta_opt=0.9, Q=1e5, Tamb=20, pr=0.99)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        # heat loss must be identical to E * A - Q (internal heat loss
-        # calculation)
-        T_diff = (self.c2.T.val + self.c1.T.val) / 2 - instance.Tamb.val
-        Q_loss = -round(instance.A.val * (
-            instance.E.val * (1 - instance.eta_opt.val) +
-            T_diff * instance.lkf_lin.val +
-            T_diff ** 2 * instance.lkf_quad.val), 0)
-        msg = ('Value for heat loss of solar collector must be '
-               + str(Q_loss) + ', is ' + str(round(instance.Q_loss.val, 0)) +
-               '.')
-        assert Q_loss == round(instance.Q_loss.val, 0), msg
-
-        # test all parameters of the energy group: E
-        area = instance.A.val
-        instance.set_attr(A=area * 1.2, E='var')
-        self.nw.solve('design')
-        instance.set_attr(A=area)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        assert Q_loss == round(instance.Q_loss.val, 0), msg
-
-        # test all parameters of the energy group: eta_opt
-        instance.set_attr(E=8e2, eta_opt='var')
-        self.nw.solve('design')
-        instance.set_attr(E=1e3)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        assert Q_loss == round(instance.Q_loss.val, 0), msg
-
-        # test all parameters of the energy group: lkf_lin
-        instance.set_attr(E=8e2, eta_opt=instance.eta_opt.val, lkf_lin='var')
-        self.nw.solve('design')
-        instance.set_attr(E=1e3)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        assert Q_loss == round(instance.Q_loss.val, 0), msg
-
-        # test all parameters of the energy group: lkf_quad
-        instance.set_attr(E=8e2, lkf_lin=instance.lkf_lin.val, lkf_quad='var')
-        self.nw.solve('design')
-        instance.set_attr(E=1e3)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        assert Q_loss == round(instance.Q_loss.val, 0), msg
-
-        # test all parameters of the energy group: Tamb
-        instance.set_attr(E=8e2, lkf_lin=instance.lkf_lin.val, lkf_quad='var')
-        self.nw.solve('design')
-        instance.set_attr(E=1e3)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        assert Q_loss == round(instance.Q_loss.val, 0), msg
-
-    def test_HeatExchanger(self):
-        """Test component properties of heat exchanger."""
-        instance = HeatExchanger('heat exchanger')
-        self.setup_HeatExchanger_network(instance)
-
-        # design specification
-        instance.set_attr(pr1=0.98, pr2=0.98, ttd_u=5,
-                          design=['pr1', 'pr2', 'ttd_u'],
-                          offdesign=['zeta1', 'zeta2', 'kA_char'])
-        self.c1.set_attr(T=120, p=3, fluid={'Ar': 0, 'H2O': 1, 'S800': 0})
-        self.c2.set_attr(T=70)
-        self.c3.set_attr(T=40, p=5, fluid={'Ar': 1, 'H2O': 0, 'S800': 0})
-        b = Bus('heat transfer', P=-80e3)
-        b.add_comps({'comp': instance})
-        self.nw.add_busses(b)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        self.nw.save('tmp')
-        Q_design = instance.Q.val
-
-        # test specified kA value
-        instance.set_attr(kA=instance.kA.val * 2 / 3)
-        b.set_attr(P=None)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-
-        # test heat transfer
-        Q = self.c1.m.val_SI * (self.c2.h.val_SI - self.c1.h.val_SI)
-        msg = (
-            'Value of heat flow must be ' + str(round(Q_design * 2 / 3, 0)) +
-            ', is ' + str(round(Q, 0)) + '.')
-        assert round(Q, 1) == round(Q_design * 2 / 3, 1), msg
-
-        # back to design case
-        instance.set_attr(kA=None)
-        b.set_attr(P=Q_design)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-
-        # check heat transfer
-        Q = self.c1.m.val_SI * (self.c2.h.val_SI - self.c1.h.val_SI)
-        td_log = ((self.c2.T.val - self.c3.T.val -
-                   self.c1.T.val + self.c4.T.val) /
-                  np.log((self.c2.T.val - self.c3.T.val) /
-                         (self.c1.T.val - self.c4.T.val)))
-        kA = round(-Q / td_log, 0)
-        msg = ('Value of heat transfer must be ' + str(round(Q, 0)) + ', is ' +
-               str(round(instance.Q.val, 0)) + '.')
-        assert round(Q, 0) == round(instance.Q.val, 0), msg
-
-        # check upper terminal temperature difference
-        msg = ('Value of terminal temperature difference must be ' +
-               str(round(instance.ttd_u.val, 1)) + ', is ' +
-               str(round(self.c1.T.val - self.c4.T.val, 1)) + '.')
-        ttd_u_calc = round(self.c1.T.val - self.c4.T.val, 1)
-        ttd_u = round(instance.ttd_u.val, 1)
-        assert ttd_u_calc == ttd_u, msg
-
-        # check lower terminal temperature difference
-        self.c2.set_attr(T=np.nan)
-        instance.set_attr(ttd_l=20)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of terminal temperature difference must be ' +
-               str(instance.ttd_l.val) + ', is ' +
-               str(self.c2.T.val - self.c3.T.val) + '.')
-        ttd_l_calc = round(self.c2.T.val - self.c3.T.val, 1)
-        ttd_l = round(instance.ttd_l.val, 1)
-        assert ttd_l_calc == ttd_l, msg
-
-        # check specified kA value (by offdesign parameter), reset temperatures
-        # to design state
-        self.c2.set_attr(T=70)
-        instance.set_attr(ttd_l=np.nan)
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of heat flow must be ' + str(instance.Q.val) + ', is ' +
-               str(round(Q, 0)) + '.')
-        assert round(Q, 0) == round(instance.Q.val, 0), msg
-        msg = ('Value of heat transfer coefficient must be ' + str(kA) +
-               ', is ' + str(round(instance.kA.val, 0)) + '.')
-        assert kA == round(instance.kA.val, 0), msg
-
-        # trigger negative lower terminal temperature difference as result
-        self.c4.set_attr(T=np.nan)
-        self.c2.set_attr(T=30)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of upper terminal temperature differences must be '
-               'smaller than zero, is ' + str(round(instance.ttd_l.val, 1)) +
-               '.')
-        assert instance.ttd_l.val < 0, msg
-
-        # trigger negative upper terminal temperature difference as result
-        self.c4.set_attr(T=100)
-        self.c2.set_attr(h=200e3, T=np.nan)
-        instance.set_attr(pr1=0.98, pr2=0.98, ttd_u=np.nan,
-                          design=['pr1', 'pr2'])
-        self.c1.set_attr(h=150e3, T=np.nan)
-        self.c3.set_attr(T=40)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of upper terminal temperature differences must be '
-               'smaller than zero, is ' + str(round(instance.ttd_u.val, 1)) +
-               '.')
-        assert instance.ttd_u.val < 0, msg
-
-        shutil.rmtree('./tmp', ignore_errors=True)
-
-    def test_Condenser(self):
-        """Test component properties of Condenser."""
-        instance = Condenser('condenser')
-        self.setup_HeatExchanger_network(instance)
-
-        # design specification
-        instance.set_attr(pr1=0.98, pr2=0.98, ttd_u=5,
-                          offdesign=['zeta2', 'kA_char'])
-        self.c1.set_attr(T=100, p0=0.5, fluid={'Ar': 0, 'H2O': 1, 'S800': 0})
-        self.c3.set_attr(T=30, p=5, fluid={'Ar': 0, 'H2O': 1, 'S800': 0})
-        self.c4.set_attr(T=40)
-        instance.set_attr(Q=-80e3)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        self.nw.save('tmp')
-        Q_design = instance.Q.val
-
-        # test specified kA value
-        instance.set_attr(kA=instance.kA.val * 2 / 3, Q=None)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-
-        # test heat transfer
-        Q = self.c1.m.val_SI * (self.c2.h.val_SI - self.c1.h.val_SI)
-        msg = (
-            'Value of heat flow must be ' + str(round(Q_design * 2 / 3, 0)) +
-            ', is ' + str(round(Q, 0)) + '.')
-        assert round(Q, 1) == round(Q_design * 2 / 3, 1), msg
-
-        # back to design case
-        instance.set_attr(kA=None, Q=Q_design)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-
-        # test heat transfer
-        Q = self.c1.m.val_SI * (self.c2.h.val_SI - self.c1.h.val_SI)
-        msg = ('Value of heat flow must be ' + str(round(instance.Q.val, 0)) +
-               ', is ' + str(round(Q, 0)) + '.')
-        assert round(Q, 1) == round(instance.Q.val, 1), msg
-
-        # test upper terminal temperature difference. For the component
-        # condenser the temperature of the condensing fluid is relevant.
-        ttd_u = round(T_bp_p(self.c1.get_flow()) - self.c4.T.val_SI, 1)
-        p = round(self.c1.p.val_SI, 5)
-        msg = ('Value of terminal temperature difference must be ' +
-               str(round(instance.ttd_u.val, 1)) + ', is ' +
-               str(ttd_u) + '.')
-        assert ttd_u == round(instance.ttd_u.val, 1), msg
-
-        # test lower terminal temperature difference
-        instance.set_attr(ttd_l=20, ttd_u=np.nan, design=['pr2', 'ttd_l'])
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of terminal temperature difference must be ' +
-               str(instance.ttd_l.val) + ', is ' +
-               str(self.c2.T.val - self.c3.T.val) + '.')
-        ttd_l_calc = round(self.c2.T.val - self.c3.T.val, 1)
-        ttd_l = round(instance.ttd_l.val, 1)
-        assert ttd_l_calc == ttd_l, msg
-
-        # check kA value with condensing pressure in offdesign mode:
-        # no changes to design point means: identical pressure
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of condensing pressure be ' + str(p) + ', is ' +
-               str(round(self.c1.p.val_SI, 5)) + '.')
-        assert p == round(self.c1.p.val_SI, 5), msg
-        shutil.rmtree('./tmp', ignore_errors=True)
+# -*- coding: utf-8
+
+"""Module for testing components of type heat exchanger.
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location
+tests/test_components/test_heat_exchangers.py
+
+SPDX-License-Identifier: MIT
+"""
+import shutil
+
+import numpy as np
+
+from tespy.components import Condenser
+from tespy.components import HeatExchanger
+from tespy.components import ParabolicTrough
+from tespy.components import SimpleHeatExchanger
+from tespy.components import Sink
+from tespy.components import SolarCollector
+from tespy.components import Source
+from tespy.connections import Bus
+from tespy.connections import Connection
+from tespy.networks import Network
+from tespy.tools.fluid_properties import T_bp_p
+
+
+class TestHeatExchangers:
+
+    def setup_method(self):
+
+        self.nw = Network(
+            ['H2O', 'Ar', 'INCOMP::S800'], T_unit='C', p_unit='bar',
+            v_unit='m3 / s')
+        self.inl1 = Source('inlet 1')
+        self.outl1 = Sink('outlet 1')
+
+    def setup_SimpleHeatExchanger_network(self, instance):
+
+        self.c1 = Connection(self.inl1, 'out1', instance, 'in1')
+        self.c2 = Connection(instance, 'out1', self.outl1, 'in1')
+
+        self.nw.add_conns(self.c1, self.c2)
+
+    def setup_HeatExchanger_network(self, instance):
+
+        self.inl2 = Source('inlet 2')
+        self.outl2 = Sink('outlet 2')
+
+        self.c1 = Connection(self.inl1, 'out1', instance, 'in1')
+        self.c2 = Connection(instance, 'out1', self.outl1, 'in1')
+        self.c3 = Connection(self.inl2, 'out1', instance, 'in2')
+        self.c4 = Connection(instance, 'out2', self.outl2, 'in1')
+
+        self.nw.add_conns(self.c1, self.c2, self.c3, self.c4)
+
+    def test_SimpleHeatExchanger(self):
+        """Test component properties of simple heat exchanger."""
+        instance = SimpleHeatExchanger('heat exchanger')
+        self.setup_SimpleHeatExchanger_network(instance)
+        fl = {'Ar': 0, 'H2O': 1, 'S800': 0}
+        self.c1.set_attr(fluid=fl, m=1, p=10, T=100)
+        # trigger heat exchanger parameter groups
+        instance.set_attr(hydro_group='HW', L=100, ks=100, pr=0.99, Tamb=20)
+
+        # test grouped parameter settings with missing parameters
+        instance.hydro_group.is_set = True
+        instance.kA_group.is_set = True
+        instance.kA_char_group.is_set = True
+        self.nw.solve('design', init_only=True)
+        msg = ('Hydro group must no be set, if one parameter is missing!')
+        assert instance.hydro_group.is_set is False, msg
+        msg = ('kA group must no be set, if one parameter is missing!')
+        assert instance.kA_group.is_set is False, msg
+        msg = ('kA char group must no be set, if one parameter is missing!')
+        assert instance.kA_char_group.is_set is False, msg
+
+        # test diameter calculation from specified dimensions (as pipe)
+        # with Hazen-Williams method
+        instance.set_attr(hydro_group='HW', D='var', L=100,
+                          ks=100, pr=0.99, Tamb=20)
+        b = Bus('heat', P=-1e5)
+        b.add_comps({'comp': instance})
+        self.nw.add_busses(b)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        pr = round(self.c2.p.val_SI / self.c1.p.val_SI, 3)
+        msg = ('Value of pressure ratio must be ' + str(pr) + ', is ' +
+               str(instance.pr.val) + '.')
+        assert pr == round(instance.pr.val, 3), msg
+
+        # make zeta system variable and use previously calculated diameter
+        # to calculate zeta. The value for zeta must not change
+        zeta = round(instance.zeta.val, 0)
+        instance.set_attr(D=instance.D.val, zeta='var', pr=np.nan)
+        instance.D.is_var = False
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of zeta must be ' + str(zeta) + ', is ' +
+               str(round(instance.zeta.val, 0)) + '.')
+        assert zeta == round(instance.zeta.val, 0), msg
+
+        # same test with pressure ratio as sytem variable
+        pr = round(instance.pr.val, 3)
+        instance.set_attr(zeta=np.nan, pr='var')
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of pressure ratio must be ' + str(pr) +
+               ', is ' + str(round(instance.pr.val, 3)) + '.')
+        assert pr == round(instance.pr.val, 3), msg
+
+        # test heat transfer coefficient as variable of the system (ambient
+        # temperature required)
+        instance.set_attr(kA='var', pr=np.nan)
+        b.set_attr(P=-5e4)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+
+        # due to heat output being half of reference (for Tamb) kA should be
+        # somewhere near to that (actual value is 677)
+        msg = ('Value of heat transfer coefficient must be 677, is ' +
+               str(instance.kA.val) + '.')
+        assert 677 == round(instance.kA.val, 0), msg
+
+        # test heat transfer as variable of the system
+        instance.set_attr(Q='var', kA=np.nan)
+        Q = -5e4
+        b.set_attr(P=Q)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of heat transfer must be ' + str(Q) +
+               ', is ' + str(instance.Q.val) + '.')
+        assert Q == round(instance.Q.val, 0), msg
+
+        # test kA as network results parameter
+        instance.set_attr(Q=-5e4, Tamb=None)
+        b.set_attr(P=None)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        kA_network = self.nw.results['SimpleHeatExchanger'].loc[
+            instance.label, 'kA']
+        print(kA_network)
+        msg = 'kA value must not be included in network results.'
+        expr = not instance.kA.is_result and np.isnan(kA_network)
+        assert expr, msg
+
+        # test kA as network results parameter
+        instance.set_attr(Tamb=20)
+        self.nw.solve('design')
+        kA_network = self.nw.results['SimpleHeatExchanger'].loc[
+            instance.label, 'kA']
+        kA_comp = instance.kA.val
+        msg = 'kA value needs to be identical on network and component level.'
+        assert kA_network == kA_comp, msg
+
+    def test_ParabolicTrough(self):
+        """Test component properties of parabolic trough."""
+        instance = ParabolicTrough('parabolic trough')
+        self.setup_SimpleHeatExchanger_network(instance)
+        fl = {'Ar': 0, 'H2O': 0, 'S800': 1}
+        self.c1.set_attr(fluid=fl, p=2, T=200)
+        self.c2.set_attr(T=350)
+
+        # test grouped parameter settings with missing parameters
+        instance.hydro_group.is_set = True
+        instance.energy_group.is_set = True
+        self.nw.solve('design', init_only=True)
+        msg = ('Hydro group must no be set, if one parameter is missing!')
+        assert instance.hydro_group.is_set is False, msg
+        msg = ('Energy group must no be set, if one parameter is missing!')
+        assert instance.energy_group.is_set is False, msg
+
+        # test solar collector params as system variables
+        instance.set_attr(
+            pr=1, aoi=10, doc=0.95, Q=1e6, Tamb=25, A='var', eta_opt=0.816,
+            c_1=0.0622, c_2=0.00023, E=8e2, iam_1=-1.59e-3, iam_2=9.77e-5)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        # heat loss must be identical to E * A - Q (internal heat loss
+        # calculation)
+        T_diff = (self.c2.T.val + self.c1.T.val) / 2 - instance.Tamb.val
+        iam = (
+            1 - instance.iam_1.val * abs(instance.aoi.val) -
+            instance.iam_2.val * instance.aoi.val ** 2)
+
+        Q_loss = -round(instance.A.val * (
+            instance.E.val * (
+                1 - instance.eta_opt.val * instance.doc.val ** 1.5 * iam
+            ) + T_diff * instance.c_1.val + T_diff ** 2 * instance.c_2.val), 0)
+        msg = (
+            'Value for heat loss of parabolic trough must be ' + str(Q_loss) +
+            ', is ' + str(round(instance.Q_loss.val, 0)) + '.')
+        assert Q_loss == round(instance.Q_loss.val, 0), msg
+
+        # test all parameters of the energy group: E
+        # going to a different operating point first
+        area = instance.A.val
+        instance.set_attr(A=area * 1.2, E='var')
+        self.nw.solve('design')
+        instance.set_attr(A=area)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        assert Q_loss == round(instance.Q_loss.val, 0), msg
+
+        # test all parameters of the energy group: eta_opt
+        instance.set_attr(E=5e2, eta_opt='var')
+        self.nw.solve('design')
+        instance.set_attr(E=8e2)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        assert Q_loss == round(instance.Q_loss.val, 0), msg
+
+        # test all parameters of the energy group: c_1
+        instance.set_attr(E=5e2, eta_opt=instance.eta_opt.val, c_1='var')
+        self.nw.solve('design')
+        instance.set_attr(E=8e2)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        assert Q_loss == round(instance.Q_loss.val, 0), msg
+
+        # test all parameters of the energy group: c_2
+        instance.set_attr(E=5e2, c_1=instance.c_1.val, c_2='var')
+        self.nw.solve('design')
+        instance.set_attr(E=8e2)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        assert Q_loss == round(instance.Q_loss.val, 0), msg
+
+        # test all parameters of the energy group: iam_1
+        instance.set_attr(E=5e2, c_2=instance.c_2.val, iam_1='var')
+        self.nw.solve('design')
+        instance.set_attr(E=8e2)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        assert Q_loss == round(instance.Q_loss.val, 0), msg
+
+        # test all parameters of the energy group: iam_2
+        instance.set_attr(E=5e2, iam_1=instance.iam_1.val, iam_2='var')
+        self.nw.solve('design')
+        instance.set_attr(E=8e2)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        assert Q_loss == round(instance.Q_loss.val, 0), msg
+
+        # test all parameters of the energy group: aoi
+        instance.set_attr(E=5e2, iam_2=instance.iam_2.val, aoi='var')
+        self.nw.solve('design')
+        instance.set_attr(E=8e2)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        assert Q_loss == round(instance.Q_loss.val, 0), msg
+
+        # test all parameters of the energy group: doc
+        instance.set_attr(E=5e2, aoi=instance.aoi.val, doc='var')
+        self.nw.solve('design')
+        instance.set_attr(E=8e2)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        assert Q_loss == round(instance.Q_loss.val, 0), msg
+
+    def test_SolarCollector(self):
+        """Test component properties of solar collector."""
+        instance = SolarCollector('solar collector')
+        self.setup_SimpleHeatExchanger_network(instance)
+        fl = {'Ar': 0, 'H2O': 1, 'S800': 0}
+        self.c1.set_attr(fluid=fl, p=10, T=30)
+        self.c2.set_attr(T=70)
+
+        # test grouped parameter settings with missing parameters
+        instance.hydro_group.is_set = True
+        instance.energy_group.is_set = True
+        self.nw.solve('design', init_only=True)
+        msg = ('Hydro group must no be set, if one parameter is missing!')
+        assert instance.hydro_group.is_set is False, msg
+        msg = ('Energy group must no be set, if one parameter is missing!')
+        assert instance.energy_group.is_set is False, msg
+
+        # test solar collector params as system variables
+        instance.set_attr(E=1e3, lkf_lin=1.0, lkf_quad=0.005, A='var',
+                          eta_opt=0.9, Q=1e5, Tamb=20, pr=0.99)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        # heat loss must be identical to E * A - Q (internal heat loss
+        # calculation)
+        T_diff = (self.c2.T.val + self.c1.T.val) / 2 - instance.Tamb.val
+        Q_loss = -round(instance.A.val * (
+            instance.E.val * (1 - instance.eta_opt.val) +
+            T_diff * instance.lkf_lin.val +
+            T_diff ** 2 * instance.lkf_quad.val), 0)
+        msg = ('Value for heat loss of solar collector must be '
+               + str(Q_loss) + ', is ' + str(round(instance.Q_loss.val, 0)) +
+               '.')
+        assert Q_loss == round(instance.Q_loss.val, 0), msg
+
+        # test all parameters of the energy group: E
+        area = instance.A.val
+        instance.set_attr(A=area * 1.2, E='var')
+        self.nw.solve('design')
+        instance.set_attr(A=area)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        assert Q_loss == round(instance.Q_loss.val, 0), msg
+
+        # test all parameters of the energy group: eta_opt
+        instance.set_attr(E=8e2, eta_opt='var')
+        self.nw.solve('design')
+        instance.set_attr(E=1e3)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        assert Q_loss == round(instance.Q_loss.val, 0), msg
+
+        # test all parameters of the energy group: lkf_lin
+        instance.set_attr(E=8e2, eta_opt=instance.eta_opt.val, lkf_lin='var')
+        self.nw.solve('design')
+        instance.set_attr(E=1e3)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        assert Q_loss == round(instance.Q_loss.val, 0), msg
+
+        # test all parameters of the energy group: lkf_quad
+        instance.set_attr(E=8e2, lkf_lin=instance.lkf_lin.val, lkf_quad='var')
+        self.nw.solve('design')
+        instance.set_attr(E=1e3)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        assert Q_loss == round(instance.Q_loss.val, 0), msg
+
+        # test all parameters of the energy group: Tamb
+        instance.set_attr(E=8e2, lkf_lin=instance.lkf_lin.val, lkf_quad='var')
+        self.nw.solve('design')
+        instance.set_attr(E=1e3)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        assert Q_loss == round(instance.Q_loss.val, 0), msg
+
+    def test_HeatExchanger(self):
+        """Test component properties of heat exchanger."""
+        instance = HeatExchanger('heat exchanger')
+        self.setup_HeatExchanger_network(instance)
+
+        # design specification
+        instance.set_attr(pr1=0.98, pr2=0.98, ttd_u=5,
+                          design=['pr1', 'pr2', 'ttd_u'],
+                          offdesign=['zeta1', 'zeta2', 'kA_char'])
+        self.c1.set_attr(T=120, p=3, fluid={'Ar': 0, 'H2O': 1, 'S800': 0})
+        self.c2.set_attr(T=70)
+        self.c3.set_attr(T=40, p=5, fluid={'Ar': 1, 'H2O': 0, 'S800': 0})
+        b = Bus('heat transfer', P=-80e3)
+        b.add_comps({'comp': instance})
+        self.nw.add_busses(b)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        self.nw.save('tmp')
+        Q_design = instance.Q.val
+
+        # test specified kA value
+        instance.set_attr(kA=instance.kA.val * 2 / 3)
+        b.set_attr(P=None)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+
+        # test heat transfer
+        Q = self.c1.m.val_SI * (self.c2.h.val_SI - self.c1.h.val_SI)
+        msg = (
+            'Value of heat flow must be ' + str(round(Q_design * 2 / 3, 0)) +
+            ', is ' + str(round(Q, 0)) + '.')
+        assert round(Q, 1) == round(Q_design * 2 / 3, 1), msg
+
+        # back to design case
+        instance.set_attr(kA=None)
+        b.set_attr(P=Q_design)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+
+        # check heat transfer
+        Q = self.c1.m.val_SI * (self.c2.h.val_SI - self.c1.h.val_SI)
+        td_log = ((self.c2.T.val - self.c3.T.val -
+                   self.c1.T.val + self.c4.T.val) /
+                  np.log((self.c2.T.val - self.c3.T.val) /
+                         (self.c1.T.val - self.c4.T.val)))
+        kA = round(-Q / td_log, 0)
+        msg = ('Value of heat transfer must be ' + str(round(Q, 0)) + ', is ' +
+               str(round(instance.Q.val, 0)) + '.')
+        assert round(Q, 0) == round(instance.Q.val, 0), msg
+
+        # check upper terminal temperature difference
+        msg = ('Value of terminal temperature difference must be ' +
+               str(round(instance.ttd_u.val, 1)) + ', is ' +
+               str(round(self.c1.T.val - self.c4.T.val, 1)) + '.')
+        ttd_u_calc = round(self.c1.T.val - self.c4.T.val, 1)
+        ttd_u = round(instance.ttd_u.val, 1)
+        assert ttd_u_calc == ttd_u, msg
+
+        # check lower terminal temperature difference
+        self.c2.set_attr(T=np.nan)
+        instance.set_attr(ttd_l=20)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of terminal temperature difference must be ' +
+               str(instance.ttd_l.val) + ', is ' +
+               str(self.c2.T.val - self.c3.T.val) + '.')
+        ttd_l_calc = round(self.c2.T.val - self.c3.T.val, 1)
+        ttd_l = round(instance.ttd_l.val, 1)
+        assert ttd_l_calc == ttd_l, msg
+
+        # check specified kA value (by offdesign parameter), reset temperatures
+        # to design state
+        self.c2.set_attr(T=70)
+        instance.set_attr(ttd_l=np.nan)
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+        msg = ('Value of heat flow must be ' + str(instance.Q.val) + ', is ' +
+               str(round(Q, 0)) + '.')
+        assert round(Q, 0) == round(instance.Q.val, 0), msg
+        msg = ('Value of heat transfer coefficient must be ' + str(kA) +
+               ', is ' + str(round(instance.kA.val, 0)) + '.')
+        assert kA == round(instance.kA.val, 0), msg
+
+        # trigger negative lower terminal temperature difference as result
+        self.c4.set_attr(T=np.nan)
+        self.c2.set_attr(T=30)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of upper terminal temperature differences must be '
+               'smaller than zero, is ' + str(round(instance.ttd_l.val, 1)) +
+               '.')
+        assert instance.ttd_l.val < 0, msg
+
+        # trigger negative upper terminal temperature difference as result
+        self.c4.set_attr(T=100)
+        self.c2.set_attr(h=200e3, T=np.nan)
+        instance.set_attr(pr1=0.98, pr2=0.98, ttd_u=np.nan,
+                          design=['pr1', 'pr2'])
+        self.c1.set_attr(h=150e3, T=np.nan)
+        self.c3.set_attr(T=40)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of upper terminal temperature differences must be '
+               'smaller than zero, is ' + str(round(instance.ttd_u.val, 1)) +
+               '.')
+        assert instance.ttd_u.val < 0, msg
+
+        shutil.rmtree('./tmp', ignore_errors=True)
+
+    def test_Condenser(self):
+        """Test component properties of Condenser."""
+        instance = Condenser('condenser')
+        self.setup_HeatExchanger_network(instance)
+
+        # design specification
+        instance.set_attr(pr1=0.98, pr2=0.98, ttd_u=5,
+                          offdesign=['zeta2', 'kA_char'])
+        self.c1.set_attr(T=100, p0=0.5, fluid={'Ar': 0, 'H2O': 1, 'S800': 0})
+        self.c3.set_attr(T=30, p=5, fluid={'Ar': 0, 'H2O': 1, 'S800': 0})
+        self.c4.set_attr(T=40)
+        instance.set_attr(Q=-80e3)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        self.nw.save('tmp')
+        Q_design = instance.Q.val
+
+        # test specified kA value
+        instance.set_attr(kA=instance.kA.val * 2 / 3, Q=None)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+
+        # test heat transfer
+        Q = self.c1.m.val_SI * (self.c2.h.val_SI - self.c1.h.val_SI)
+        msg = (
+            'Value of heat flow must be ' + str(round(Q_design * 2 / 3, 0)) +
+            ', is ' + str(round(Q, 0)) + '.')
+        assert round(Q, 1) == round(Q_design * 2 / 3, 1), msg
+
+        # back to design case
+        instance.set_attr(kA=None, Q=Q_design)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+
+        # test heat transfer
+        Q = self.c1.m.val_SI * (self.c2.h.val_SI - self.c1.h.val_SI)
+        msg = ('Value of heat flow must be ' + str(round(instance.Q.val, 0)) +
+               ', is ' + str(round(Q, 0)) + '.')
+        assert round(Q, 1) == round(instance.Q.val, 1), msg
+
+        # test upper terminal temperature difference. For the component
+        # condenser the temperature of the condensing fluid is relevant.
+        ttd_u = round(T_bp_p(self.c1.get_flow()) - self.c4.T.val_SI, 1)
+        p = round(self.c1.p.val_SI, 5)
+        msg = ('Value of terminal temperature difference must be ' +
+               str(round(instance.ttd_u.val, 1)) + ', is ' +
+               str(ttd_u) + '.')
+        assert ttd_u == round(instance.ttd_u.val, 1), msg
+
+        # test lower terminal temperature difference
+        instance.set_attr(ttd_l=20, ttd_u=np.nan, design=['pr2', 'ttd_l'])
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of terminal temperature difference must be ' +
+               str(instance.ttd_l.val) + ', is ' +
+               str(self.c2.T.val - self.c3.T.val) + '.')
+        ttd_l_calc = round(self.c2.T.val - self.c3.T.val, 1)
+        ttd_l = round(instance.ttd_l.val, 1)
+        assert ttd_l_calc == ttd_l, msg
+
+        # check kA value with condensing pressure in offdesign mode:
+        # no changes to design point means: identical pressure
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+        msg = ('Value of condensing pressure be ' + str(p) + ', is ' +
+               str(round(self.c1.p.val_SI, 5)) + '.')
+        assert p == round(self.c1.p.val_SI, 5), msg
+        shutil.rmtree('./tmp', ignore_errors=True)
+
+    def test_CondenserWithEvaporation(self):
+        """Test a Condenser that evaporates a fluid."""
+        instance = Condenser('condenser')
+        self.setup_HeatExchanger_network(instance)
+
+        # design specification
+        instance.set_attr(pr1=1, pr2=1, offdesign=["kA"])
+        self.c1.set_attr(x=1, p=1, fluid={'Ar': 0, 'H2O': 1, 'S800': 0}, m=1)
+        self.c3.set_attr(
+            x=0, p=0.7, fluid={'Ar': 0, 'H2O': 1, 'S800': 0}, m=2, design=["m"]
+        )
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        ttd_l = round(instance.ttd_l.val, 3)
+        ttd_u = round(instance.ttd_u.val, 3)
+        td_log = round(instance.td_log.val, 3)
+        msg = (
+            "Value of upper and lower terminal temperature differences must be "
+            f"identical, but they are not: ttd_u={ttd_u}, ttd_l={ttd_l}."
+        )
+        assert instance.ttd_l.val == instance.ttd_u.val, msg
+
+        msg = (
+            "Value of logarithmic and lower terminal temperature differences "
+            f"must be identical, but they are not: td_log={td_log}, "
+            f"ttd_l={ttd_l}."
+        )
+        assert instance.td_log.val == instance.ttd_l.val, msg
+
+        # self.nw.save('tmp')
+        # self.c1.set_attr(m=1)
+        # self.nw.solve("offdesign", design_path="tmp")
+        # self.nw._convergence_check()
+        # msg = (
+        #     "Value of logarithmic and lower terminal temperature differences "
+        #     f"must be identical, but they are not: td_log={td_log}, "
+        #     f"ttd_l={self.c3.m.val}."
+        # )
+        # assert instance.td_log.val == instance.ttd_l.val, msg
+        shutil.rmtree('./tmp', ignore_errors=True)
```

### Comparing `TESPy-0.6.2/tests/test_components/test_piping.py` & `TESPy-0.6.3/tests/test_components/test_piping.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,91 +1,85 @@
-# -*- coding: utf-8
-
-"""Module for testing components of the piping module.
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location
-tests/test_components/test_piping.py
-
-SPDX-License-Identifier: MIT
-"""
-import numpy as np
-
-from tespy.components import Pipe
-from tespy.components import Sink
-from tespy.components import Source
-from tespy.components import Valve
-from tespy.connections import Connection
-from tespy.networks import Network
-from tespy.tools.characteristics import CharLine
-
-
-def convergence_check(lin_dep):
-    """Check convergence status of a simulation."""
-    msg = 'Calculation did not converge!'
-    assert lin_dep is False, msg
-
-
-class TestPiping:
-
-    def setup_piping_network(self, instance):
-        self.nw = Network(['CH4'], T_unit='C', p_unit='bar')
-        self.source = Source('source')
-        self.sink = Sink('sink')
-        self.c1 = Connection(self.source, 'out1', instance, 'in1')
-        self.c2 = Connection(instance, 'out1', self.sink, 'in1')
-        self.nw.add_conns(self.c1, self.c2)
-
-    def test_Valve(self):
-        """Test component properties of valves."""
-        instance = Valve('valve')
-        self.setup_piping_network(instance)
-
-        # parameter specification
-        self.c1.set_attr(fluid={'CH4': 1}, m=10, p=10, T=120)
-        self.c2.set_attr(p=1)
-
-        # test variable pressure ration
-        instance.set_attr(pr='var')
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        pr = round(self.c2.p.val_SI / self.c1.p.val_SI, 2)
-        msg = ('Value of pressure ratio must be ' + str(pr) + ', is ' +
-               str(round(instance.pr.val, 2)) + '.')
-        assert pr == round(instance.pr.val, 2), msg
-
-        # test variable zeta value
-        zeta = round(instance.zeta.val, 0)
-        instance.set_attr(zeta='var', pr=None)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of dimension independent zeta value must be ' +
-               str(zeta) + ', is ' + str(round(instance.zeta.val, 0)) + '.')
-        assert zeta == round(instance.zeta.val, 0), msg
-
-        # dp char
-        x = np.array([8, 9, 10, 11, 12])
-        y = np.array([5, 8, 9, 9.5, 9.6]) * 1e5
-        dp_char = CharLine(x, y)
-        instance.set_attr(zeta=None, dp_char={
-            'char_func': dp_char, 'is_set': True})
-        m = 11
-        self.c1.set_attr(m=m)
-        self.c2.set_attr(p=np.nan)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        self.nw.print_results()
-        dp = round(-dp_char.evaluate(m), 0)
-        dp_act = round(self.c2.p.val_SI - self.c1.p.val_SI)
-        msg = ('The pressure drop at the valve should be ' + str(dp) + ' but '
-               'is ' + str(dp_act) + '.')
-        assert dp == dp_act, msg
-
-    def test_Pipe(self):
-        """Test component properties of pipe."""
-        instance = Pipe('pipe')
-        self.setup_piping_network(instance)
-
-        # NO TEST NEEDED AT THE MOMENT, THE PIPE PROPERTIES ARE IDENTICAL TO
-        # THE PROPERTIES OF THE SIMPLE HEAT EXCHANGER. TESTS ARE LOCATED AT
-        # heat_exchanger_tests.py
+# -*- coding: utf-8
+
+"""Module for testing components of the piping module.
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location
+tests/test_components/test_piping.py
+
+SPDX-License-Identifier: MIT
+"""
+import numpy as np
+
+from tespy.components import Pipe
+from tespy.components import Sink
+from tespy.components import Source
+from tespy.components import Valve
+from tespy.connections import Connection
+from tespy.networks import Network
+from tespy.tools.characteristics import CharLine
+
+
+class TestPiping:
+
+    def setup_piping_network(self, instance):
+        self.nw = Network(['CH4'], T_unit='C', p_unit='bar')
+        self.source = Source('source')
+        self.sink = Sink('sink')
+        self.c1 = Connection(self.source, 'out1', instance, 'in1')
+        self.c2 = Connection(instance, 'out1', self.sink, 'in1')
+        self.nw.add_conns(self.c1, self.c2)
+
+    def test_Valve(self):
+        """Test component properties of valves."""
+        instance = Valve('valve')
+        self.setup_piping_network(instance)
+
+        # parameter specification
+        self.c1.set_attr(fluid={'CH4': 1}, m=10, p=10, T=120)
+        self.c2.set_attr(p=1)
+
+        # test variable pressure ration
+        instance.set_attr(pr='var')
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        pr = round(self.c2.p.val_SI / self.c1.p.val_SI, 2)
+        msg = ('Value of pressure ratio must be ' + str(pr) + ', is ' +
+               str(round(instance.pr.val, 2)) + '.')
+        assert pr == round(instance.pr.val, 2), msg
+
+        # test variable zeta value
+        zeta = round(instance.zeta.val, 0)
+        instance.set_attr(zeta='var', pr=None)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of dimension independent zeta value must be ' +
+               str(zeta) + ', is ' + str(round(instance.zeta.val, 0)) + '.')
+        assert zeta == round(instance.zeta.val, 0), msg
+
+        # dp char
+        x = np.array([8, 9, 10, 11, 12])
+        y = np.array([5, 8, 9, 9.5, 9.6]) * 1e5
+        dp_char = CharLine(x, y)
+        instance.set_attr(zeta=None, dp_char={
+            'char_func': dp_char, 'is_set': True})
+        m = 11
+        self.c1.set_attr(m=m)
+        self.c2.set_attr(p=np.nan)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        self.nw.print_results()
+        dp = round(-dp_char.evaluate(m), 0)
+        dp_act = round(self.c2.p.val_SI - self.c1.p.val_SI)
+        msg = ('The pressure drop at the valve should be ' + str(dp) + ' but '
+               'is ' + str(dp_act) + '.')
+        assert dp == dp_act, msg
+
+    def test_Pipe(self):
+        """Test component properties of pipe."""
+        instance = Pipe('pipe')
+        self.setup_piping_network(instance)
+
+        # NO TEST NEEDED AT THE MOMENT, THE PIPE PROPERTIES ARE IDENTICAL TO
+        # THE PROPERTIES OF THE SIMPLE HEAT EXCHANGER. TESTS ARE LOCATED AT
+        # heat_exchanger_tests.py
```

### Comparing `TESPy-0.6.2/tests/test_components/test_reactors.py` & `TESPy-0.6.3/tests/test_components/test_reactors.py`

 * *Files 25% similar despite different names*

```diff
@@ -1,181 +1,175 @@
-# -*- coding: utf-8
-
-"""Module for testing components of type reactor.
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location
-tests/test_components/test_reactors.py
-
-SPDX-License-Identifier: MIT
-"""
-
-import shutil
-
-import numpy as np
-
-from tespy.components import Sink
-from tespy.components import Source
-from tespy.components import WaterElectrolyzer
-from tespy.connections import Bus
-from tespy.connections import Connection
-from tespy.networks import Network
-
-
-def convergence_check(lin_dep):
-    """Check convergence status of a simulation."""
-    msg = 'Calculation did not converge!'
-    assert lin_dep is False, msg
-
-
-class TestReactors:
-
-    def setup(self):
-        """Set up network for electrolyzer tests."""
-        self.nw = Network(['O2', 'H2', 'H2O'], T_unit='C', p_unit='bar')
-        self.instance = WaterElectrolyzer('electrolyzer')
-
-        fw = Source('feed water')
-        cw_in = Source('cooling water')
-        o2 = Sink('oxygen sink')
-        h2 = Sink('hydrogen sink')
-        cw_out = Sink('cooling water sink')
-
-        self.instance.set_attr(pr=0.99, eta=1)
-
-        cw_el = Connection(cw_in, 'out1', self.instance, 'in1',
-                           fluid={'H2O': 1, 'H2': 0, 'O2': 0}, T=20, p=1)
-        el_cw = Connection(self.instance, 'out1', cw_out, 'in1', T=45)
-
-        self.nw.add_conns(cw_el, el_cw)
-
-        fw_el = Connection(fw, 'out1', self.instance, 'in2', label='h2o')
-        el_o2 = Connection(self.instance, 'out2', o2, 'in1')
-        el_h2 = Connection(self.instance, 'out3', h2, 'in1', label='h2')
-
-        self.nw.add_conns(fw_el, el_o2, el_h2)
-
-    def test_WaterElectrolyzer(self):
-        """Test component properties of water electrolyzer."""
-        # check bus function:
-        # power output on component and bus must be indentical
-        self.nw.get_conn('h2o').set_attr(T=25, p=1)
-        self.nw.get_conn('h2').set_attr(T=25)
-        power = Bus('power')
-        power.add_comps({'comp': self.instance, 'param': 'P', 'base': 'bus'})
-        power.set_attr(P=2.5e6)
-        self.nw.add_busses(power)
-
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of power must be ' + str(power.P.val) + ', is ' +
-               str(self.instance.P.val) + '.')
-        assert round(power.P.val, 1) == round(self.instance.P.val), msg
-
-        # effieciency was set to 100 % with inlet and outlet states of the
-        # reaction educts and products beeing identical to reference state
-        # therefore Q must be equal to 0
-        msg = ('Value of heat output must be 0.0, is ' +
-               str(self.instance.Q.val) + '.')
-        assert round(self.instance.Q.val, 4) == 0.0, msg
-
-        # reset power, change efficiency value and specify heat bus value
-        power.set_attr(P=np.nan)
-        self.nw.get_conn('h2o').set_attr(T=25, p=1)
-        self.nw.get_conn('h2').set_attr(T=50)
-        self.instance.set_attr(eta=0.8)
-        # check bus function:
-        # heat output on component and bus must be indentical
-        heat = Bus('heat')
-        heat.add_comps({'comp': self.instance, 'param': 'Q'})
-        heat.set_attr(P=-8e5)
-        self.nw.add_busses(heat)
-
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of heat flow must be ' + str(heat.P.val) +
-               ', is ' + str(self.instance.Q.val) + '.')
-        assert round(heat.P.val, 1) == round(self.instance.Q.val), msg
-        self.nw.save('tmp')
-
-        # check bus function:
-        # heat output on component and bus must identical (offdesign test)
-        Q = heat.P.val * 0.9
-        heat.set_attr(P=Q)
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of heat flow must be ' + str(Q) +
-               ', is ' + str(self.instance.Q.val) + '.')
-        assert round(Q, 1) == round(self.instance.Q.val), msg
-
-        # delete both busses again
-        self.nw.del_busses(heat, power)
-
-        # test efficiency vs. specific energy consumption
-        self.nw.get_conn('h2').set_attr(m=0.1)
-        self.instance.set_attr(eta=0.9, e='var')
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of efficiency must be ' + str(self.instance.eta.val) +
-               ', is ' + str(self.instance.e0 / self.instance.e.val) + '.')
-        eta = round(self.instance.eta.val, 2)
-        eta_calc = round(self.instance.e0 / self.instance.e.val, 2)
-        assert eta == eta_calc, msg
-
-        # test efficiency value > 1, Q must be larger than 0
-        e = 130e6
-        self.instance.set_attr(e=np.nan, eta=np.nan)
-        self.instance.set_attr(e=e)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        # test efficiency
-        msg = ('Value of efficiency must be ' + str(self.instance.e0 / e) +
-               ', is ' + str(self.instance.eta.val) + '.')
-        eta = round(self.instance.e0 / e, 2)
-        eta_calc = round(self.instance.eta.val, 2)
-        assert eta == eta_calc, msg
-        # test Q
-        msg = ('Value of heat must be larger than zero, is ' +
-               str(self.instance.Q.val) + '.')
-        assert self.instance.Q.val > 0, msg
-
-        # test specific energy consumption
-        e = 150e6
-        self.instance.set_attr(e=np.nan, eta=np.nan)
-        self.instance.set_attr(e=e)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of specific energy consumption e must be ' + str(e) +
-               ', is ' + str(self.instance.e.val) + '.')
-        assert round(e, 1) == round(self.instance.e.val, 1), msg
-
-        # test cooling loop pressure ratio, zeta as variable value
-        pr = 0.95
-        self.instance.set_attr(
-            pr=pr, e=None, eta=None, zeta='var', P=2e7, design=['pr'])
-        self.nw.solve('design')
-        shutil.rmtree('./tmp', ignore_errors=True)
-        self.nw.save('tmp')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of pressure ratio must be ' + str(pr) + ', is ' +
-               str(self.instance.pr.val) + '.')
-        assert round(pr, 2) == round(self.instance.pr.val, 2), msg
-
-        # use zeta as offdesign parameter, at design point pressure
-        # ratio must not change
-        self.instance.set_attr(zeta=np.nan, offdesign=['zeta'])
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of pressure ratio must be ' + str(pr) + ', is ' +
-               str(self.instance.pr.val) + '.')
-        assert round(pr, 2) == round(self.instance.pr.val, 2), msg
-
-        # test heat output specification in offdesign mode
-        Q = self.instance.Q.val * 0.9
-        self.instance.set_attr(Q=Q, P=np.nan)
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of heat must be ' + str(Q) + ', is ' +
-               str(self.instance.Q.val) + '.')
-        assert round(Q, 0) == round(self.instance.Q.val, 0), msg
-        shutil.rmtree('./tmp', ignore_errors=True)
+# -*- coding: utf-8
+
+"""Module for testing components of type reactor.
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location
+tests/test_components/test_reactors.py
+
+SPDX-License-Identifier: MIT
+"""
+
+import shutil
+
+import numpy as np
+
+from tespy.components import Sink
+from tespy.components import Source
+from tespy.components import WaterElectrolyzer
+from tespy.connections import Bus
+from tespy.connections import Connection
+from tespy.networks import Network
+
+
+class TestReactors:
+
+    def setup_method(self):
+        """Set up network for electrolyzer tests."""
+        self.nw = Network(['O2', 'H2', 'H2O'], T_unit='C', p_unit='bar')
+        self.instance = WaterElectrolyzer('electrolyzer')
+
+        fw = Source('feed water')
+        cw_in = Source('cooling water')
+        o2 = Sink('oxygen sink')
+        h2 = Sink('hydrogen sink')
+        cw_out = Sink('cooling water sink')
+
+        self.instance.set_attr(pr=0.99, eta=1)
+
+        cw_el = Connection(cw_in, 'out1', self.instance, 'in1',
+                           fluid={'H2O': 1, 'H2': 0, 'O2': 0}, T=20, p=1)
+        el_cw = Connection(self.instance, 'out1', cw_out, 'in1', T=45)
+
+        self.nw.add_conns(cw_el, el_cw)
+
+        fw_el = Connection(fw, 'out1', self.instance, 'in2', label='h2o')
+        el_o2 = Connection(self.instance, 'out2', o2, 'in1')
+        el_h2 = Connection(self.instance, 'out3', h2, 'in1', label='h2')
+
+        self.nw.add_conns(fw_el, el_o2, el_h2)
+
+    def test_WaterElectrolyzer(self):
+        """Test component properties of water electrolyzer."""
+        # check bus function:
+        # power output on component and bus must be indentical
+        self.nw.get_conn('h2o').set_attr(T=25, p=1)
+        self.nw.get_conn('h2').set_attr(T=25)
+        power = Bus('power')
+        power.add_comps({'comp': self.instance, 'param': 'P', 'base': 'bus'})
+        power.set_attr(P=2.5e6)
+        self.nw.add_busses(power)
+
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of power must be ' + str(power.P.val) + ', is ' +
+               str(self.instance.P.val) + '.')
+        assert round(power.P.val, 1) == round(self.instance.P.val), msg
+
+        # effieciency was set to 100 % with inlet and outlet states of the
+        # reaction educts and products beeing identical to reference state
+        # therefore Q must be equal to 0
+        msg = ('Value of heat output must be 0.0, is ' +
+               str(self.instance.Q.val) + '.')
+        assert round(self.instance.Q.val, 4) == 0.0, msg
+
+        # reset power, change efficiency value and specify heat bus value
+        power.set_attr(P=np.nan)
+        self.nw.get_conn('h2o').set_attr(T=25, p=1)
+        self.nw.get_conn('h2').set_attr(T=50)
+        self.instance.set_attr(eta=0.8)
+        # check bus function:
+        # heat output on component and bus must be indentical
+        heat = Bus('heat')
+        heat.add_comps({'comp': self.instance, 'param': 'Q'})
+        heat.set_attr(P=-8e5)
+        self.nw.add_busses(heat)
+
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of heat flow must be ' + str(heat.P.val) +
+               ', is ' + str(self.instance.Q.val) + '.')
+        assert round(heat.P.val, 1) == round(self.instance.Q.val), msg
+        self.nw.save('tmp')
+
+        # check bus function:
+        # heat output on component and bus must identical (offdesign test)
+        Q = heat.P.val * 0.9
+        heat.set_attr(P=Q)
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+        msg = ('Value of heat flow must be ' + str(Q) +
+               ', is ' + str(self.instance.Q.val) + '.')
+        assert round(Q, 1) == round(self.instance.Q.val), msg
+
+        # delete both busses again
+        self.nw.del_busses(heat, power)
+
+        # test efficiency vs. specific energy consumption
+        self.nw.get_conn('h2').set_attr(m=0.1)
+        self.instance.set_attr(eta=0.9, e='var')
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of efficiency must be ' + str(self.instance.eta.val) +
+               ', is ' + str(self.instance.e0 / self.instance.e.val) + '.')
+        eta = round(self.instance.eta.val, 2)
+        eta_calc = round(self.instance.e0 / self.instance.e.val, 2)
+        assert eta == eta_calc, msg
+
+        # test efficiency value > 1, Q must be larger than 0
+        e = 130e6
+        self.instance.set_attr(e=np.nan, eta=np.nan)
+        self.instance.set_attr(e=e)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        # test efficiency
+        msg = ('Value of efficiency must be ' + str(self.instance.e0 / e) +
+               ', is ' + str(self.instance.eta.val) + '.')
+        eta = round(self.instance.e0 / e, 2)
+        eta_calc = round(self.instance.eta.val, 2)
+        assert eta == eta_calc, msg
+        # test Q
+        msg = ('Value of heat must be larger than zero, is ' +
+               str(self.instance.Q.val) + '.')
+        assert self.instance.Q.val > 0, msg
+
+        # test specific energy consumption
+        e = 150e6
+        self.instance.set_attr(e=np.nan, eta=np.nan)
+        self.instance.set_attr(e=e)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of specific energy consumption e must be ' + str(e) +
+               ', is ' + str(self.instance.e.val) + '.')
+        assert round(e, 1) == round(self.instance.e.val, 1), msg
+
+        # test cooling loop pressure ratio, zeta as variable value
+        pr = 0.95
+        self.instance.set_attr(
+            pr=pr, e=None, eta=None, zeta='var', P=2e7, design=['pr'])
+        self.nw.solve('design')
+        shutil.rmtree('./tmp', ignore_errors=True)
+        self.nw.save('tmp')
+        self.nw._convergence_check()
+        msg = ('Value of pressure ratio must be ' + str(pr) + ', is ' +
+               str(self.instance.pr.val) + '.')
+        assert round(pr, 2) == round(self.instance.pr.val, 2), msg
+
+        # use zeta as offdesign parameter, at design point pressure
+        # ratio must not change
+        self.instance.set_attr(zeta=np.nan, offdesign=['zeta'])
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+        msg = ('Value of pressure ratio must be ' + str(pr) + ', is ' +
+               str(self.instance.pr.val) + '.')
+        assert round(pr, 2) == round(self.instance.pr.val, 2), msg
+
+        # test heat output specification in offdesign mode
+        Q = self.instance.Q.val * 0.9
+        self.instance.set_attr(Q=Q, P=np.nan)
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+        msg = ('Value of heat must be ' + str(Q) + ', is ' +
+               str(self.instance.Q.val) + '.')
+        assert round(Q, 0) == round(self.instance.Q.val, 0), msg
+        shutil.rmtree('./tmp', ignore_errors=True)
```

### Comparing `TESPy-0.6.2/tests/test_components/test_turbomachinery.py` & `TESPy-0.6.3/tests/test_components/test_turbomachinery.py`

 * *Files 20% similar despite different names*

```diff
@@ -1,387 +1,381 @@
-# -*- coding: utf-8
-
-"""Module for testing components of type turbomachinery.
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location
-tests/test_components/test_turbomachinery.py
-
-SPDX-License-Identifier: MIT
-"""
-import shutil
-
-import numpy as np
-
-from tespy.components import Compressor
-from tespy.components import Pump
-from tespy.components import Sink
-from tespy.components import Source
-from tespy.components import Turbine
-from tespy.components.turbomachinery.base import Turbomachine
-from tespy.connections import Connection
-from tespy.networks import Network
-from tespy.tools.characteristics import CharLine
-from tespy.tools.characteristics import CharMap
-from tespy.tools.characteristics import load_default_char as ldc
-from tespy.tools.fluid_properties import isentropic
-from tespy.tools.fluid_properties import s_mix_ph
-
-
-def convergence_check(lin_dep):
-    """Check convergence status of a simulation."""
-    msg = 'Calculation did not converge!'
-    assert lin_dep is False, msg
-
-
-class TestTurbomachinery:
-
-    def setup_network(self, instance):
-        self.nw = Network(['INCOMP::DowQ', 'NH3', 'N2', 'O2', 'Ar'],
-                          T_unit='C', p_unit='bar', v_unit='m3 / s')
-        self.source = Source('source')
-        self.sink = Sink('sink')
-        self.c1 = Connection(self.source, 'out1', instance, 'in1')
-        self.c2 = Connection(instance, 'out1', self.sink, 'in1')
-        self.nw.add_conns(self.c1, self.c2)
-
-    def test_Compressor(self):
-        """Test component properties of compressors."""
-        instance = Compressor('compressor')
-        self.setup_network(instance)
-
-        # compress NH3, other fluids in network are for turbine, pump, ...
-        fl = {'N2': 1, 'O2': 0, 'Ar': 0, 'DowQ': 0, 'NH3': 0}
-        self.c1.set_attr(fluid=fl, v=1, p=1, T=5)
-        self.c2.set_attr(p=6)
-        instance.set_attr(eta_s=0.8)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        self.nw.save('tmp')
-
-        # test isentropic efficiency value
-        eta_s_d = (
-            (isentropic(self.c1.get_flow(), self.c2.get_flow()) -
-             self.c1.h.val_SI) / (self.c2.h.val_SI - self.c1.h.val_SI))
-        msg = ('Value of isentropic efficiency must be ' + str(eta_s_d) +
-               ', is ' + str(instance.eta_s.val) + '.')
-        assert round(eta_s_d, 3) == round(instance.eta_s.val, 3), msg
-
-        # trigger invalid value for isentropic efficiency
-        instance.set_attr(eta_s=1.1)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-
-        # test calculated value
-        eta_s = (
-            (isentropic(self.c1.get_flow(), self.c2.get_flow()) -
-             self.c1.h.val_SI) / (self.c2.h.val_SI - self.c1.h.val_SI))
-        msg = ('Value of isentropic efficiency must be ' + str(eta_s) +
-               ', is ' + str(instance.eta_s.val) + '.')
-        assert round(eta_s, 3) == round(instance.eta_s.val, 3), msg
-
-        # remove pressure at outlet, use characteristic map for pressure
-        # rise calculation
-        self.c2.set_attr(p=np.nan)
-        instance.set_attr(
-            char_map_pr={'char_func': ldc(
-                'compressor', 'char_map_pr', 'DEFAULT', CharMap),
-                'is_set': True},
-            char_map_eta_s={'char_func': ldc(
-                'compressor', 'char_map_eta_s', 'DEFAULT', CharMap),
-                'is_set': True},
-            eta_s=np.nan, igva=0)
-
-        # offdesign test, efficiency value should be at design value
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of isentropic efficiency (' + str(instance.eta_s.val) +
-               ') must be identical to design case (' + str(eta_s) + ').')
-        assert round(eta_s_d, 2) == round(instance.eta_s.val, 2), msg
-
-        # move to highest available speedline, mass flow below lowest value
-        # at that line
-        self.c1.set_attr(v=np.nan, m=self.c1.m.val * 0.8, T=-30)
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-
-        # should be value
-        eta_s = eta_s_d * instance.char_map_eta_s.char_func.z[6, 0]
-        msg = ('Value of isentropic efficiency (' + str(instance.eta_s.val) +
-               ') must be at (' + str(round(eta_s, 4)) + ').')
-        assert round(eta_s, 4) == round(instance.eta_s.val, 4), msg
-
-        # going below lowest available speedline, above highest mass flow at
-        # that line
-        self.c1.set_attr(T=175)
-        self.nw.solve('offdesign', design_path='tmp', init_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        # should be value
-        eta_s = eta_s_d * instance.char_map_eta_s.char_func.z[0, 9]
-        msg = ('Value of isentropic efficiency (' + str(instance.eta_s.val) +
-               ') must be at (' + str(round(eta_s, 4)) + ').')
-        assert round(eta_s, 4) == round(instance.eta_s.val, 4), msg
-
-        # back to design properties, test eta_s_char
-        self.c2.set_attr(p=6)
-        self.c1.set_attr(v=1, T=5, m=np.nan)
-
-        # test parameter specification for eta_s_char with unset char map
-        instance.set_attr(eta_s_char={'char_func': ldc(
-            'compressor', 'eta_s_char', 'DEFAULT', CharLine),
-            'is_set': True, 'param': 'm'})
-        instance.char_map_eta_s.is_set = False
-        instance.char_map_pr.is_set = False
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of isentropic efficiency must be ' + str(eta_s_d) +
-               ', is ' + str(instance.eta_s.val) + '.')
-        assert round(eta_s_d, 3) == round(instance.eta_s.val, 3), msg
-
-        # move up in volumetric flow
-        self.c1.set_attr(v=1.5)
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        eta_s = round(eta_s_d * instance.eta_s_char.char_func.evaluate(
-            self.c1.m.val_SI / self.c1.m.design), 3)
-        msg = ('Value of isentropic efficiency must be ' + str(eta_s) +
-               ', is ' + str(round(instance.eta_s.val, 3)) + '.')
-        assert eta_s == round(instance.eta_s.val, 3), msg
-
-        # test parameter specification for pr
-        instance.eta_s_char.set_attr(param='pr')
-        self.c1.set_attr(v=1)
-        self.c2.set_attr(p=6)
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        expr = (self.c2.p.val_SI * self.c1.p.design /
-                (self.c2.p.design * self.c1.p.val_SI))
-        eta_s = round(
-            eta_s_d * instance.eta_s_char.char_func.evaluate(expr), 3)
-        msg = ('Value of isentropic efficiency must be ' + str(eta_s) +
-               ', is ' + str(round(instance.eta_s.val, 3)) + '.')
-        assert eta_s == round(instance.eta_s.val, 3), msg
-        shutil.rmtree('./tmp', ignore_errors=True)
-
-    def test_Pump(self):
-        """Test component properties of pumps."""
-        instance = Pump('pump')
-        self.setup_network(instance)
-        fl = {'N2': 0, 'O2': 0, 'Ar': 0, 'DowQ': 1, 'NH3': 0}
-        self.c1.set_attr(fluid=fl, v=1, p=5, T=50)
-        self.c2.set_attr(p=7)
-        instance.set_attr(eta_s=1)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-
-        # test calculated value for efficiency
-        eta_s = (
-            (isentropic(self.c1.get_flow(), self.c2.get_flow()) -
-             self.c1.h.val_SI) / (self.c2.h.val_SI - self.c1.h.val_SI))
-        msg = ('Value of isentropic efficiency must be ' + str(eta_s) +
-               ', is ' + str(instance.eta_s.val) + '.')
-        assert eta_s == instance.eta_s.val, msg
-
-        # isentropic efficiency of 1 means inlet and outlet entropy are
-        # identical
-        s1 = round(s_mix_ph(self.c1.get_flow()), 4)
-        s2 = round(s_mix_ph(self.c2.get_flow()), 4)
-        msg = ('Value of entropy must be identical for inlet (' + str(s1) +
-               ') and outlet (' + str(s2) +
-               ') at 100 % isentropic efficiency.')
-        assert s1 == s2, msg
-
-        # specify realistic value for efficiency, outlet pressure from flow
-        # char
-        eta_s_d = 0.8
-        instance.set_attr(eta_s=eta_s_d)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        self.nw.save('tmp')
-        self.c2.set_attr(p=np.nan)
-
-        # flow char (pressure rise vs. volumetric flow)
-        x = [0, 0.2, 0.4, 0.6, 0.8, 1, 1.2, 1.4]
-        y = np.array([14, 13.5, 12.5, 11, 9, 6.5, 3.5, 0]) * 1e5
-        char = {'char_func': CharLine(x, y), 'is_set': True}
-        # apply flow char and eta_s char
-        instance.set_attr(
-            flow_char=char, eta_s=np.nan, eta_s_char={
-                'char_func': ldc('pump', 'eta_s_char', 'DEFAULT', CharLine),
-                'is_set': True})
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-
-        # value for difference pressure
-        dp = 650000.0
-        msg = ('Value of pressure rise must be ' + str(dp) + ', is ' +
-               str(self.c2.p.val_SI - self.c1.p.val_SI) + '.')
-        assert round(self.c2.p.val_SI - self.c1.p.val_SI, 0) == dp, msg
-
-        # test ohter volumetric flow on flow char
-        self.c1.set_attr(v=0.9)
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        dp = 775000.0
-        msg = ('Value of pressure rise must be ' + str(dp) + ', is ' +
-               str(round(self.c2.p.val_SI - self.c1.p.val_SI, 0)) + '.')
-        assert round(self.c2.p.val_SI - self.c1.p.val_SI, 0) == dp, msg
-
-        # test value of isentropic efficiency
-        eta_s = round(eta_s_d * instance.eta_s_char.char_func.evaluate(
-            self.c1.v.val_SI / self.c1.v.design), 3)
-        msg = ('Value of isentropic efficiency must be ' + str(eta_s) +
-               ', is ' + str(instance.eta_s.val) + '.')
-        assert eta_s == round(instance.eta_s.val, 3), msg
-        instance.eta_s_char.is_set = False
-
-        # test boundaries of characteristic line:
-        # lower boundary
-        instance.set_attr(eta_s=0.8)
-        self.c1.set_attr(m=0, v=None)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of power must be ' + str(14e5) + ', is ' +
-               str(round(self.c2.p.val_SI - self.c1.p.val_SI, 0)) + '.')
-        assert round(self.c2.p.val_SI - self.c1.p.val_SI, 0) == 14e5, msg
-
-        # upper boundary
-        self.c1.set_attr(v=1.5, m=None)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of power must be 0, is ' +
-               str(round(self.c2.p.val_SI - self.c1.p.val_SI, 0)) + '.')
-        assert round(self.c2.p.val_SI - self.c1.p.val_SI, 0) == 0, msg
-        shutil.rmtree('./tmp', ignore_errors=True)
-
-    def test_Turbine(self):
-        """Test component properties of turbines."""
-        instance = Turbine('turbine')
-        self.setup_network(instance)
-        fl = {'N2': 0.7556, 'O2': 0.2315, 'Ar': 0.0129, 'DowQ': 0,
-              'NH3': 0}
-        self.c1.set_attr(fluid=fl, m=15, p=10)
-        self.c2.set_attr(p=1, T=25)
-        instance.set_attr(eta_s=0.85)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        self.nw.save('tmp')
-
-        # design value of isentropic efficiency
-        eta_s_d = (
-            (self.c2.h.val_SI - self.c1.h.val_SI) / (
-                isentropic(self.c1.get_flow(), self.c2.get_flow()) -
-                self.c1.h.val_SI))
-        msg = ('Value of isentropic efficiency must be ' +
-               str(round(eta_s_d, 3)) + ', is ' + str(instance.eta_s.val) +
-               '.')
-        assert round(eta_s_d, 3) == round(instance.eta_s.val, 3), msg
-
-        # trigger invalid value for isentropic efficiency
-        instance.set_attr(eta_s=1.1)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        eta_s = (
-            (self.c2.h.val_SI - self.c1.h.val_SI) / (
-                isentropic(self.c1.get_flow(), self.c2.get_flow()) -
-                self.c1.h.val_SI))
-        msg = ('Value of isentropic efficiency must be ' + str(eta_s) +
-               ', is ' + str(instance.eta_s.val) + '.')
-        assert round(eta_s, 3) == round(instance.eta_s.val, 3), msg
-
-        # unset isentropic efficiency and inlet pressure,
-        # use characteristcs and cone law instead, parameters have to be in
-        # design state
-        self.c1.set_attr(p=np.nan)
-        instance.cone.is_set = True
-        instance.eta_s_char.is_set = True
-        instance.eta_s.is_set = False
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        # check efficiency
-        msg = ('Value of isentropic efficiency (' + str(instance.eta_s.val) +
-               ') must be identical to design case (' + str(eta_s_d) + ').')
-        assert round(eta_s_d, 2) == round(instance.eta_s.val, 2), msg
-        # check pressure
-        msg = ('Value of inlet pressure (' + str(round(self.c1.p.val_SI)) +
-               ') must be identical to design case (' +
-               str(round(self.c1.p.design)) + ').')
-        assert round(self.c1.p.design) == round(self.c1.p.val_SI), msg
-
-        # lowering mass flow, inlet pressure must sink according to cone law
-        self.c1.set_attr(m=self.c1.m.val * 0.8)
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        msg = ('Value of pressure ratio (' + str(instance.pr.val) +
-               ') must be at (' + str(0.128) + ').')
-        assert 0.128 == round(instance.pr.val, 3), msg
-
-        # testing more parameters for eta_s_char
-        # test parameter specification v
-        self.c1.set_attr(m=10)
-        instance.eta_s_char.param = 'v'
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        expr = self.c1.v.val_SI / self.c1.v.design
-        eta_s = round(eta_s_d * instance.eta_s_char.char_func.evaluate(expr), 3)
-        msg = ('Value of isentropic efficiency (' +
-               str(round(instance.eta_s.val, 3)) +
-               ') must be (' + str(eta_s) + ').')
-        assert eta_s == round(instance.eta_s.val, 3), msg
-
-        # test parameter specification pr
-        instance.eta_s_char.param = 'pr'
-        self.nw.solve('offdesign', design_path='tmp')
-        convergence_check(self.nw.lin_dep)
-        expr = (self.c2.p.val_SI * self.c1.p.design /
-                (self.c2.p.design * self.c1.p.val_SI))
-        eta_s = round(eta_s_d * instance.eta_s_char.char_func.evaluate(expr), 3)
-        msg = ('Value of isentropic efficiency (' +
-               str(round(instance.eta_s.val, 3)) +
-               ') must be (' + str(eta_s) + ').')
-        assert eta_s == round(instance.eta_s.val, 3), msg
-        shutil.rmtree('./tmp', ignore_errors=True)
-
-    def test_Turbomachine(self):
-        """Test component properties of turbomachines."""
-        instance = Turbomachine('turbomachine')
-        msg = ('Component name must be turbomachine, is ' +
-               instance.component() + '.')
-        assert 'turbomachine' == instance.component(), msg
-        self.setup_network(instance)
-        fl = {'N2': 0.7556, 'O2': 0.2315, 'Ar': 0.0129, 'DowQ': 0, 'NH3': 0}
-        self.c1.set_attr(fluid=fl, m=10, p=1, h=1e5)
-        self.c2.set_attr(p=3, h=2e5)
-
-        # pressure ratio and power are the basic functions for turbomachines,
-        # these are inherited by all children, thus only tested here
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        power = self.c1.m.val_SI * (self.c2.h.val_SI - self.c1.h.val_SI)
-        pr = self.c2.p.val_SI / self.c1.p.val_SI
-        msg = ('Value of power must be ' + str(power) + ', is ' +
-               str(instance.P.val) + '.')
-        assert power == instance.P.val, msg
-        msg = ('Value of power must be ' + str(pr) + ', is ' +
-               str(instance.pr.val) + '.')
-        assert pr == instance.pr.val, msg
-
-        # test pressure ratio specification
-        self.c2.set_attr(p=np.nan)
-        instance.set_attr(pr=5)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        pr = self.c2.p.val_SI / self.c1.p.val_SI
-        msg = ('Value of power must be ' + str(pr) + ', is ' +
-               str(instance.pr.val) + '.')
-        assert pr == instance.pr.val, msg
-
-        # test power specification
-        self.c2.set_attr(h=np.nan)
-        instance.set_attr(P=1e5)
-        self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
-        power = self.c1.m.val_SI * (self.c2.h.val_SI - self.c1.h.val_SI)
-        msg = ('Value of power must be ' + str(power) + ', is ' +
-               str(instance.P.val) + '.')
-        assert power == instance.P.val, msg
+# -*- coding: utf-8
+
+"""Module for testing components of type turbomachinery.
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location
+tests/test_components/test_turbomachinery.py
+
+SPDX-License-Identifier: MIT
+"""
+import shutil
+
+import numpy as np
+
+from tespy.components import Compressor
+from tespy.components import Pump
+from tespy.components import Sink
+from tespy.components import Source
+from tespy.components import Turbine
+from tespy.components.turbomachinery.base import Turbomachine
+from tespy.connections import Connection
+from tespy.networks import Network
+from tespy.tools.characteristics import CharLine
+from tespy.tools.characteristics import CharMap
+from tespy.tools.characteristics import load_default_char as ldc
+from tespy.tools.fluid_properties import isentropic
+from tespy.tools.fluid_properties import s_mix_ph
+
+
+class TestTurbomachinery:
+
+    def setup_network(self, instance):
+        self.nw = Network(['INCOMP::DowQ', 'NH3', 'N2', 'O2', 'Ar'],
+                          T_unit='C', p_unit='bar', v_unit='m3 / s')
+        self.source = Source('source')
+        self.sink = Sink('sink')
+        self.c1 = Connection(self.source, 'out1', instance, 'in1')
+        self.c2 = Connection(instance, 'out1', self.sink, 'in1')
+        self.nw.add_conns(self.c1, self.c2)
+
+    def test_Compressor(self):
+        """Test component properties of compressors."""
+        instance = Compressor('compressor')
+        self.setup_network(instance)
+
+        # compress NH3, other fluids in network are for turbine, pump, ...
+        fl = {'N2': 1, 'O2': 0, 'Ar': 0, 'DowQ': 0, 'NH3': 0}
+        self.c1.set_attr(fluid=fl, v=1, p=1, T=5)
+        self.c2.set_attr(p=6)
+        instance.set_attr(eta_s=0.8)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        self.nw.save('tmp')
+
+        # test isentropic efficiency value
+        eta_s_d = (
+            (isentropic(self.c1.get_flow(), self.c2.get_flow()) -
+             self.c1.h.val_SI) / (self.c2.h.val_SI - self.c1.h.val_SI))
+        msg = ('Value of isentropic efficiency must be ' + str(eta_s_d) +
+               ', is ' + str(instance.eta_s.val) + '.')
+        assert round(eta_s_d, 3) == round(instance.eta_s.val, 3), msg
+
+        # trigger invalid value for isentropic efficiency
+        instance.set_attr(eta_s=1.1)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+
+        # test calculated value
+        eta_s = (
+            (isentropic(self.c1.get_flow(), self.c2.get_flow()) -
+             self.c1.h.val_SI) / (self.c2.h.val_SI - self.c1.h.val_SI))
+        msg = ('Value of isentropic efficiency must be ' + str(eta_s) +
+               ', is ' + str(instance.eta_s.val) + '.')
+        assert round(eta_s, 3) == round(instance.eta_s.val, 3), msg
+
+        # remove pressure at outlet, use characteristic map for pressure
+        # rise calculation
+        self.c2.set_attr(p=np.nan)
+        instance.set_attr(
+            char_map_pr={'char_func': ldc(
+                'compressor', 'char_map_pr', 'DEFAULT', CharMap),
+                'is_set': True},
+            char_map_eta_s={'char_func': ldc(
+                'compressor', 'char_map_eta_s', 'DEFAULT', CharMap),
+                'is_set': True},
+            eta_s=np.nan, igva=0)
+
+        # offdesign test, efficiency value should be at design value
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+        msg = ('Value of isentropic efficiency (' + str(instance.eta_s.val) +
+               ') must be identical to design case (' + str(eta_s) + ').')
+        assert round(eta_s_d, 2) == round(instance.eta_s.val, 2), msg
+
+        # move to highest available speedline, mass flow below lowest value
+        # at that line
+        self.c1.set_attr(v=np.nan, m=self.c1.m.val * 0.8, T=-30)
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+
+        # should be value
+        eta_s = eta_s_d * instance.char_map_eta_s.char_func.z[6, 0]
+        msg = ('Value of isentropic efficiency (' + str(instance.eta_s.val) +
+               ') must be at (' + str(round(eta_s, 4)) + ').')
+        assert round(eta_s, 4) == round(instance.eta_s.val, 4), msg
+
+        # going below lowest available speedline, above highest mass flow at
+        # that line
+        self.c1.set_attr(T=175)
+        self.nw.solve('offdesign', design_path='tmp', init_path='tmp')
+        self.nw._convergence_check()
+        # should be value
+        eta_s = eta_s_d * instance.char_map_eta_s.char_func.z[0, 9]
+        msg = ('Value of isentropic efficiency (' + str(instance.eta_s.val) +
+               ') must be at (' + str(round(eta_s, 4)) + ').')
+        assert round(eta_s, 4) == round(instance.eta_s.val, 4), msg
+
+        # back to design properties, test eta_s_char
+        self.c2.set_attr(p=6)
+        self.c1.set_attr(v=1, T=5, m=np.nan)
+
+        # test parameter specification for eta_s_char with unset char map
+        instance.set_attr(eta_s_char={'char_func': ldc(
+            'compressor', 'eta_s_char', 'DEFAULT', CharLine),
+            'is_set': True, 'param': 'm'})
+        instance.char_map_eta_s.is_set = False
+        instance.char_map_pr.is_set = False
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+        msg = ('Value of isentropic efficiency must be ' + str(eta_s_d) +
+               ', is ' + str(instance.eta_s.val) + '.')
+        assert round(eta_s_d, 3) == round(instance.eta_s.val, 3), msg
+
+        # move up in volumetric flow
+        self.c1.set_attr(v=1.5)
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+        eta_s = round(eta_s_d * instance.eta_s_char.char_func.evaluate(
+            self.c1.m.val_SI / self.c1.m.design), 3)
+        msg = ('Value of isentropic efficiency must be ' + str(eta_s) +
+               ', is ' + str(round(instance.eta_s.val, 3)) + '.')
+        assert eta_s == round(instance.eta_s.val, 3), msg
+
+        # test parameter specification for pr
+        instance.eta_s_char.set_attr(param='pr')
+        self.c1.set_attr(v=1)
+        self.c2.set_attr(p=6)
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+        expr = (self.c2.p.val_SI * self.c1.p.design /
+                (self.c2.p.design * self.c1.p.val_SI))
+        eta_s = round(
+            eta_s_d * instance.eta_s_char.char_func.evaluate(expr), 3)
+        msg = ('Value of isentropic efficiency must be ' + str(eta_s) +
+               ', is ' + str(round(instance.eta_s.val, 3)) + '.')
+        assert eta_s == round(instance.eta_s.val, 3), msg
+        shutil.rmtree('./tmp', ignore_errors=True)
+
+    def test_Pump(self):
+        """Test component properties of pumps."""
+        instance = Pump('pump')
+        self.setup_network(instance)
+        fl = {'N2': 0, 'O2': 0, 'Ar': 0, 'DowQ': 1, 'NH3': 0}
+        self.c1.set_attr(fluid=fl, v=1, p=5, T=50)
+        self.c2.set_attr(p=7)
+        instance.set_attr(eta_s=1)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+
+        # test calculated value for efficiency
+        eta_s = (
+            (isentropic(self.c1.get_flow(), self.c2.get_flow()) -
+             self.c1.h.val_SI) / (self.c2.h.val_SI - self.c1.h.val_SI))
+        msg = ('Value of isentropic efficiency must be ' + str(eta_s) +
+               ', is ' + str(instance.eta_s.val) + '.')
+        assert eta_s == instance.eta_s.val, msg
+
+        # isentropic efficiency of 1 means inlet and outlet entropy are
+        # identical
+        s1 = round(s_mix_ph(self.c1.get_flow()), 4)
+        s2 = round(s_mix_ph(self.c2.get_flow()), 4)
+        msg = ('Value of entropy must be identical for inlet (' + str(s1) +
+               ') and outlet (' + str(s2) +
+               ') at 100 % isentropic efficiency.')
+        assert s1 == s2, msg
+
+        # specify realistic value for efficiency, outlet pressure from flow
+        # char
+        eta_s_d = 0.8
+        instance.set_attr(eta_s=eta_s_d)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        self.nw.save('tmp')
+        self.c2.set_attr(p=np.nan)
+
+        # flow char (pressure rise vs. volumetric flow)
+        x = [0, 0.2, 0.4, 0.6, 0.8, 1, 1.2, 1.4]
+        y = np.array([14, 13.5, 12.5, 11, 9, 6.5, 3.5, 0]) * 1e5
+        char = {'char_func': CharLine(x, y), 'is_set': True}
+        # apply flow char and eta_s char
+        instance.set_attr(
+            flow_char=char, eta_s=np.nan, eta_s_char={
+                'char_func': ldc('pump', 'eta_s_char', 'DEFAULT', CharLine),
+                'is_set': True})
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+
+        # value for difference pressure
+        dp = 650000.0
+        msg = ('Value of pressure rise must be ' + str(dp) + ', is ' +
+               str(self.c2.p.val_SI - self.c1.p.val_SI) + '.')
+        assert round(self.c2.p.val_SI - self.c1.p.val_SI, 0) == dp, msg
+
+        # test ohter volumetric flow on flow char
+        self.c1.set_attr(v=0.9)
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+        dp = 775000.0
+        msg = ('Value of pressure rise must be ' + str(dp) + ', is ' +
+               str(round(self.c2.p.val_SI - self.c1.p.val_SI, 0)) + '.')
+        assert round(self.c2.p.val_SI - self.c1.p.val_SI, 0) == dp, msg
+
+        # test value of isentropic efficiency
+        eta_s = round(eta_s_d * instance.eta_s_char.char_func.evaluate(
+            self.c1.v.val_SI / self.c1.v.design), 3)
+        msg = ('Value of isentropic efficiency must be ' + str(eta_s) +
+               ', is ' + str(instance.eta_s.val) + '.')
+        assert eta_s == round(instance.eta_s.val, 3), msg
+        instance.eta_s_char.is_set = False
+
+        # test boundaries of characteristic line:
+        # lower boundary
+        instance.set_attr(eta_s=0.8)
+        self.c1.set_attr(m=0, v=None)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of power must be ' + str(14e5) + ', is ' +
+               str(round(self.c2.p.val_SI - self.c1.p.val_SI, 0)) + '.')
+        assert round(self.c2.p.val_SI - self.c1.p.val_SI, 0) == 14e5, msg
+
+        # upper boundary
+        self.c1.set_attr(v=1.5, m=None)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        msg = ('Value of power must be 0, is ' +
+               str(round(self.c2.p.val_SI - self.c1.p.val_SI, 0)) + '.')
+        assert round(self.c2.p.val_SI - self.c1.p.val_SI, 0) == 0, msg
+        shutil.rmtree('./tmp', ignore_errors=True)
+
+    def test_Turbine(self):
+        """Test component properties of turbines."""
+        instance = Turbine('turbine')
+        self.setup_network(instance)
+        fl = {'N2': 0.7556, 'O2': 0.2315, 'Ar': 0.0129, 'DowQ': 0,
+              'NH3': 0}
+        self.c1.set_attr(fluid=fl, m=15, p=10)
+        self.c2.set_attr(p=1, T=25)
+        instance.set_attr(eta_s=0.85)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        self.nw.save('tmp')
+
+        # design value of isentropic efficiency
+        eta_s_d = (
+            (self.c2.h.val_SI - self.c1.h.val_SI) / (
+                isentropic(self.c1.get_flow(), self.c2.get_flow()) -
+                self.c1.h.val_SI))
+        msg = ('Value of isentropic efficiency must be ' +
+               str(round(eta_s_d, 3)) + ', is ' + str(instance.eta_s.val) +
+               '.')
+        assert round(eta_s_d, 3) == round(instance.eta_s.val, 3), msg
+
+        # trigger invalid value for isentropic efficiency
+        instance.set_attr(eta_s=1.1)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        eta_s = (
+            (self.c2.h.val_SI - self.c1.h.val_SI) / (
+                isentropic(self.c1.get_flow(), self.c2.get_flow()) -
+                self.c1.h.val_SI))
+        msg = ('Value of isentropic efficiency must be ' + str(eta_s) +
+               ', is ' + str(instance.eta_s.val) + '.')
+        assert round(eta_s, 3) == round(instance.eta_s.val, 3), msg
+
+        # unset isentropic efficiency and inlet pressure,
+        # use characteristcs and cone law instead, parameters have to be in
+        # design state
+        self.c1.set_attr(p=np.nan)
+        instance.cone.is_set = True
+        instance.eta_s_char.is_set = True
+        instance.eta_s.is_set = False
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+        # check efficiency
+        msg = ('Value of isentropic efficiency (' + str(instance.eta_s.val) +
+               ') must be identical to design case (' + str(eta_s_d) + ').')
+        assert round(eta_s_d, 2) == round(instance.eta_s.val, 2), msg
+        # check pressure
+        msg = ('Value of inlet pressure (' + str(round(self.c1.p.val_SI)) +
+               ') must be identical to design case (' +
+               str(round(self.c1.p.design)) + ').')
+        assert round(self.c1.p.design) == round(self.c1.p.val_SI), msg
+
+        # lowering mass flow, inlet pressure must sink according to cone law
+        self.c1.set_attr(m=self.c1.m.val * 0.8)
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+        msg = ('Value of pressure ratio (' + str(instance.pr.val) +
+               ') must be at (' + str(0.128) + ').')
+        assert 0.128 == round(instance.pr.val, 3), msg
+
+        # testing more parameters for eta_s_char
+        # test parameter specification v
+        self.c1.set_attr(m=10)
+        instance.eta_s_char.param = 'v'
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+        expr = self.c1.v.val_SI / self.c1.v.design
+        eta_s = round(eta_s_d * instance.eta_s_char.char_func.evaluate(expr), 3)
+        msg = ('Value of isentropic efficiency (' +
+               str(round(instance.eta_s.val, 3)) +
+               ') must be (' + str(eta_s) + ').')
+        assert eta_s == round(instance.eta_s.val, 3), msg
+
+        # test parameter specification pr
+        instance.eta_s_char.param = 'pr'
+        self.nw.solve('offdesign', design_path='tmp')
+        self.nw._convergence_check()
+        expr = (self.c2.p.val_SI * self.c1.p.design /
+                (self.c2.p.design * self.c1.p.val_SI))
+        eta_s = round(eta_s_d * instance.eta_s_char.char_func.evaluate(expr), 3)
+        msg = ('Value of isentropic efficiency (' +
+               str(round(instance.eta_s.val, 3)) +
+               ') must be (' + str(eta_s) + ').')
+        assert eta_s == round(instance.eta_s.val, 3), msg
+        shutil.rmtree('./tmp', ignore_errors=True)
+
+    def test_Turbomachine(self):
+        """Test component properties of turbomachines."""
+        instance = Turbomachine('turbomachine')
+        msg = ('Component name must be turbomachine, is ' +
+               instance.component() + '.')
+        assert 'turbomachine' == instance.component(), msg
+        self.setup_network(instance)
+        fl = {'N2': 0.7556, 'O2': 0.2315, 'Ar': 0.0129, 'DowQ': 0, 'NH3': 0}
+        self.c1.set_attr(fluid=fl, m=10, p=1, h=1e5)
+        self.c2.set_attr(p=3, h=2e5)
+
+        # pressure ratio and power are the basic functions for turbomachines,
+        # these are inherited by all children, thus only tested here
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        power = self.c1.m.val_SI * (self.c2.h.val_SI - self.c1.h.val_SI)
+        pr = self.c2.p.val_SI / self.c1.p.val_SI
+        msg = ('Value of power must be ' + str(power) + ', is ' +
+               str(instance.P.val) + '.')
+        assert power == instance.P.val, msg
+        msg = ('Value of power must be ' + str(pr) + ', is ' +
+               str(instance.pr.val) + '.')
+        assert pr == instance.pr.val, msg
+
+        # test pressure ratio specification
+        self.c2.set_attr(p=np.nan)
+        instance.set_attr(pr=5)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        pr = self.c2.p.val_SI / self.c1.p.val_SI
+        msg = ('Value of power must be ' + str(pr) + ', is ' +
+               str(instance.pr.val) + '.')
+        assert pr == instance.pr.val, msg
+
+        # test power specification
+        self.c2.set_attr(h=np.nan)
+        instance.set_attr(P=1e5)
+        self.nw.solve('design')
+        self.nw._convergence_check()
+        power = self.c1.m.val_SI * (self.c2.h.val_SI - self.c1.h.val_SI)
+        msg = ('Value of power must be ' + str(power) + ', is ' +
+               str(instance.P.val) + '.')
+        assert power == instance.P.val, msg
```

### Comparing `TESPy-0.6.2/tests/test_connections.py` & `TESPy-0.6.3/tests/test_connections.py`

 * *Files 6% similar despite different names*

```diff
@@ -15,15 +15,15 @@
 from tespy.connections import Connection
 from tespy.connections import Ref
 from tespy.networks import Network
 
 
 class TestConnections:
 
-    def setup(self):
+    def setup_method(self):
         """Set up the model."""
         # %% network setup
         fluid_list = ['Air']
         self.nw = Network(
             fluids=fluid_list, p_unit='bar', T_unit='C', p_range=[0.5, 20])
 
         # %% components
```

### Comparing `TESPy-0.6.2/tests/test_errors.py` & `TESPy-0.6.3/tests/test_errors.py`

 * *Files 1% similar despite different names*

```diff
@@ -287,15 +287,15 @@
 
 ##############################################################################
 # combustion_engine
 
 
 class TestCombustionEngineBusErrors:
 
-    def setup(self):
+    def setup_method(self):
         self.nw = Network(['water', 'air'])
         self.instance = CombustionEngine('combustion engine')
         self.bus = Bus('power')
         self.bus.add_comps({'comp': self.instance, 'param': 'Param'})
 
     def test_missing_Bus_param_func(self):
         """Test wrong/missing bus parameter in bus function."""
@@ -442,15 +442,15 @@
 
 
 ##############################################################################
 # test errors of Network class
 
 class TestNetworkErrors:
 
-    def setup(self):
+    def setup_method(self):
         self.nw = Network(['water'])
 
     def test_add_conns_TypeError(self):
         with raises(TypeError):
             self.nw.add_conns(Component('test'))
 
     def test_no_connections_error(self):
```

### Comparing `TESPy-0.6.2/tests/test_models/test_heat_pump_model.py` & `TESPy-0.6.3/tests/test_models/test_heat_pump_model.py`

 * *Files 1% similar despite different names*

```diff
@@ -27,15 +27,15 @@
 from tespy.connections import Ref
 from tespy.networks import Network
 from tespy.tools.characteristics import CharLine
 
 
 class TestHeatPump:
 
-    def setup(self):
+    def setup_method(self):
         # %% network setup
         self.nw = Network(fluids=['water', 'NH3'], T_unit='C', p_unit='bar',
                           h_unit='kJ / kg', m_unit='kg / s')
 
         # %% components
         # sources & sinks
         cc_refrigerant = CycleCloser('refrigerant cycle closer')
```

### Comparing `TESPy-0.6.2/tests/test_models/test_solar_energy_generating_system.py` & `TESPy-0.6.3/tests/test_models/test_solar_energy_generating_system.py`

 * *Files 10% similar despite different names*

```diff
@@ -1,416 +1,416 @@
-# -*- coding: utf-8
-
-"""Module for testing a tespy simulation vs results from a different simulator.
-
-This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
-by the contributors recorded in the version control history of the file,
-available from its original location
-tests/test_models/test_solar_energy_generating_system.py
-
-SPDX-License-Identifier: MIT
-"""
-from tespy.components import Compressor
-from tespy.components import Condenser
-from tespy.components import CycleCloser
-from tespy.components import Drum
-from tespy.components import HeatExchanger
-from tespy.components import Merge
-from tespy.components import ParabolicTrough
-from tespy.components import Pump
-from tespy.components import Sink
-from tespy.components import Source
-from tespy.components import Splitter
-from tespy.components import Turbine
-from tespy.components import Valve
-from tespy.connections import Bus
-from tespy.connections import Connection
-from tespy.connections import Ref
-from tespy.networks import Network
-from tespy.tools import ExergyAnalysis
-
-
-class TestSEGS:
-
-    def setup(self):
-        """
-        Full model validation of SEGS model in TESPy vs. EBSILON.
-
-        Find original models at https://github.com/fwitte/SEGS_exergy.
-        """
-        # specification of ambient state
-        self.pamb = 1.013
-        self.Tamb = 25
-
-        # setting up network
-        self.nw = Network(fluids=['water', 'INCOMP::TVP1', 'air'])
-        self.nw.set_attr(
-            T_unit='C', p_unit='bar', h_unit='kJ / kg', m_unit='kg / s',
-            s_unit="kJ / kgK")
-
-        # components definition
-        air_in = Source('Ambient air source', fkt_group='CW')
-        air_out = Sink('Ambient air sink', fkt_group='CW')
-
-        closer_pt = CycleCloser('Cycle closer pt', fkt_group='SF')
-        pt = ParabolicTrough('Parabolic trough', fkt_group='SF')
-        ptpump = Pump('HTF pump', fkt_group='SF')
-
-        closer = CycleCloser('Cycle closer power cycle', fkt_group='SG')
-
-        eco = HeatExchanger('Economizer', fkt_group='SG')
-        eva = HeatExchanger('Evaporator', fkt_group='SG')
-        sup = HeatExchanger('Superheater', fkt_group='SG')
-        drum = Drum('Drum', fkt_group='SG')
-
-        reh = HeatExchanger('Reheater', fkt_group='RH')
-
-        hpt1 = Turbine('HP turbine 1', fkt_group='HPT')
-        hpt2 = Turbine('HP turbine 2', fkt_group='HPT')
-        lpt1 = Turbine('LP turbine 1', fkt_group='LPT')
-        lpt2 = Turbine('LP turbine 2', fkt_group='LPT')
-        lpt3 = Turbine('LP turbine 3', fkt_group='LPT')
-        lpt4 = Turbine('LP turbine 4', fkt_group='LPT')
-        lpt5 = Turbine('LP turbine 5', fkt_group='LPT')
-
-        cond = Condenser('Condenser', fkt_group='CW')
-        condpump = Pump('Condenser pump', fkt_group='CW')
-        fwt = Merge('Feedwater tank', num_in=3, fkt_group='LPP')
-        fwp = Pump('Feedwater pump', fkt_group='FWP')
-        cwp = Pump('Cooling water pump', fkt_group='CW')
-        closer_cw = CycleCloser('Cycle closer cw', fkt_group='CW')
-        ct = HeatExchanger('Cooling tower', fkt_group='CW')
-        fan = Compressor('Cooling tower fan', fkt_group='CW')
-
-        sp1 = Splitter('Splitter 1', fkt_group='HPT')
-        sp2 = Splitter('Splitter 2', fkt_group='HPT')
-        sp3 = Splitter('Splitter 3', fkt_group='LPT')
-        sp4 = Splitter('Splitter 4', fkt_group='LPT')
-        sp5 = Splitter('Splitter 5', fkt_group='LPT')
-        sp6 = Splitter('Splitter 6', fkt_group='LPT')
-        sp7 = Splitter('Splitter 7', fkt_group='SF')
-
-        m1 = Merge('Merge 1', fkt_group='CW')
-        m2 = Merge('Merge 2', fkt_group='HPP')
-        m3 = Merge('Merge 3', fkt_group='LPP')
-        m4 = Merge('Merge 4', fkt_group='LPP')
-        m5 = Merge('Merge 5', fkt_group='SF')
-
-        v1 = Valve('Valve 1', fkt_group='HPP')
-        v2 = Valve('Valve 2', fkt_group='HPP')
-        v3 = Valve('Valve 3', fkt_group='LPP')
-        v4 = Valve('Valve 4', fkt_group='LPP')
-        v5 = Valve('Valve 5', fkt_group='LPP')
-
-        hppre1 = Condenser('High pressure preheater 1', fkt_group='HPP')
-        hppre2 = Condenser('High pressure preheater 2', fkt_group='HPP')
-        hppre1_sub = HeatExchanger(
-            'High pressure preheater 1 subcooling', fkt_group='HPP')
-        hppre2_sub = HeatExchanger(
-            'High pressure preheater 2 subcooling', fkt_group='HPP')
-
-        lppre1 = Condenser('Low pressure preheater 1', fkt_group='LPP')
-        lppre2 = Condenser('Low pressure preheater 2', fkt_group='LPP')
-        lppre3 = Condenser('Low pressure preheater 3', fkt_group='LPP')
-        lppre1_sub = HeatExchanger(
-            'Low pressure preheater 1 subcooling', fkt_group='LPP')
-        lppre2_sub = HeatExchanger(
-            'Low pressure preheater 2 subcooling', fkt_group='LPP')
-        lppre3_sub = HeatExchanger(
-            'Low pressure preheater 3 subcooling', fkt_group='LPP')
-
-        # connections definition
-        # power cycle
-        c1 = Connection(sup, 'out2', closer, 'in1', label='1')
-        c2 = Connection(closer, 'out1', hpt1, 'in1', label='2')
-        c3 = Connection(hpt1, 'out1', sp1, 'in1', label='3')
-        c4 = Connection(sp1, 'out1', hpt2, 'in1', label='4')
-        c5 = Connection(hpt2, 'out1', sp2, 'in1', label='5')
-        c6 = Connection(sp2, 'out1', reh, 'in2', label='6')
-        c7 = Connection(reh, 'out2', lpt1, 'in1', label='7')
-        c8 = Connection(lpt1, 'out1', sp3, 'in1', label='8')
-        c9 = Connection(sp3, 'out1', lpt2, 'in1', label='9')
-        c10 = Connection(lpt2, 'out1', sp4, 'in1', label='10')
-        c11 = Connection(sp4, 'out1', lpt3, 'in1', label='11')
-        c12 = Connection(lpt3, 'out1', sp5, 'in1', label='12')
-        c13 = Connection(sp5, 'out1', lpt4, 'in1', label='13')
-        c14 = Connection(lpt4, 'out1', sp6, 'in1', label='14')
-        c15 = Connection(sp6, 'out1', lpt5, 'in1', label='15')
-        c16 = Connection(lpt5, 'out1', m1, 'in1', label='16')
-        c17 = Connection(m1, 'out1', cond, 'in1', label='17')
-        c18 = Connection(cond, 'out1', condpump, 'in1', label='18')
-        c19 = Connection(condpump, 'out1', lppre1, 'in2', label='19')
-        # c19 = Connection(condpump, 'out1', lppre1_sub, 'in2', label='19')
-        # c20 = Connection(lppre1_sub, 'out2', lppre1, 'in2', label='20')
-        c21 = Connection(lppre1, 'out2', lppre2, 'in2', label='21')
-        # c21 = Connection(lppre1, 'out2', lppre2_sub, 'in2', label='21')
-        # c22 = Connection(lppre2_sub, 'out2', lppre2, 'in2', label='22')
-        c23 = Connection(lppre2, 'out2', lppre3, 'in2', label='23')
-        # c23 = Connection(lppre2, 'out2', lppre3_sub, 'in2', label='23')
-        # c24 = Connection(lppre3_sub, 'out2', lppre3, 'in2', label='24')
-        c25 = Connection(lppre3, 'out2', fwt, 'in1', label='25')
-        c26 = Connection(fwt, 'out1', fwp, 'in1', label='26')
-        c27 = Connection(fwp, 'out1', hppre1, 'in2', label='27')
-        c29 = Connection(hppre1, 'out2', hppre2, 'in2', label='29')
-        c31 = Connection(hppre2, 'out2', eco, 'in2', label='31')
-
-        c36 = Connection(sp1, 'out2', hppre2, 'in1', label='36')
-        c37 = Connection(hppre2, 'out1', v1, 'in1', label='37')
-        c39 = Connection(v1, 'out1', m2, 'in2', label='39')
-        c40 = Connection(sp2, 'out2', m2, 'in1', label='40')
-        c41 = Connection(m2, 'out1', hppre1, 'in1', label='41')
-        c42 = Connection(hppre1, 'out1', v2, 'in1', label='42')
-        c44 = Connection(v2, 'out1', fwt, 'in2', label='44')
-        c45 = Connection(sp3, 'out2', fwt, 'in3', label='45')
-        c46 = Connection(sp4, 'out2', lppre3, 'in1', label='46')
-        c47 = Connection(lppre3, 'out1', v3, 'in1', label='47')
-        # c47 = Connection(lppre3, 'out1', lppre3_sub, 'in1', label='47')
-        # c48 = Connection(lppre3_sub, 'out1', v3, 'in1', label='48')
-        c49 = Connection(v3, 'out1', m3, 'in1', label='49')
-        c50 = Connection(sp5, 'out2', m3, 'in2', label='50')
-        c51 = Connection(m3, 'out1', lppre2, 'in1', label='51')
-        c52 = Connection(lppre2, 'out1', v4, 'in1', label='52')
-        # c52 = Connection(lppre2, 'out1', lppre2_sub, 'in1', label='52')
-        # c53 = Connection(lppre2_sub, 'out1', v4, 'in1', label='53')
-        c54 = Connection(v4, 'out1', m4, 'in2', label='54')
-        c55 = Connection(sp6, 'out2', m4, 'in1', label='55')
-        c56 = Connection(m4, 'out1', lppre1, 'in1', label='56')
-        c57 = Connection(lppre1, 'out1', v5, 'in1', label='57')
-        # c57 = Connection(lppre1, 'out1', lppre1_sub, 'in1', label='57')
-        # c58 = Connection(lppre1_sub, 'out1', v5, 'in1', label='58')
-        c59 = Connection(v5, 'out1', m1, 'in2', label='59')
-
-        # components from subsystem
-        c32 = Connection(eco, 'out2', drum, 'in1', label='32')
-        c33 = Connection(drum, 'out1', eva, 'in2', label='33')
-        c34 = Connection(eva, 'out2', drum, 'in2', label='34')
-        c35 = Connection(drum, 'out2', sup, 'in2', label='35')
-        c73 = Connection(sup, 'out1', eva, 'in1', label='73')
-        c74 = Connection(eva, 'out1', eco, 'in1', label='74')
-
-        # cooling water
-        c60 = Connection(cond, 'out2', closer_cw, 'in1', label='60')
-        c61 = Connection(closer_cw, 'out1', ct, 'in1', label='61')
-        c62 = Connection(ct, 'out1', cwp, 'in1', label='62')
-        c63 = Connection(cwp, 'out1', cond, 'in2', label='63')
-
-        # cooling tower
-        c64 = Connection(air_in, 'out1', fan, 'in1', label='64')
-        c65 = Connection(fan, 'out1', ct, 'in2', label='65')
-        c66 = Connection(ct, 'out2', air_out, 'in1', label='66')
-
-        # parabolic trough cycle
-        c70 = Connection(pt, 'out1', closer_pt, 'in1', label='67')
-        c71 = Connection(closer_pt, 'out1', sp7, 'in1', label='71')
-        c72 = Connection(sp7, 'out1', sup, 'in1', label='72')
-        c75 = Connection(eco, 'out1', m5, 'in1', label='75')
-        c76 = Connection(sp7, 'out2', reh, 'in1', label='76')
-        c77 = Connection(reh, 'out1', m5, 'in2', label='77')
-        c78 = Connection(m5, 'out1', ptpump, 'in1', label='78')
-        c79 = Connection(ptpump, 'out1', pt, 'in1', label='79')
-
-        # add connections to network
-        self.nw.add_conns(
-            c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15,
-            c16, c17, c18, c19, c21, c23, c25, c26, c27, c29, c31, c32, c33,
-            c34, c35, c36, c37, c39, c40, c41, c42, c44, c45, c46, c47, c49,
-            c50, c51, c52, c54, c55, c56, c57, c59, c60, c61, c62, c63, c64,
-            c65, c66, c70, c71, c72, c73, c74, c75, c76, c77, c78, c79)
-
-        # power bus
-        power = Bus('total output power')
-        power.add_comps(
-            {'comp': hpt1, 'char': 0.97, 'base': 'component'},
-            {'comp': hpt2, 'char': 0.97, 'base': 'component'},
-            {'comp': lpt1, 'char': 0.97, 'base': 'component'},
-            {'comp': lpt2, 'char': 0.97, 'base': 'component'},
-            {'comp': lpt3, 'char': 0.97, 'base': 'component'},
-            {'comp': lpt4, 'char': 0.97, 'base': 'component'},
-            {'comp': lpt5, 'char': 0.97, 'base': 'component'},
-            {'comp': fwp, 'char': 0.95, 'base': 'bus'},
-            {'comp': condpump, 'char': 0.95, 'base': 'bus'},
-            {'comp': ptpump, 'char': 0.95, 'base': 'bus'},
-            {'comp': cwp, 'char': 0.95, 'base': 'bus'},
-            {'comp': fan, 'char': 0.95, 'base': 'bus'})
-
-        heat_input_bus = Bus('heat input')
-        heat_input_bus.add_comps({'comp': pt, 'base': 'bus'})
-
-        exergy_loss_bus = Bus('exergy loss')
-        exergy_loss_bus.add_comps(
-            {'comp': air_in, 'base': 'bus'}, {'comp': air_out})
-
-        self.nw.add_busses(power, heat_input_bus, exergy_loss_bus)
-
-        # component parameters
-        pt.set_attr(doc=0.95, aoi=0,
-                    Tamb=25, A='var', eta_opt=0.73,
-                    c_1=0.00496, c_2=0.000691, E=1000,
-                    iam_1=1, iam_2=1)
-
-        ptpump.set_attr(eta_s=0.6)
-
-        eco.set_attr()
-        eva.set_attr(ttd_l=5)
-        sup.set_attr()
-
-        hpt1.set_attr(eta_s=0.8376)
-        hpt2.set_attr(eta_s=0.8463)
-        lpt1.set_attr(eta_s=0.8623)
-        lpt2.set_attr(eta_s=0.917)
-        lpt3.set_attr(eta_s=0.9352)
-        lpt4.set_attr(eta_s=0.88)
-        lpt5.set_attr(eta_s=0.6445)
-
-        cond.set_attr(pr1=1, pr2=0.9, ttd_u=5)
-        condpump.set_attr(eta_s=0.7)
-        fwp.set_attr(eta_s=0.7)
-        cwp.set_attr(eta_s=0.7)
-        ct.set_attr(pr1=0.95)
-        fan.set_attr(eta_s=0.6)
-
-        lppre1.set_attr(pr1=1, ttd_u=5)
-        lppre2.set_attr(pr1=1, ttd_u=5)
-        lppre3.set_attr(pr1=1, ttd_u=5)
-        hppre1.set_attr(pr1=1, ttd_u=5)
-        hppre2.set_attr(pr1=1, ttd_u=5)
-
-        lppre1_sub.set_attr(pr1=1, pr2=1, ttd_l=10)
-        lppre2_sub.set_attr(pr1=1, pr2=1, ttd_l=10)
-        lppre3_sub.set_attr(pr1=1, pr2=1, ttd_l=10)
-        hppre1_sub.set_attr(pr1=1, pr2=1, ttd_l=10)
-        hppre2_sub.set_attr(pr1=1, pr2=1, ttd_l=10)
-
-        # connection parameters
-        # parabolic trough cycle
-        c70.set_attr(fluid={'TVP1': 1, 'water': 0, 'air': 0}, T=390, p=23.304)
-        c76.set_attr(m=Ref(c70, 0.1284, 0))
-        c73.set_attr(p=22.753)
-        c74.set_attr(p=21.167)
-        c78.set_attr(p=20.34)
-        c79.set_attr(p=41.024)
-
-        # cooling water
-        c62.set_attr(
-            fluid={'TVP1': 0, 'water': 1, 'air': 0}, T=30, p=self.pamb)
-        # cooling tower
-        c64.set_attr(
-            fluid={'water': 0, 'TVP1': 0, 'air': 1}, p=self.pamb, T=self.Tamb)
-        c65.set_attr(p=self.pamb + 0.0005)
-        c66.set_attr(p=self.pamb, T=30)
-        # power cycle
-        c32.set_attr(Td_bp=-2)
-        c34.set_attr(x=0.5)
-        c1.set_attr(fluid={'water': 1, 'TVP1': 0, 'air': 0}, p=100, T=371)
-
-        # steam generator pressure values
-        c31.set_attr(p=103.56)
-        c35.set_attr(p=103.42)
-
-        # turbine pressure values
-        c3.set_attr(p=33.61, m=38.969)
-        c5.set_attr(p=18.58)
-        c7.set_attr(p=17.1, T=371)
-        c8.set_attr(p=7.98)
-        c10.set_attr(p=2.73)
-        c12.set_attr(p=0.96)
-        c14.set_attr(p=0.29)
-
-        # preheater pressure values
-        c19.set_attr(p=14.755, state='l')
-        c21.set_attr(p=9.9975, state='l')
-        c23.set_attr(p=8.7012, state='l')
-        c25.set_attr(state='l')
-
-        c27.set_attr(p=125)
-        c29.set_attr(p=112)
-
-        # condensation
-        c16.set_attr(p=0.08)
-
-        # feedwater tank
-        c26.set_attr(x=0)
-
-        # a stable solution is generated for parts of the network
-        self.nw.solve(mode='design')
-
-        self.nw.del_conns(c19, c21, c23, c27, c29, c37, c42, c47, c52, c57)
-
-        c19 = Connection(condpump, 'out1', lppre1_sub, 'in2', label='19')
-        c20 = Connection(lppre1_sub, 'out2', lppre1, 'in2', label='20')
-        c21 = Connection(lppre1, 'out2', lppre2_sub, 'in2', label='21')
-        c22 = Connection(lppre2_sub, 'out2', lppre2, 'in2', label='22')
-        c23 = Connection(lppre2, 'out2', lppre3_sub, 'in2', label='23')
-        c24 = Connection(lppre3_sub, 'out2', lppre3, 'in2', label='24')
-
-        c27 = Connection(fwp, 'out1', hppre1_sub, 'in2', label='27')
-        c28 = Connection(hppre1_sub, 'out2', hppre1, 'in2', label='28')
-        c29 = Connection(hppre1, 'out2', hppre2_sub, 'in2', label='29')
-        c30 = Connection(hppre2_sub, 'out2', hppre2, 'in2', label='30')
-
-        c37 = Connection(hppre2, 'out1', hppre2_sub, 'in1', label='37')
-        c38 = Connection(hppre2_sub, 'out1', v1, 'in1', label='38')
-        c42 = Connection(hppre1, 'out1', hppre1_sub, 'in1', label='42')
-        c43 = Connection(hppre1_sub, 'out1', v2, 'in1', label='43')
-
-        c47 = Connection(lppre3, 'out1', lppre3_sub, 'in1', label='47')
-        c48 = Connection(lppre3_sub, 'out1', v3, 'in1', label='48')
-        c52 = Connection(lppre2, 'out1', lppre2_sub, 'in1', label='52')
-        c53 = Connection(lppre2_sub, 'out1', v4, 'in1', label='53')
-        c57 = Connection(lppre1, 'out1', lppre1_sub, 'in1', label='57')
-        c58 = Connection(lppre1_sub, 'out1', v5, 'in1', label='58')
-
-        self.nw.add_conns(
-            c19, c20, c21, c22, c23, c24, c27, c28, c29, c30, c37, c38, c42,
-            c43, c47, c48, c52, c53, c57, c58)
-
-        # specification of missing parameters
-        c19.set_attr(p=14.755)
-        c21.set_attr(p=9.9975, state='l')
-        c23.set_attr(p=8.7012, state='l')
-        c27.set_attr(p=125)
-        c29.set_attr(p=112)
-
-        # solve final state
-        self.nw.solve(mode='design')
-
-    def test_model(self):
-        """Test the thermodynamic model."""
-        power_ebsilon = -31.769
-        power_tespy = round(
-            self.nw.busses['total output power'].P.val / 1e6, 3)
-        msg = (
-            'The total power calculated (' + str(power_tespy) + ') does not '
-            'match the power calculated with the EBSILON model (' +
-            str(power_ebsilon) + ').')
-        assert power_tespy == power_ebsilon, msg
-
-        T_c79_ebsilon = 296.254
-        T_c79_tespy = round(self.nw.get_conn('79').T.val, 3)
-        msg = (
-            'The temperature at connection 79 calculated (' +
-            str(T_c79_tespy) + ') does not match the temperature calculated '
-            'with the EBSILON model (' + str(T_c79_ebsilon) + ').')
-        assert T_c79_tespy == T_c79_ebsilon, msg
-
-    def test_exergy_analysis(self):
-        """Test the exergy analysis results."""
-        # carry out exergy analysis
-        ean = ExergyAnalysis(
-            self.nw, E_P=[self.nw.busses['total output power']],
-            E_F=[self.nw.busses['heat input']],
-            E_L=[self.nw.busses['exergy loss']])
-        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
-
-        # generate Grassmann diagram
-        links, nodes = ean.generate_plotly_sankey_input()
-
-        # check if exergy product value in links is equal to total power
-        # output
-        position = links['target'].index(nodes.index('E_P'))
-        power_links = round(links['value'][position], 0)
-        power_bus = round(-self.nw.busses['total output power'].P.val, 0)
-        msg = (
-            'The exergy product value in the links (' + str(power_links) +
-            ') must be equal to the power on the respective bus (' +
-            str(power_bus) + ').')
-        assert power_links == power_bus, msg
+# -*- coding: utf-8
+
+"""Module for testing a tespy simulation vs results from a different simulator.
+
+This file is part of project TESPy (github.com/oemof/tespy). It's copyrighted
+by the contributors recorded in the version control history of the file,
+available from its original location
+tests/test_models/test_solar_energy_generating_system.py
+
+SPDX-License-Identifier: MIT
+"""
+from tespy.components import Compressor
+from tespy.components import Condenser
+from tespy.components import CycleCloser
+from tespy.components import Drum
+from tespy.components import HeatExchanger
+from tespy.components import Merge
+from tespy.components import ParabolicTrough
+from tespy.components import Pump
+from tespy.components import Sink
+from tespy.components import Source
+from tespy.components import Splitter
+from tespy.components import Turbine
+from tespy.components import Valve
+from tespy.connections import Bus
+from tespy.connections import Connection
+from tespy.connections import Ref
+from tespy.networks import Network
+from tespy.tools import ExergyAnalysis
+
+
+class TestSEGS:
+
+    def setup_method(self):
+        """
+        Full model validation of SEGS model in TESPy vs. EBSILON.
+
+        Find original models at https://github.com/fwitte/SEGS_exergy.
+        """
+        # specification of ambient state
+        self.pamb = 1.013
+        self.Tamb = 25
+
+        # setting up network
+        self.nw = Network(fluids=['water', 'INCOMP::TVP1', 'air'])
+        self.nw.set_attr(
+            T_unit='C', p_unit='bar', h_unit='kJ / kg', m_unit='kg / s',
+            s_unit="kJ / kgK")
+
+        # components definition
+        air_in = Source('Ambient air source', fkt_group='CW')
+        air_out = Sink('Ambient air sink', fkt_group='CW')
+
+        closer_pt = CycleCloser('Cycle closer pt', fkt_group='SF')
+        pt = ParabolicTrough('Parabolic trough', fkt_group='SF')
+        ptpump = Pump('HTF pump', fkt_group='SF')
+
+        closer = CycleCloser('Cycle closer power cycle', fkt_group='SG')
+
+        eco = HeatExchanger('Economizer', fkt_group='SG')
+        eva = HeatExchanger('Evaporator', fkt_group='SG')
+        sup = HeatExchanger('Superheater', fkt_group='SG')
+        drum = Drum('Drum', fkt_group='SG')
+
+        reh = HeatExchanger('Reheater', fkt_group='RH')
+
+        hpt1 = Turbine('HP turbine 1', fkt_group='HPT')
+        hpt2 = Turbine('HP turbine 2', fkt_group='HPT')
+        lpt1 = Turbine('LP turbine 1', fkt_group='LPT')
+        lpt2 = Turbine('LP turbine 2', fkt_group='LPT')
+        lpt3 = Turbine('LP turbine 3', fkt_group='LPT')
+        lpt4 = Turbine('LP turbine 4', fkt_group='LPT')
+        lpt5 = Turbine('LP turbine 5', fkt_group='LPT')
+
+        cond = Condenser('Condenser', fkt_group='CW')
+        condpump = Pump('Condenser pump', fkt_group='CW')
+        fwt = Merge('Feedwater tank', num_in=3, fkt_group='LPP')
+        fwp = Pump('Feedwater pump', fkt_group='FWP')
+        cwp = Pump('Cooling water pump', fkt_group='CW')
+        closer_cw = CycleCloser('Cycle closer cw', fkt_group='CW')
+        ct = HeatExchanger('Cooling tower', fkt_group='CW')
+        fan = Compressor('Cooling tower fan', fkt_group='CW')
+
+        sp1 = Splitter('Splitter 1', fkt_group='HPT')
+        sp2 = Splitter('Splitter 2', fkt_group='HPT')
+        sp3 = Splitter('Splitter 3', fkt_group='LPT')
+        sp4 = Splitter('Splitter 4', fkt_group='LPT')
+        sp5 = Splitter('Splitter 5', fkt_group='LPT')
+        sp6 = Splitter('Splitter 6', fkt_group='LPT')
+        sp7 = Splitter('Splitter 7', fkt_group='SF')
+
+        m1 = Merge('Merge 1', fkt_group='CW')
+        m2 = Merge('Merge 2', fkt_group='HPP')
+        m3 = Merge('Merge 3', fkt_group='LPP')
+        m4 = Merge('Merge 4', fkt_group='LPP')
+        m5 = Merge('Merge 5', fkt_group='SF')
+
+        v1 = Valve('Valve 1', fkt_group='HPP')
+        v2 = Valve('Valve 2', fkt_group='HPP')
+        v3 = Valve('Valve 3', fkt_group='LPP')
+        v4 = Valve('Valve 4', fkt_group='LPP')
+        v5 = Valve('Valve 5', fkt_group='LPP')
+
+        hppre1 = Condenser('High pressure preheater 1', fkt_group='HPP')
+        hppre2 = Condenser('High pressure preheater 2', fkt_group='HPP')
+        hppre1_sub = HeatExchanger(
+            'High pressure preheater 1 subcooling', fkt_group='HPP')
+        hppre2_sub = HeatExchanger(
+            'High pressure preheater 2 subcooling', fkt_group='HPP')
+
+        lppre1 = Condenser('Low pressure preheater 1', fkt_group='LPP')
+        lppre2 = Condenser('Low pressure preheater 2', fkt_group='LPP')
+        lppre3 = Condenser('Low pressure preheater 3', fkt_group='LPP')
+        lppre1_sub = HeatExchanger(
+            'Low pressure preheater 1 subcooling', fkt_group='LPP')
+        lppre2_sub = HeatExchanger(
+            'Low pressure preheater 2 subcooling', fkt_group='LPP')
+        lppre3_sub = HeatExchanger(
+            'Low pressure preheater 3 subcooling', fkt_group='LPP')
+
+        # connections definition
+        # power cycle
+        c1 = Connection(sup, 'out2', closer, 'in1', label='1')
+        c2 = Connection(closer, 'out1', hpt1, 'in1', label='2')
+        c3 = Connection(hpt1, 'out1', sp1, 'in1', label='3')
+        c4 = Connection(sp1, 'out1', hpt2, 'in1', label='4')
+        c5 = Connection(hpt2, 'out1', sp2, 'in1', label='5')
+        c6 = Connection(sp2, 'out1', reh, 'in2', label='6')
+        c7 = Connection(reh, 'out2', lpt1, 'in1', label='7')
+        c8 = Connection(lpt1, 'out1', sp3, 'in1', label='8')
+        c9 = Connection(sp3, 'out1', lpt2, 'in1', label='9')
+        c10 = Connection(lpt2, 'out1', sp4, 'in1', label='10')
+        c11 = Connection(sp4, 'out1', lpt3, 'in1', label='11')
+        c12 = Connection(lpt3, 'out1', sp5, 'in1', label='12')
+        c13 = Connection(sp5, 'out1', lpt4, 'in1', label='13')
+        c14 = Connection(lpt4, 'out1', sp6, 'in1', label='14')
+        c15 = Connection(sp6, 'out1', lpt5, 'in1', label='15')
+        c16 = Connection(lpt5, 'out1', m1, 'in1', label='16')
+        c17 = Connection(m1, 'out1', cond, 'in1', label='17')
+        c18 = Connection(cond, 'out1', condpump, 'in1', label='18')
+        c19 = Connection(condpump, 'out1', lppre1, 'in2', label='19')
+        # c19 = Connection(condpump, 'out1', lppre1_sub, 'in2', label='19')
+        # c20 = Connection(lppre1_sub, 'out2', lppre1, 'in2', label='20')
+        c21 = Connection(lppre1, 'out2', lppre2, 'in2', label='21')
+        # c21 = Connection(lppre1, 'out2', lppre2_sub, 'in2', label='21')
+        # c22 = Connection(lppre2_sub, 'out2', lppre2, 'in2', label='22')
+        c23 = Connection(lppre2, 'out2', lppre3, 'in2', label='23')
+        # c23 = Connection(lppre2, 'out2', lppre3_sub, 'in2', label='23')
+        # c24 = Connection(lppre3_sub, 'out2', lppre3, 'in2', label='24')
+        c25 = Connection(lppre3, 'out2', fwt, 'in1', label='25')
+        c26 = Connection(fwt, 'out1', fwp, 'in1', label='26')
+        c27 = Connection(fwp, 'out1', hppre1, 'in2', label='27')
+        c29 = Connection(hppre1, 'out2', hppre2, 'in2', label='29')
+        c31 = Connection(hppre2, 'out2', eco, 'in2', label='31')
+
+        c36 = Connection(sp1, 'out2', hppre2, 'in1', label='36')
+        c37 = Connection(hppre2, 'out1', v1, 'in1', label='37')
+        c39 = Connection(v1, 'out1', m2, 'in2', label='39')
+        c40 = Connection(sp2, 'out2', m2, 'in1', label='40')
+        c41 = Connection(m2, 'out1', hppre1, 'in1', label='41')
+        c42 = Connection(hppre1, 'out1', v2, 'in1', label='42')
+        c44 = Connection(v2, 'out1', fwt, 'in2', label='44')
+        c45 = Connection(sp3, 'out2', fwt, 'in3', label='45')
+        c46 = Connection(sp4, 'out2', lppre3, 'in1', label='46')
+        c47 = Connection(lppre3, 'out1', v3, 'in1', label='47')
+        # c47 = Connection(lppre3, 'out1', lppre3_sub, 'in1', label='47')
+        # c48 = Connection(lppre3_sub, 'out1', v3, 'in1', label='48')
+        c49 = Connection(v3, 'out1', m3, 'in1', label='49')
+        c50 = Connection(sp5, 'out2', m3, 'in2', label='50')
+        c51 = Connection(m3, 'out1', lppre2, 'in1', label='51')
+        c52 = Connection(lppre2, 'out1', v4, 'in1', label='52')
+        # c52 = Connection(lppre2, 'out1', lppre2_sub, 'in1', label='52')
+        # c53 = Connection(lppre2_sub, 'out1', v4, 'in1', label='53')
+        c54 = Connection(v4, 'out1', m4, 'in2', label='54')
+        c55 = Connection(sp6, 'out2', m4, 'in1', label='55')
+        c56 = Connection(m4, 'out1', lppre1, 'in1', label='56')
+        c57 = Connection(lppre1, 'out1', v5, 'in1', label='57')
+        # c57 = Connection(lppre1, 'out1', lppre1_sub, 'in1', label='57')
+        # c58 = Connection(lppre1_sub, 'out1', v5, 'in1', label='58')
+        c59 = Connection(v5, 'out1', m1, 'in2', label='59')
+
+        # components from subsystem
+        c32 = Connection(eco, 'out2', drum, 'in1', label='32')
+        c33 = Connection(drum, 'out1', eva, 'in2', label='33')
+        c34 = Connection(eva, 'out2', drum, 'in2', label='34')
+        c35 = Connection(drum, 'out2', sup, 'in2', label='35')
+        c73 = Connection(sup, 'out1', eva, 'in1', label='73')
+        c74 = Connection(eva, 'out1', eco, 'in1', label='74')
+
+        # cooling water
+        c60 = Connection(cond, 'out2', closer_cw, 'in1', label='60')
+        c61 = Connection(closer_cw, 'out1', ct, 'in1', label='61')
+        c62 = Connection(ct, 'out1', cwp, 'in1', label='62')
+        c63 = Connection(cwp, 'out1', cond, 'in2', label='63')
+
+        # cooling tower
+        c64 = Connection(air_in, 'out1', fan, 'in1', label='64')
+        c65 = Connection(fan, 'out1', ct, 'in2', label='65')
+        c66 = Connection(ct, 'out2', air_out, 'in1', label='66')
+
+        # parabolic trough cycle
+        c70 = Connection(pt, 'out1', closer_pt, 'in1', label='67')
+        c71 = Connection(closer_pt, 'out1', sp7, 'in1', label='71')
+        c72 = Connection(sp7, 'out1', sup, 'in1', label='72')
+        c75 = Connection(eco, 'out1', m5, 'in1', label='75')
+        c76 = Connection(sp7, 'out2', reh, 'in1', label='76')
+        c77 = Connection(reh, 'out1', m5, 'in2', label='77')
+        c78 = Connection(m5, 'out1', ptpump, 'in1', label='78')
+        c79 = Connection(ptpump, 'out1', pt, 'in1', label='79')
+
+        # add connections to network
+        self.nw.add_conns(
+            c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11, c12, c13, c14, c15,
+            c16, c17, c18, c19, c21, c23, c25, c26, c27, c29, c31, c32, c33,
+            c34, c35, c36, c37, c39, c40, c41, c42, c44, c45, c46, c47, c49,
+            c50, c51, c52, c54, c55, c56, c57, c59, c60, c61, c62, c63, c64,
+            c65, c66, c70, c71, c72, c73, c74, c75, c76, c77, c78, c79)
+
+        # power bus
+        power = Bus('total output power')
+        power.add_comps(
+            {'comp': hpt1, 'char': 0.97, 'base': 'component'},
+            {'comp': hpt2, 'char': 0.97, 'base': 'component'},
+            {'comp': lpt1, 'char': 0.97, 'base': 'component'},
+            {'comp': lpt2, 'char': 0.97, 'base': 'component'},
+            {'comp': lpt3, 'char': 0.97, 'base': 'component'},
+            {'comp': lpt4, 'char': 0.97, 'base': 'component'},
+            {'comp': lpt5, 'char': 0.97, 'base': 'component'},
+            {'comp': fwp, 'char': 0.95, 'base': 'bus'},
+            {'comp': condpump, 'char': 0.95, 'base': 'bus'},
+            {'comp': ptpump, 'char': 0.95, 'base': 'bus'},
+            {'comp': cwp, 'char': 0.95, 'base': 'bus'},
+            {'comp': fan, 'char': 0.95, 'base': 'bus'})
+
+        heat_input_bus = Bus('heat input')
+        heat_input_bus.add_comps({'comp': pt, 'base': 'bus'})
+
+        exergy_loss_bus = Bus('exergy loss')
+        exergy_loss_bus.add_comps(
+            {'comp': air_in, 'base': 'bus'}, {'comp': air_out})
+
+        self.nw.add_busses(power, heat_input_bus, exergy_loss_bus)
+
+        # component parameters
+        pt.set_attr(doc=0.95, aoi=0,
+                    Tamb=25, A='var', eta_opt=0.73,
+                    c_1=0.00496, c_2=0.000691, E=1000,
+                    iam_1=1, iam_2=1)
+
+        ptpump.set_attr(eta_s=0.6)
+
+        eco.set_attr()
+        eva.set_attr(ttd_l=5)
+        sup.set_attr()
+
+        hpt1.set_attr(eta_s=0.8376)
+        hpt2.set_attr(eta_s=0.8463)
+        lpt1.set_attr(eta_s=0.8623)
+        lpt2.set_attr(eta_s=0.917)
+        lpt3.set_attr(eta_s=0.9352)
+        lpt4.set_attr(eta_s=0.88)
+        lpt5.set_attr(eta_s=0.6445)
+
+        cond.set_attr(pr1=1, pr2=0.9, ttd_u=5)
+        condpump.set_attr(eta_s=0.7)
+        fwp.set_attr(eta_s=0.7)
+        cwp.set_attr(eta_s=0.7)
+        ct.set_attr(pr1=0.95)
+        fan.set_attr(eta_s=0.6)
+
+        lppre1.set_attr(pr1=1, ttd_u=5)
+        lppre2.set_attr(pr1=1, ttd_u=5)
+        lppre3.set_attr(pr1=1, ttd_u=5)
+        hppre1.set_attr(pr1=1, ttd_u=5)
+        hppre2.set_attr(pr1=1, ttd_u=5)
+
+        lppre1_sub.set_attr(pr1=1, pr2=1, ttd_l=10)
+        lppre2_sub.set_attr(pr1=1, pr2=1, ttd_l=10)
+        lppre3_sub.set_attr(pr1=1, pr2=1, ttd_l=10)
+        hppre1_sub.set_attr(pr1=1, pr2=1, ttd_l=10)
+        hppre2_sub.set_attr(pr1=1, pr2=1, ttd_l=10)
+
+        # connection parameters
+        # parabolic trough cycle
+        c70.set_attr(fluid={'TVP1': 1, 'water': 0, 'air': 0}, T=390, p=23.304)
+        c76.set_attr(m=Ref(c70, 0.1284, 0))
+        c73.set_attr(p=22.753)
+        c74.set_attr(p=21.167)
+        c78.set_attr(p=20.34)
+        c79.set_attr(p=41.024)
+
+        # cooling water
+        c62.set_attr(
+            fluid={'TVP1': 0, 'water': 1, 'air': 0}, T=30, p=self.pamb)
+        # cooling tower
+        c64.set_attr(
+            fluid={'water': 0, 'TVP1': 0, 'air': 1}, p=self.pamb, T=self.Tamb)
+        c65.set_attr(p=self.pamb + 0.0005)
+        c66.set_attr(p=self.pamb, T=30)
+        # power cycle
+        c32.set_attr(Td_bp=-2)
+        c34.set_attr(x=0.5)
+        c1.set_attr(fluid={'water': 1, 'TVP1': 0, 'air': 0}, p=100, T=371)
+
+        # steam generator pressure values
+        c31.set_attr(p=103.56)
+        c35.set_attr(p=103.42)
+
+        # turbine pressure values
+        c3.set_attr(p=33.61, m=38.969)
+        c5.set_attr(p=18.58)
+        c7.set_attr(p=17.1, T=371)
+        c8.set_attr(p=7.98)
+        c10.set_attr(p=2.73)
+        c12.set_attr(p=0.96)
+        c14.set_attr(p=0.29)
+
+        # preheater pressure values
+        c19.set_attr(p=14.755, state='l')
+        c21.set_attr(p=9.9975, state='l')
+        c23.set_attr(p=8.7012, state='l')
+        c25.set_attr(state='l')
+
+        c27.set_attr(p=125)
+        c29.set_attr(p=112)
+
+        # condensation
+        c16.set_attr(p=0.08)
+
+        # feedwater tank
+        c26.set_attr(x=0)
+
+        # a stable solution is generated for parts of the network
+        self.nw.solve(mode='design')
+
+        self.nw.del_conns(c19, c21, c23, c27, c29, c37, c42, c47, c52, c57)
+
+        c19 = Connection(condpump, 'out1', lppre1_sub, 'in2', label='19')
+        c20 = Connection(lppre1_sub, 'out2', lppre1, 'in2', label='20')
+        c21 = Connection(lppre1, 'out2', lppre2_sub, 'in2', label='21')
+        c22 = Connection(lppre2_sub, 'out2', lppre2, 'in2', label='22')
+        c23 = Connection(lppre2, 'out2', lppre3_sub, 'in2', label='23')
+        c24 = Connection(lppre3_sub, 'out2', lppre3, 'in2', label='24')
+
+        c27 = Connection(fwp, 'out1', hppre1_sub, 'in2', label='27')
+        c28 = Connection(hppre1_sub, 'out2', hppre1, 'in2', label='28')
+        c29 = Connection(hppre1, 'out2', hppre2_sub, 'in2', label='29')
+        c30 = Connection(hppre2_sub, 'out2', hppre2, 'in2', label='30')
+
+        c37 = Connection(hppre2, 'out1', hppre2_sub, 'in1', label='37')
+        c38 = Connection(hppre2_sub, 'out1', v1, 'in1', label='38')
+        c42 = Connection(hppre1, 'out1', hppre1_sub, 'in1', label='42')
+        c43 = Connection(hppre1_sub, 'out1', v2, 'in1', label='43')
+
+        c47 = Connection(lppre3, 'out1', lppre3_sub, 'in1', label='47')
+        c48 = Connection(lppre3_sub, 'out1', v3, 'in1', label='48')
+        c52 = Connection(lppre2, 'out1', lppre2_sub, 'in1', label='52')
+        c53 = Connection(lppre2_sub, 'out1', v4, 'in1', label='53')
+        c57 = Connection(lppre1, 'out1', lppre1_sub, 'in1', label='57')
+        c58 = Connection(lppre1_sub, 'out1', v5, 'in1', label='58')
+
+        self.nw.add_conns(
+            c19, c20, c21, c22, c23, c24, c27, c28, c29, c30, c37, c38, c42,
+            c43, c47, c48, c52, c53, c57, c58)
+
+        # specification of missing parameters
+        c19.set_attr(p=14.755)
+        c21.set_attr(p=9.9975, state='l')
+        c23.set_attr(p=8.7012, state='l')
+        c27.set_attr(p=125)
+        c29.set_attr(p=112)
+
+        # solve final state
+        self.nw.solve(mode='design')
+
+    def test_model(self):
+        """Test the thermodynamic model."""
+        power_ebsilon = -31.769
+        power_tespy = round(
+            self.nw.busses['total output power'].P.val / 1e6, 3)
+        msg = (
+            'The total power calculated (' + str(power_tespy) + ') does not '
+            'match the power calculated with the EBSILON model (' +
+            str(power_ebsilon) + ').')
+        assert power_tespy == power_ebsilon, msg
+
+        T_c79_ebsilon = 296.254
+        T_c79_tespy = round(self.nw.get_conn('79').T.val, 3)
+        msg = (
+            'The temperature at connection 79 calculated (' +
+            str(T_c79_tespy) + ') does not match the temperature calculated '
+            'with the EBSILON model (' + str(T_c79_ebsilon) + ').')
+        assert T_c79_tespy == T_c79_ebsilon, msg
+
+    def test_exergy_analysis(self):
+        """Test the exergy analysis results."""
+        # carry out exergy analysis
+        ean = ExergyAnalysis(
+            self.nw, E_P=[self.nw.busses['total output power']],
+            E_F=[self.nw.busses['heat input']],
+            E_L=[self.nw.busses['exergy loss']])
+        ean.analyse(pamb=self.pamb, Tamb=self.Tamb)
+
+        # generate Grassmann diagram
+        links, nodes = ean.generate_plotly_sankey_input(disaggregate_flows=True)
+
+        # check if exergy product value in links is equal to total power
+        # output
+        position = links['target'].index(nodes.index('E_P'))
+        power_links = round(links['value'][position], 0)
+        power_bus = round(-self.nw.busses['total output power'].P.val, 0)
+        msg = (
+            'The exergy product value in the links (' + str(power_links) +
+            ') must be equal to the power on the respective bus (' +
+            str(power_bus) + ').')
+        assert power_links == power_bus, msg
```

### Comparing `TESPy-0.6.2/tests/test_networks/test_network.py` & `TESPy-0.6.3/tests/test_networks/test_network.py`

 * *Files 6% similar despite different names*

```diff
@@ -28,20 +28,14 @@
 from tespy.components import Valve
 from tespy.connections import Connection
 from tespy.networks import Network
 from tespy.networks import load_network
 from tespy.tools.helpers import TESPyNetworkError
 
 
-def convergence_check(lin_dep):
-    """Check convergence status of a simulation."""
-    msg = 'Calculation did not converge!'
-    assert not lin_dep, msg
-
-
 class TestNetworks:
     def setup_Network_tests(self):
         self.nw = Network(['water'], p_unit='bar', v_unit='m3 / s', T_unit='C')
         self.source = Source('source')
         self.sink = Sink('sink')
 
     def offdesign_TESPyNetworkError(self, **kwargs):
@@ -120,15 +114,15 @@
         new_sink = Sink("A different sink")
         a = Connection(self.source, 'out1', p, 'in1')
         b = Connection(p, 'out1', new_sink, 'in1')
         self.nw.add_conns(a, b)
         a.set_attr(fluid={"water": 1}, m=1, p=1, T=25)
         b.set_attr(p=1, T=25)
         self.nw.solve("design")
-        convergence_check(self.nw.lin_dep)
+        self.nw._convergence_check()
 
     def test_Network_missing_connection_in_init_path(self):
         """Test debug message for missing connection in init_path."""
         self.setup_Network_tests()
         IF = SubsystemInterface('IF')
         a = Connection(self.source, 'out1', self.sink, 'in1')
         self.nw.add_conns(a)
@@ -354,47 +348,47 @@
         self.nw.add_conns(inlet, outlet, self.sp_p1, self.p1_sc1, self.sc1_v1,
                           v1_me, self.sp_p2, self.p2_sc2, self.sc2_v2, v2_me)
 
     def test_individual_design_path_on_connections_and_components(self):
         """Test individual design path specification."""
         self.setup_Network_individual_offdesign()
         self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
+        self.nw._convergence_check()
         self.sc2_v2.set_attr(m=0)
         self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
+        self.nw._convergence_check()
         self.nw.save('design1')
         v1_design = self.sc1_v1.v.val_SI
         zeta_sc1_design = self.sc1.zeta.val
 
         self.sc2_v2.set_attr(T=95, state='l', m=None)
         self.sc1_v1.set_attr(m=0.001, T=None)
         self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
+        self.nw._convergence_check()
         self.nw.save('design2')
         v2_design = self.sc2_v2.v.val_SI
         zeta_sc2_design = self.sc2.zeta.val
 
         self.sc1_v1.set_attr(m=np.nan)
         self.sc1_v1.set_attr(design=['T'], offdesign=['v'], state='l')
         self.sc2_v2.set_attr(design=['T'], offdesign=['v'], state='l')
 
         self.sc2.set_attr(design_path='design2')
         self.pump2.set_attr(design_path='design2')
         self.sp_p2.set_attr(design_path='design2')
         self.p2_sc2.set_attr(design_path='design2')
         self.sc2_v2.set_attr(design_path='design2')
         self.nw.solve('offdesign', design_path='design1')
-        convergence_check(self.nw.lin_dep)
+        self.nw._convergence_check()
 
         self.sc1.set_attr(E=500)
         self.sc2.set_attr(E=950)
 
         self.nw.solve('offdesign', design_path='design1')
-        convergence_check(self.nw.lin_dep)
+        self.nw._convergence_check()
         self.sc2_v2.set_attr(design_path=np.nan)
 
         # volumetric flow comparison
         msg = ('Design path was set to None, is ' +
                str(self.sc2_v2.design_path) + '.')
         assert self.sc2_v2.design_path is None, msg
 
@@ -419,33 +413,33 @@
         shutil.rmtree('./design1', ignore_errors=True)
         shutil.rmtree('./design2', ignore_errors=True)
 
     def test_local_offdesign_on_connections_and_components(self):
         """Test local offdesign feature."""
         self.setup_Network_individual_offdesign()
         self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
+        self.nw._convergence_check()
         self.sc2_v2.set_attr(m=0)
         self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
+        self.nw._convergence_check()
         self.nw.save('design1')
 
         self.sc1_v1.set_attr(design=['T'], offdesign=['v'], state='l')
         self.sc2_v2.set_attr(design=['T'], offdesign=['v'], state='l')
 
         self.sc1.set_attr(local_offdesign=True, design_path='design1')
         self.pump1.set_attr(local_offdesign=True, design_path='design1')
         self.sp_p1.set_attr(local_offdesign=True, design_path='design1')
         self.p1_sc1.set_attr(local_offdesign=True, design_path='design1')
         self.sc1_v1.set_attr(local_offdesign=True, design_path='design1')
         self.sc1.set_attr(E=500)
 
         self.sc2_v2.set_attr(T=95, m=np.nan)
         self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
+        self.nw._convergence_check()
         self.nw.save('design2')
 
         # connections and components on side 1 must have switched to offdesign
 
         msg = ('Solar collector outlet temperature must be different from ' +
                'design value ' + str(round(self.sc1_v1.T.design - 273.15, 1)) +
                ', is ' + str(round(self.sc1_v1.T.val, 1)) + '.')
@@ -461,18 +455,18 @@
         shutil.rmtree('./design1', ignore_errors=True)
         shutil.rmtree('./design2', ignore_errors=True)
 
     def test_missing_design_path_local_offdesign_on_connections(self):
         """Test missing design path on connections in local offdesign mode."""
         self.setup_Network_individual_offdesign()
         self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
+        self.nw._convergence_check()
         self.sc2_v2.set_attr(m=0)
         self.nw.solve('design')
-        convergence_check(self.nw.lin_dep)
+        self.nw._convergence_check()
         self.nw.save('design1')
 
         self.sc1_v1.set_attr(design=['T'], offdesign=['v'], state='l')
         self.sc2_v2.set_attr(design=['T'], offdesign=['v'], state='l')
 
         self.sc1.set_attr(local_offdesign=True, design_path='design1')
         self.pump1.set_attr(local_offdesign=True, design_path='design1')
```

### Comparing `TESPy-0.6.2/tests/test_tools/test_characteristics.py` & `TESPy-0.6.3/tests/test_tools/test_characteristics.py`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/tests/test_tools/test_helpers.py` & `TESPy-0.6.3/tests/test_tools/test_helpers.py`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/tutorial/advanced/optimization_example.py` & `TESPy-0.6.3/tutorial/advanced/optimization_example.py`

 * *Files 0% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 import pygmo as pg
 
 from tespy.components import CycleCloser
 from tespy.components import Sink
 from tespy.components import Source
 from tespy.components import Condenser
 from tespy.components import Desuperheater
-from tespy.components import HeatExchangerSimple
+from tespy.components import SimpleHeatExchanger
 from tespy.components import Merge
 from tespy.components import Splitter
 from tespy.components import Valve
 from tespy.components import Pump
 from tespy.components import Turbine
 from tespy.connections import Bus
 from tespy.connections import Connection
@@ -26,15 +26,15 @@
 
         self.nw = Network(fluids=["water"])
         self.nw.set_attr(
             p_unit="bar", T_unit="C", h_unit="kJ / kg", iterinfo=False
         )
         # components
         # main cycle
-        sg = HeatExchangerSimple("steam generator")
+        sg = SimpleHeatExchanger("steam generator")
         cc = CycleCloser("cycle closer")
         hpt = Turbine("high pressure turbine")
         sp1 = Splitter("splitter 1", num_out=2)
         mpt = Turbine("mid pressure turbine")
         sp2 = Splitter("splitter 2", num_out=2)
         lpt = Turbine("low pressure turbine")
         con = Condenser("condenser")
@@ -178,15 +178,15 @@
         Solve the TESPy model given the the input parameters
         """
         self.set_params(**kwargs)
 
         self.solved = False
         try:
             self.nw.solve("design")
-            if self.nw.res[-1] >= 1e-3 or self.nw.lin_dep:
+            if not self.nw.converged:
                 self.nw.solve("design", init_only=True, init_path=self.stable)
             else:
                 # might need more checks here!
                 if (
                         any(self.nw.results["Condenser"]["Q"] > 0)
                         or any(self.nw.results["Desuperheater"]["Q"] > 0)
                         or any(self.nw.results["Turbine"]["P"] > 0)
```

### Comparing `TESPy-0.6.2/tutorial/advanced/starting_values.py` & `TESPy-0.6.3/tutorial/advanced/starting_values.py`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/tutorial/advanced/stepwise.py` & `TESPy-0.6.3/tutorial/advanced/stepwise.py`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/tutorial/basics/district_heating.py` & `TESPy-0.6.3/tutorial/basics/district_heating.py`

 * *Files 5% similar despite different names*

```diff
@@ -1,26 +1,26 @@
 # %%[sec_1]
 from tespy.components.basics.cycle_closer import CycleCloser
 from tespy.networks import Network
 from tespy.components import (
-    CycleCloser, Pipe, Pump, Valve, HeatExchangerSimple
+    CycleCloser, Pipe, Pump, Valve, SimpleHeatExchanger
 )
 from tespy.connections import Connection
 
-fluid_list = ['water']
+fluid_list = ['INCOMP::Water']
 nw = Network(fluids=fluid_list)
 nw.set_attr(T_unit='C', p_unit='bar', h_unit='kJ / kg')
 
 # central heating plant
-hs = HeatExchangerSimple('heat source')
+hs = SimpleHeatExchanger('heat source')
 cc = CycleCloser('cycle closer')
 pu = Pump('feed pump')
 
 # consumer
-cons = HeatExchangerSimple('consumer')
+cons = SimpleHeatExchanger('consumer')
 val = Valve('control valve')
 
 # pipes
 pipe_feed = Pipe('feed pipe')
 pipe_return = Pipe('return pipe')
 
 # connections
@@ -35,15 +35,15 @@
 # %%[sec_2]
 cons.set_attr(Q=-10000, pr=0.98)
 hs.set_attr(pr=1)
 pu.set_attr(eta_s=0.75)
 pipe_feed.set_attr(Q=-250, pr=0.98)
 pipe_return.set_attr(Q=-200, pr=0.98)
 
-c1.set_attr(T=90, p=10, fluid={'water': 1})
+c1.set_attr(T=90, p=10, fluid={'Water': 1})
 c2.set_attr(p=13)
 c4.set_attr(T=65)
 
 nw.solve(mode="design")
 nw.print_results()
 # %%[sec_3]
 pipe_feed.set_attr(
```

### Comparing `TESPy-0.6.2/tutorial/basics/gas_turbine.py` & `TESPy-0.6.3/tutorial/basics/gas_turbine.py`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/tutorial/basics/heat_pump.py` & `TESPy-0.6.3/tutorial/basics/heat_pump.py`

 * *Files 2% similar despite different names*

```diff
@@ -5,23 +5,23 @@
 fluid_list = ['R134a']
 my_plant = Network(fluids=fluid_list)
 # %%[sec_2]
 # set the unitsystem for temperatures to C and for pressure to bar
 my_plant.set_attr(T_unit='C', p_unit='bar', h_unit='kJ / kg')
 # %%[sec_3]
 from tespy.components import (
-    CycleCloser, Compressor, Valve, HeatExchangerSimple
+    CycleCloser, Compressor, Valve, SimpleHeatExchanger
 )
 
 cc = CycleCloser('cycle closer')
 
 # heat sink
-co = HeatExchangerSimple('condenser')
+co = SimpleHeatExchanger('condenser')
 # heat source
-ev = HeatExchangerSimple('evaporator')
+ev = SimpleHeatExchanger('evaporator')
 
 va = Valve('expansion valve')
 cp = Compressor('compressor')
 # %%[sec_4]
 from tespy.connections import Connection
 
 # connections of heat pump
```

### Comparing `TESPy-0.6.2/tutorial/basics/rankine.py` & `TESPy-0.6.3/tutorial/basics/rankine.py`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/tutorial/heat_pump_exergy/NH3.py` & `TESPy-0.6.3/tutorial/heat_pump_exergy/NH3.py`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/tutorial/heat_pump_exergy/NH3_calculations.py` & `TESPy-0.6.3/tutorial/heat_pump_exergy/NH3_calculations.py`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/tutorial/heat_pump_exergy/R410A.py` & `TESPy-0.6.3/tutorial/heat_pump_exergy/R410A.py`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/tutorial/heat_pump_exergy/R410A_calculations.py` & `TESPy-0.6.3/tutorial/heat_pump_exergy/R410A_calculations.py`

 * *Files identical despite different names*

### Comparing `TESPy-0.6.2/tutorial/heat_pump_exergy/plots.py` & `TESPy-0.6.3/tutorial/heat_pump_exergy/plots.py`

 * *Files identical despite different names*

